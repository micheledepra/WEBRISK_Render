<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Risk Game - Analytics Dashboard</title>
    <!-- Add Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        @font-face {
            font-family: 'Mechfire';
            src: url('../res/Font/Second font/Mechfire-jq3v.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
            font-size: 14px; /* Body Text - 14px base */
            font-weight: 400;
            line-height: 1.5;
        }

        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }

        h1 {
            color: #667eea;
            font-size: 28px; /* Primary Header - 28px */
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.5px;
        }

        .connection-status {
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 12px; /* Supporting Text - 12px */
        }

        .connection-status.connected {
            background: #4caf50;
            color: white;
        }

        .connection-status.disconnected {
            background: #f44336;
            color: white;
        }

        /* Grid Layout for Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .chart-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .chart-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        }

        .chart-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 18px; /* Secondary Header - 18px */
            font-weight: 600;
            text-align: center;
            letter-spacing: -0.3px;
        }

        .chart-container {
            position: relative;
            height: 200px;
            margin-bottom: 8px;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px; /* Supporting Text - 12px */
            font-weight: 400;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Player Stats Section */
        .player-stats {
            overflow-x: auto;
            margin-bottom: 30px;
        }

        .player-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            position: relative;
            transition: transform 0.3s ease;
        }

        .player-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .player-card h4 {
            margin-bottom: 15px;
            font-size: 18px; /* Secondary Header - 18px */
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.3px;
        }

        .player-color-indicator {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 14px; /* Body Text - 14px */
            font-weight: 400;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-value {
            font-weight: 600;
            color: #667eea;
        }

        /* Player Overview Table */
        .player-overview-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .player-overview-table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .player-overview-table th {
            padding: 10px 8px;
            text-align: center;
            font-weight: 600;
            font-size: 11px; /* Micro Text - 11px */
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            white-space: nowrap;
        }

        .player-overview-table th:first-child {
            position: sticky;
            left: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 3;
            text-align: left;
            padding: 10px 12px;
        }

        /* Metric name headers with category colors */
        .player-overview-table th[data-category] {
            padding: 8px 6px;
            font-size: 10px; /* Micro Text - 10px */
            font-weight: 500;
            letter-spacing: 0.3px;
        }

        .player-overview-table th[data-category="ranking"] {
            background: linear-gradient(135deg, #fff4cc 0%, #ffe680 100%);
            color: #996600;
            border-right: 1px solid rgba(255, 215, 0, 0.3);
        }

        .player-overview-table th[data-category="overview"] {
            background: linear-gradient(135deg, #e6ecff 0%, #ccd9ff 100%);
            color: #3349b8;
            border-right: 1px solid rgba(102, 126, 234, 0.3);
        }

        .player-overview-table th[data-category="combat"] {
            background: linear-gradient(135deg, #ffe6f0 0%, #ffcce0 100%);
            color: #a30d47;
            border-right: 1px solid rgba(233, 30, 99, 0.3);
        }

        .player-overview-table th[data-category="strategic"] {
            background: linear-gradient(135deg, #e6f7e6 0%, #cceecc 100%);
            color: #2d6e2d;
            border-right: 1px solid rgba(76, 175, 80, 0.3);
        }

        .player-overview-table th.category-header {
            text-align: center;
            font-size: 12px; /* Supporting Text - 12px */
            font-weight: 700;
            padding: 10px 8px;
            border-top: 2px solid rgba(255, 255, 255, 0.3);
            letter-spacing: 0.5px;
        }

        .player-overview-table th.category-ranking {
            background: linear-gradient(135deg, #ffd700 0%, #ffb300 100%);
            color: #333;
        }

        .player-overview-table th.category-overview {
            background: linear-gradient(135deg, #667eea 0%, #4c63d2 100%);
            color: white;
        }

        .player-overview-table th.category-combat {
            background: linear-gradient(135deg, #e91e63 0%, #c2185b 100%);
            color: white;
        }

        .player-overview-table th.category-strategic {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
            color: white;
        }

        .player-overview-table tbody tr {
            transition: background-color 0.2s ease;
            border-left: 5px solid transparent;
        }

        .player-overview-table tbody tr:nth-child(odd) {
            background-color: #f8f9fa;
        }

        .player-overview-table tbody tr:hover {
            background-color: rgba(102, 126, 234, 0.1);
        }

        .player-overview-table td {
            padding: 10px 8px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px; /* Supporting Text - 13px */
            font-weight: 400;
            text-align: center;
        }

        .player-overview-table td:first-child {
            text-align: left;
            font-weight: 600;
            font-size: 14px; /* Body Text - 14px */
            position: sticky;
            left: 0;
            z-index: 1;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
            padding: 10px 12px;
        }

        .player-overview-table tbody tr:nth-child(odd) td:first-child {
            background-color: #f8f9fa;
        }

        .player-overview-table tbody tr:nth-child(even) td:first-child {
            background-color: white;
        }

        .player-overview-table tbody tr:hover td:first-child {
            background-color: rgba(102, 126, 234, 0.1);
        }

        .table-metric-value {
            font-weight: 600;
            padding: 3px 6px;
            border-radius: 3px;
            display: inline-block;
            font-size: 13px; /* Supporting Text - 13px */
        }

        .table-metric-rank {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
        }

        .table-metric-overview {
            color: #667eea;
        }

        .table-metric-combat {
            color: #e91e63;
        }

        .table-metric-strategic {
            color: #4caf50;
        }

        .table-territory-highlight {
            font-size: 0.8em;
            color: #666;
            font-style: italic;
        }

        /* Category Filter */
        .category-filter {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .category-filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .category-filter-header h4 {
            margin: 0;
            color: #667eea;
            font-size: 16px; /* Body Text - 16px */
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: -0.2px;
        }

        .category-filter-toggle {
            font-size: 18px; /* Secondary Header - 18px */
            color: #667eea;
            transition: transform 0.3s ease;
        }

        .category-filter-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .category-filter-content {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .category-filter-content.hidden {
            max-height: 0;
            margin-top: 0;
        }

        .category-filter-btn {
            padding: 8px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px; /* Supporting Text - 13px */
            transition: all 0.2s ease;
        }

        .category-filter-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .category-filter-btn.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .category-filter-btn.all {
            border-color: #333;
        }

        .category-filter-btn.all.active {
            background: linear-gradient(135deg, #333 0%, #555 100%);
        }

        .category-filter-btn.ranking.active {
            background: linear-gradient(135deg, #ffd700 0%, #ffb300 100%);
            color: #333;
            border-color: #ffd700;
        }

        .category-filter-btn.overview.active {
            background: linear-gradient(135deg, #667eea 0%, #4c63d2 100%);
            border-color: #667eea;
        }

        .category-filter-btn.combat.active {
            background: linear-gradient(135deg, #e91e63 0%, #c2185b 100%);
            border-color: #e91e63;
        }

        .category-filter-btn.strategic.active {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
            border-color: #4caf50;
        }

        /* Ranking Change Indicators */
        .rank-change-indicator {
            display: inline-block;
            margin-left: 8px;
            font-size: 16px; /* Body Text - 16px */
            font-weight: 700;
            animation: rankChange 0.5s ease;
        }

        .rank-change-up {
            color: #4caf50;
        }

        .rank-change-down {
            color: #f44336;
        }

        @keyframes rankChange {
            0% {
                transform: scale(0);
                opacity: 0;
            }
            50% {
                transform: scale(1.3);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Column visibility */
        .player-overview-table th.hidden-column,
        .player-overview-table td.hidden-column {
            display: none;
        }

        /* Dashboard Sections */
        .dashboard-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.03);
            border-radius: 8px;
            border-left: 4px solid #667eea;
            transition: all 0.3s ease;
        }

        .dashboard-section.dragging {
            opacity: 0.5;
            cursor: move;
        }

        .dashboard-section.drag-over {
            border-top: 4px solid #ffd700;
            margin-top: 20px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(102, 126, 234, 0.2);
            cursor: pointer;
            user-select: none;
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .section-drag-handle {
            cursor: move;
            font-size: 20px; /* Secondary Header - 20px */
            color: #999;
            opacity: 0;
            transition: opacity 0.2s ease;
            padding: 5px;
        }

        .dashboard-section.collapsed .section-drag-handle {
            opacity: 1;
        }

        .dashboard-section:hover .section-drag-handle {
            opacity: 0.5;
        }

        .dashboard-section.collapsed:hover .section-drag-handle {
            opacity: 1;
        }

        .section-drag-handle:hover {
            color: #667eea;
        }

        .section-title {
            color: #667eea;
            font-size: 22px; /* Secondary Header - 22px */
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.3px;
        }

        .section-collapse-toggle {
            background: none;
            border: none;
            font-size: 18px; /* Secondary Header - 18px */
            color: #667eea;
            cursor: pointer;
            padding: 3px 8px;
            transition: transform 0.3s ease, background 0.2s ease;
            border-radius: 6px;
        }

        .section-collapse-toggle:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .section-collapse-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .section-content {
            max-height: 5000px;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .section-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .dashboard-section.collapsed {
            padding: 12px 15px;
            margin-bottom: 10px;
            cursor: move;
        }

        .dashboard-section.collapsed .section-header {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .subsection-title {
            color: #764ba2;
            font-size: 18px; /* Secondary Header - 18px */
            font-weight: 600;
            margin: 20px 0 15px 0;
            text-align: center;
            letter-spacing: -0.3px;
        }

        /* Game Status Grid */
        .game-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .status-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #e8ebf0 100%);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .status-card-title {
            font-size: 12px; /* Supporting Text - 12px */
            font-weight: 600;
            color: #666;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            letter-spacing: 1px;
        }

        .status-card-value {
            font-size: 28px; /* Primary Header - 28px */
            font-weight: 700;
            color: #667eea;
            letter-spacing: -0.5px;
        }

        /* Continent Leaders Grid */
        .continent-leaders-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 10px 0;
        }

        .continent-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 12px;
            border: 3px solid #667eea;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
            min-height: 180px;
        }

        .continent-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .continent-info {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .continent-name {
            font-size: 16px; /* Body Text - 16px */
            font-weight: 700;
            color: #333;
            margin-bottom: 10px;
            letter-spacing: -0.2px;
        }

        .continent-details {
            font-size: 12px; /* Supporting Text - 12px */
            font-weight: 400;
            color: #666;
            line-height: 1.4;
        }

        .continent-mini-chart {
            width: 60px !important;
            height: 60px !important;
            min-width: 60px !important;
            min-height: 60px !important;
            max-width: 60px !important;
            max-height: 60px !important;
            margin: 10px 0;
        }

        /* Refresh Button */
        .refresh-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px; /* Body Text - 14px */
            font-weight: 600;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .refresh-btn:active {
            transform: translateY(0);
        }

        /* Loading Spinner */
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px; /* Secondary Header - 18px */
            font-weight: 600;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }

            .chart-container {
                height: 180px;
            }

            .continent-leaders-list {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 1024px) {
            .continent-leaders-list {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <div class="dashboard-header">
            <h1>üìä Risk Game Analytics Dashboard</h1>
            <div class="header-controls">
                <span id="connection-status" class="connection-status disconnected">Not Connected</span>
                <button class="refresh-btn" onclick="loadDashboardData()">üîÑ Refresh</button>
            </div>
        </div>

        <div id="loading" class="loading">Loading game data...</div>
        <div id="dashboard-content" style="display: none;">
            
            <!-- SECTION 1: PLAYER OVERVIEW -->
            <section class="dashboard-section" data-section-id="player-overview" data-section-order="2" draggable="false">
                <div class="section-header" onclick="toggleSection('player-overview')">
                    <div class="section-header-left">
                        <span class="section-drag-handle" draggable="true">‚ãÆ‚ãÆ</span>
                        <h2 class="section-title">üë• Player Overview</h2>
                    </div>
                    <button class="section-collapse-toggle" id="toggle-player-overview">‚ñº</button>
                </div>
                <div class="section-content" id="content-player-overview">
                    <!-- Category Filter -->
                    <div class="category-filter">
                        <div class="category-filter-header" onclick="toggleCategoryFilter()">
                            <h4>
                                <span>üîç Filter Columns by Category</span>
                            </h4>
                            <span class="category-filter-toggle" id="filter-toggle">‚ñº</span>
                        </div>
                        <div class="category-filter-content" id="filter-content">
                            <button class="category-filter-btn all" onclick="filterCategory('all')">All Categories</button>
                            <button class="category-filter-btn ranking" onclick="filterCategory('ranking')">üèÜ Ranking</button>
                            <button class="category-filter-btn overview active" onclick="filterCategory('overview')">üìä Player Overview</button>
                            <button class="category-filter-btn combat" onclick="filterCategory('combat')">‚öîÔ∏è Combat Efficiency</button>
                            <button class="category-filter-btn strategic" onclick="filterCategory('strategic')">üéØ Strategic Overview</button>
                        </div>
                    </div>
                    
                    <div id="player-stats" class="player-stats"></div>
                </div>
            </section>

            <!-- SECTION 2: HISTORICAL DATA TRACKING -->
            <section class="dashboard-section" data-section-id="historical-data" data-section-order="3" draggable="false">
                <div class="section-header" onclick="toggleSection('historical-data')">
                    <div class="section-header-left">
                        <span class="section-drag-handle" draggable="true">‚ãÆ‚ãÆ</span>
                        <h2 class="section-title">üìà Historical Data Tracking</h2>
                    </div>
                    <button class="section-collapse-toggle" id="toggle-historical-data">‚ñº</button>
                </div>
                <div class="section-content" id="content-historical-data">
                    <!-- Variable Selector -->
                    <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px; flex-wrap: wrap;">
                        <label style="font-weight: bold; color: #667eea;">Track Variable:</label>
                        <label style="cursor: pointer;">
                            <input type="radio" name="historicalVariable" value="power" checked onchange="updateHistoricalChart()">
                            <span style="margin-left: 5px;">Player Power</span>
                        </label>
                        <label style="cursor: pointer;">
                            <input type="radio" name="historicalVariable" value="territories" onchange="updateHistoricalChart()">
                            <span style="margin-left: 5px;">Territories</span>
                        </label>
                        <label style="cursor: pointer;">
                            <input type="radio" name="historicalVariable" value="armies" onchange="updateHistoricalChart()">
                            <span style="margin-left: 5px;">Armies</span>
                        </label>
                        <label style="cursor: pointer;">
                            <input type="radio" name="historicalVariable" value="reinforcements" onchange="updateHistoricalChart()">
                            <span style="margin-left: 5px;">Next Turn Reinforcements</span>
                        </label>
                        <label style="cursor: pointer;">
                            <input type="radio" name="historicalVariable" value="surplus" onchange="updateHistoricalChart()">
                            <span style="margin-left: 5px;">Turn Surplus/Deficit</span>
                        </label>
                    </div>
                    
                    <div class="chart-card">
                        <h3 id="historicalChartTitle">üìä Player Power Over Time</h3>
                        <div class="chart-container" style="height: 400px;">
                            <canvas id="historicalChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>

            <!-- SECTION 3: GLOBAL STATISTICS -->
            <section class="dashboard-section" data-section-id="global-statistics" data-section-order="1" draggable="false">
                <div class="section-header" onclick="toggleSection('global-statistics')">
                    <div class="section-header-left">
                        <span class="section-drag-handle" draggable="true">‚ãÆ‚ãÆ</span>
                        <h2 class="section-title">üåé Global Statistics</h2>
                    </div>
                    <button class="section-collapse-toggle" id="toggle-global-statistics">‚ñº</button>
                </div>
                <div class="section-content" id="content-global-statistics">
                    <div class="charts-grid">
                        <div class="chart-card">
                            <h3>üèÜ Player Power Ranking</h3>
                            <div class="chart-container" style="height: 180px;">
                                <canvas id="powerRankingChart"></canvas>
                            </div>
                        </div>
                        <div class="chart-card">
                            <h3>üìä Territory vs Army Comparison</h3>
                            <div class="chart-container" style="height: 180px;">
                                <canvas id="comparisonChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- SECTION 4: CONTINENT ANALYSIS -->
            <section class="dashboard-section" data-section-id="continent-analysis" data-section-order="4" draggable="false">
                <div class="section-header" onclick="toggleSection('continent-analysis')">
                    <div class="section-header-left">
                        <span class="section-drag-handle" draggable="true">‚ãÆ‚ãÆ</span>
                        <h2 class="section-title">üåç Continent Control Analysis</h2>
                    </div>
                    <button class="section-collapse-toggle" id="toggle-continent-analysis">‚ñº</button>
                </div>
                <div class="section-content" id="content-continent-analysis">
                    <!-- Metric Selector -->
                    <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; padding: 15px; background: rgba(102, 126, 234, 0.1); border-radius: 8px;">
                        <label style="font-weight: bold; color: #667eea;">View By:</label>
                        <label style="cursor: pointer;">
                            <input type="radio" name="continentMetric" value="territories" checked onchange="updateContinentMetric()">
                        <span style="margin-left: 5px;">Territories</span>
                    </label>
                    <label style="cursor: pointer;">
                        <input type="radio" name="continentMetric" value="armies" onchange="updateContinentMetric()">
                        <span style="margin-left: 5px;">Army Units</span>
                    </label>
                </div>
                
                <div class="chart-card" style="margin-bottom: 25px;">
                    <h3 id="continentControlTitle">üèÜ Territories Owned per Continent</h3>
                    <div class="chart-container">
                        <canvas id="continentControlChart"></canvas>
                    </div>
                </div>
                
                <div class="chart-card">
                    <h3 id="continentLeadersTitle">üó∫Ô∏è Continent Leaders (by Territories)</h3>
                    <div id="continent-leaders-list"></div>
                </div>
                </div>
            </section>

            <!-- SECTION 5: GAME STATUS -->
            <section class="dashboard-section" data-section-id="game-status" data-section-order="5" draggable="false">
                <div class="section-header" onclick="toggleSection('game-status')">
                    <div class="section-header-left">
                        <span class="section-drag-handle" draggable="true">‚ãÆ‚ãÆ</span>
                        <h2 class="section-title">üéÆ Game Status</h2>
                    </div>
                    <button class="section-collapse-toggle" id="toggle-game-status">‚ñº</button>
                </div>
                <div class="section-content" id="content-game-status">
                    <div id="game-status" class="game-status-grid"></div>
                </div>
            </section>

        </div>
    </div>

    <script>
        let chartInstances = {};
        let gameData = null;
        let playerColorMap = {};
        let lastDataTimestamp = 0;
        let continentMetric = 'territories'; // 'territories' or 'armies'
        let historicalVariable = 'power'; // 'power', 'territories', 'armies', 'reinforcements', 'surplus'
        let historicalData = []; // Array to store game state snapshots
        let previousRankings = {}; // Store previous turn rankings for comparison
        let currentCategoryFilter = 'overview'; // Default filter
        let sectionOrder = []; // Store custom section order
        let draggedSection = null; // Currently dragged section

        // Toggle section collapse/expand
        function toggleSection(sectionId) {
            const content = document.getElementById(`content-${sectionId}`);
            const toggle = document.getElementById(`toggle-${sectionId}`);
            const section = document.querySelector(`[data-section-id="${sectionId}"]`);
            
            if (content.classList.contains('collapsed')) {
                // Expand
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                section.classList.remove('collapsed');
                section.setAttribute('draggable', 'false');
            } else {
                // Collapse
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                section.classList.add('collapsed');
                section.setAttribute('draggable', 'true');
            }
            
            // Save collapsed state
            saveSectionStates();
        }

        // Initialize drag and drop functionality
        function initDragAndDrop() {
            const sections = document.querySelectorAll('.dashboard-section');
            
            sections.forEach(section => {
                // Handle drag start on the drag handle
                const dragHandle = section.querySelector('.section-drag-handle');
                
                dragHandle.addEventListener('mousedown', (e) => {
                    // Only allow dragging if section is collapsed
                    if (section.classList.contains('collapsed')) {
                        section.setAttribute('draggable', 'true');
                    }
                });
                
                section.addEventListener('dragstart', (e) => {
                    if (!section.classList.contains('collapsed')) {
                        e.preventDefault();
                        return;
                    }
                    draggedSection = section;
                    section.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                section.addEventListener('dragend', (e) => {
                    section.classList.remove('dragging');
                    section.setAttribute('draggable', 'false');
                    draggedSection = null;
                    
                    // Remove drag-over class from all sections
                    document.querySelectorAll('.dashboard-section').forEach(s => {
                        s.classList.remove('drag-over');
                    });
                });
                
                section.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (draggedSection && draggedSection !== section) {
                        section.classList.add('drag-over');
                    }
                });
                
                section.addEventListener('dragleave', (e) => {
                    section.classList.remove('drag-over');
                });
                
                section.addEventListener('drop', (e) => {
                    e.preventDefault();
                    section.classList.remove('drag-over');
                    
                    if (draggedSection && draggedSection !== section) {
                        // Reorder sections
                        const container = section.parentNode;
                        const draggedOrder = parseInt(draggedSection.dataset.sectionOrder);
                        const targetOrder = parseInt(section.dataset.sectionOrder);
                        
                        if (draggedOrder < targetOrder) {
                            container.insertBefore(draggedSection, section.nextSibling);
                        } else {
                            container.insertBefore(draggedSection, section);
                        }
                        
                        // Update order numbers
                        updateSectionOrder();
                        saveSectionOrder();
                    }
                });
            });
        }

        // Update section order after drag and drop
        function updateSectionOrder() {
            const sections = document.querySelectorAll('.dashboard-section');
            sections.forEach((section, index) => {
                section.dataset.sectionOrder = index + 1;
            });
        }

        // Save section order to localStorage
        function saveSectionOrder() {
            const sections = document.querySelectorAll('.dashboard-section');
            const order = Array.from(sections).map(s => s.dataset.sectionId);
            localStorage.setItem('dashboardSectionOrder', JSON.stringify(order));
            console.log('üíæ Saved section order:', order);
        }

        // Load and apply saved section order
        function loadSectionOrder() {
            const savedOrder = localStorage.getItem('dashboardSectionOrder');
            if (!savedOrder) return;
            
            try {
                const order = JSON.parse(savedOrder);
                const container = document.getElementById('dashboard-content');
                const sections = {};
                
                // Collect all sections
                document.querySelectorAll('.dashboard-section').forEach(section => {
                    sections[section.dataset.sectionId] = section;
                });
                
                // Reorder according to saved order
                order.forEach((sectionId, index) => {
                    if (sections[sectionId]) {
                        container.appendChild(sections[sectionId]);
                        sections[sectionId].dataset.sectionOrder = index + 1;
                    }
                });
                
                console.log('‚úÖ Restored section order:', order);
            } catch (e) {
                console.error('‚ùå Error loading section order:', e);
            }
        }

        // Save section collapsed states
        function saveSectionStates() {
            const states = {};
            document.querySelectorAll('.dashboard-section').forEach(section => {
                const sectionId = section.dataset.sectionId;
                states[sectionId] = section.classList.contains('collapsed');
            });
            localStorage.setItem('dashboardSectionStates', JSON.stringify(states));
        }

        // Load and apply saved section states
        function loadSectionStates() {
            const savedStates = localStorage.getItem('dashboardSectionStates');
            if (!savedStates) return;
            
            try {
                const states = JSON.parse(savedStates);
                Object.entries(states).forEach(([sectionId, isCollapsed]) => {
                    if (isCollapsed) {
                        const content = document.getElementById(`content-${sectionId}`);
                        const toggle = document.getElementById(`toggle-${sectionId}`);
                        const section = document.querySelector(`[data-section-id="${sectionId}"]`);
                        
                        if (content && toggle && section) {
                            content.classList.add('collapsed');
                            toggle.classList.add('collapsed');
                            section.classList.add('collapsed');
                            section.setAttribute('draggable', 'true');
                        }
                    }
                });
                console.log('‚úÖ Restored section states');
            } catch (e) {
                console.error('‚ùå Error loading section states:', e);
            }
        }

        // Update continent metric and refresh visualizations
        function updateContinentMetric() {
            const selectedMetric = document.querySelector('input[name="continentMetric"]:checked').value;
            continentMetric = selectedMetric;
            
            // Update titles
            if (continentMetric === 'armies') {
                document.getElementById('continentControlTitle').textContent = '‚öîÔ∏è Army Units Deployed per Continent';
                document.getElementById('continentLeadersTitle').textContent = 'üí™ Continent Leaders (by Army Units)';
            } else {
                document.getElementById('continentControlTitle').textContent = 'üèÜ Territories Owned per Continent';
                document.getElementById('continentLeadersTitle').textContent = 'üó∫Ô∏è Continent Leaders (by Territories)';
            }
            
            // Refresh the visualizations
            if (gameData) {
                visualizeContinentControl(gameData);
                visualizeContinentBreakdown(gameData);
            }
        }

        // Update historical chart variable and refresh
        function updateHistoricalChart() {
            const selectedVariable = document.querySelector('input[name="historicalVariable"]:checked').value;
            historicalVariable = selectedVariable;
            
            // Update title
            const titles = {
                'power': 'üìä Player Power Over Time',
                'territories': 'üó∫Ô∏è Territories Owned Over Time',
                'armies': '‚öîÔ∏è Army Strength Over Time',
                'reinforcements': 'üéØ Next Turn Reinforcements Over Time',
                'surplus': 'üìà Turn Surplus/Deficit Over Time'
            };
            document.getElementById('historicalChartTitle').textContent = titles[historicalVariable];
            
            // Refresh the visualization
            if (historicalData.length > 0) {
                visualizeHistoricalData();
            }
        }

        // Get consistent player color - ALWAYS use actual game colors
        function getPlayerColor(playerName) {
            if (playerColorMap[playerName]) {
                return playerColorMap[playerName];
            }
            // Log warning if color not found
            console.warn(`‚ö†Ô∏è No color found for player: ${playerName}. Available colors:`, playerColorMap);
            // Fallback only if no color is defined
            return '#999999';
        }

        // Initialize player colors from game data
        function initPlayerColors(data) {
            playerColorMap = {};
            
            // Option 1: Check if playerColors exists directly
            if (data.playerColors) {
                playerColorMap = { ...data.playerColors };
                console.log('üé® Player colors loaded from playerColors:', playerColorMap);
            }
            // Option 2: Extract colors from players object
            else if (data.players) {
                Object.entries(data.players).forEach(([playerName, playerData]) => {
                    if (playerData.color) {
                        playerColorMap[playerName] = playerData.color;
                    }
                });
                console.log('üé® Player colors extracted from players object:', playerColorMap);
            }
            // Option 3: Extract from territories owner color patterns
            else if (data.territories) {
                console.warn('‚ö†Ô∏è No player color data found, will use fallback colors');
            }
            
            console.log('üé® Final player color map:', playerColorMap);
            console.log('üé® Available players:', Object.keys(playerColorMap));
        }

        // Destroy existing chart if it exists
        function destroyChart(chartId) {
            if (chartInstances[chartId]) {
                chartInstances[chartId].destroy();
                delete chartInstances[chartId];
            }
        }

        // Create pie chart for territory distribution
        function createPieChart(canvasId, data, title) {
            destroyChart(canvasId);
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: data.labels,
                    datasets: [{
                        data: data.values,
                        backgroundColor: data.colors,
                        borderColor: '#fff',
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Create bar chart for continent control
        function createBarChart(canvasId, data, title) {
            destroyChart(canvasId);
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: data.labels,
                    datasets: data.datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            stacked: true
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                stepSize: 1
                            }
                        }
                    }
                }
            });
        }

        // Create custom legend
        function createCustomLegend(containerId, data) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            data.labels.forEach((label, index) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = data.colors[index];
                
                const text = document.createElement('span');
                text.textContent = `${label}: ${data.values[index]}`;
                
                item.appendChild(colorBox);
                item.appendChild(text);
                container.appendChild(item);
            });
        }

        // Load and visualize dashboard data
        function loadDashboardData() {
            console.log('üîÑ Checking for new dashboard data...');
            
            try {
                const rawData = localStorage.getItem('riskGameData');
                
                if (!rawData) {
                    console.warn('‚ö†Ô∏è No game data found');
                    document.getElementById('connection-status').textContent = 'No Data';
                    document.getElementById('connection-status').className = 'connection-status disconnected';
                    return;
                }
                
                const newGameData = JSON.parse(rawData);
                const newTimestamp = newGameData.timestamp || newGameData.lastUpdate || 0;
                
                // Only update if data has actually changed
                if (newTimestamp === lastDataTimestamp) {
                    console.log('‚è≠Ô∏è Data unchanged, skipping refresh');
                    return;
                }
                
                console.log('‚úÖ New game data detected! Timestamp:', newTimestamp, '(previous:', lastDataTimestamp, ')');
                lastDataTimestamp = newTimestamp;
                gameData = newGameData;
                
                // Capture historical data snapshot
                captureHistoricalSnapshot(gameData);
                
                // Initialize player colors FIRST
                initPlayerColors(gameData);
                
                // Update connection status
                document.getElementById('connection-status').textContent = '‚úì Connected';
                document.getElementById('connection-status').className = 'connection-status connected';
                
                // Show dashboard content
                document.getElementById('loading').style.display = 'none';
                document.getElementById('dashboard-content').style.display = 'block';
                
                // Visualize data in sections
                console.log('üìä Refreshing all visualizations...');
                displayPlayerStats(gameData);
                visualizePowerRanking(gameData);
                visualizeComparison(gameData);
                visualizeContinentControl(gameData);
                visualizeContinentBreakdown(gameData);
                visualizeHistoricalData();
                displayGameStatus(gameData);
                console.log('‚úÖ Dashboard refresh complete');
                
            } catch (error) {
                console.error('‚ùå Error loading dashboard data:', error);
                document.getElementById('connection-status').textContent = 'Error';
                document.getElementById('connection-status').className = 'connection-status disconnected';
            }
        }

        // Visualize global territory distribution
        function visualizeGlobalTerritories(gameData) {
            const territoryCounts = {};
            
            // Count territories per player
            Object.entries(gameData.territories).forEach(([territoryId, territory]) => {
                const owner = territory.owner;
                territoryCounts[owner] = (territoryCounts[owner] || 0) + 1;
            });
            
            const players = Object.keys(territoryCounts);
            const colors = players.map(player => {
                const color = getPlayerColor(player);
                console.log(`üé® Territory chart - ${player}: ${color}`);
                return color;
            });
            
            const chartData = {
                labels: players,
                values: Object.values(territoryCounts),
                colors: colors
            };
            
            createPieChart('globalTerritoryChart', chartData, 'Global Territory Distribution');
            createCustomLegend('globalLegend', chartData);
        }

        // Visualize army distribution
        function visualizeArmyDistribution(gameData) {
            const armyCounts = {};
            
            // Count total armies per player
            Object.entries(gameData.territories).forEach(([territoryId, territory]) => {
                const owner = territory.owner;
                armyCounts[owner] = (armyCounts[owner] || 0) + territory.armies;
            });
            
            const players = Object.keys(armyCounts);
            const colors = players.map(player => {
                const color = getPlayerColor(player);
                console.log(`üé® Army chart - ${player}: ${color}`);
                return color;
            });
            
            const chartData = {
                labels: players,
                values: Object.values(armyCounts),
                colors: colors
            };
            
            createPieChart('armyDistributionChart', chartData, 'Army Distribution');
            createCustomLegend('armyLegend', chartData);
        }

        // Visualize territory vs army comparison
        function visualizeComparison(gameData) {
            const continents = {
                'North America': {
                    territories: ['alaska', 'northwest territory', 'greenland', 'alberta', 'ontario', 'quebec', 'western united states', 'eastern united states', 'central america'],
                    bonus: 5
                },
                'South America': {
                    territories: ['venezuela', 'peru', 'brazil', 'argentina'],
                    bonus: 2
                },
                'Europe': {
                    territories: ['iceland', 'scandinavia', 'ukraine', 'great britain', 'northern europe', 'western europe', 'southern europe'],
                    bonus: 5
                },
                'Africa': {
                    territories: ['north africa', 'egypt', 'east africa', 'congo', 'south africa', 'madagascar'],
                    bonus: 3
                },
                'Asia': {
                    territories: ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 'mongolia', 'japan', 'afghanistan', 'china', 'middle east', 'india', 'siam'],
                    bonus: 7
                },
                'Australia': {
                    territories: ['indonesia', 'new guinea', 'western australia', 'eastern australia'],
                    bonus: 2
                }
            };

            const playerStats = {};
            
            Object.entries(gameData.territories).forEach(([territoryId, territory]) => {
                const owner = territory.owner;
                if (!playerStats[owner]) {
                    playerStats[owner] = { territories: 0, armies: 0, continents: [] };
                }
                playerStats[owner].territories++;
                playerStats[owner].armies += territory.armies;
            });
            
            // Check continent ownership for power calculation
            Object.entries(continents).forEach(([continentName, continentData]) => {
                const ownership = {};
                
                continentData.territories.forEach(territoryId => {
                    if (gameData.territories[territoryId]) {
                        const owner = gameData.territories[territoryId].owner;
                        ownership[owner] = (ownership[owner] || 0) + 1;
                    }
                });

                // Check if any player owns all territories in this continent
                Object.entries(ownership).forEach(([player, count]) => {
                    if (count === continentData.territories.length) {
                        playerStats[player].continents.push({
                            name: continentName,
                            bonus: continentData.bonus
                        });
                    }
                });
            });
            
            // Calculate power for each player and sort by ranking (highest first)
            const playerPower = Object.entries(playerStats).map(([player, stats]) => {
                const territoryBonus = stats.territories / 3;
                const continentBonus = stats.continents.reduce((sum, c) => sum + c.bonus, 0);
                const power = stats.armies + territoryBonus + continentBonus;
                
                return {
                    player,
                    power,
                    territories: stats.territories,
                    armies: stats.armies
                };
            });
            
            // Sort by power (descending - highest ranking first)
            playerPower.sort((a, b) => b.power - a.power);
            
            // Extract ordered players
            const players = playerPower.map(p => p.player);
            
            destroyChart('comparisonChart');
            const ctx = document.getElementById('comparisonChart').getContext('2d');
            
            chartInstances['comparisonChart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: players,
                    datasets: [
                        {
                            label: 'Territories',
                            data: players.map(p => playerStats[p].territories),
                            backgroundColor: players.map(p => getPlayerColor(p) + '80'),
                            borderColor: players.map(p => getPlayerColor(p)),
                            borderWidth: 2
                        },
                        {
                            label: 'Armies',
                            data: players.map(p => playerStats[p].armies),
                            backgroundColor: players.map(p => getPlayerColor(p) + 'CC'),
                            borderColor: players.map(p => getPlayerColor(p)),
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                font: { size: 10 },
                                padding: 8,
                                generateLabels: function(chart) {
                                    // Override legend box colors to grey
                                    const original = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                    original.forEach(label => {
                                        label.fillStyle = '#808080';  // Grey color
                                        label.strokeStyle = '#606060'; // Darker grey border
                                    });
                                    return original;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                font: { size: 9 }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                font: { size: 9 }
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 5,
                            bottom: 5,
                            left: 5,
                            right: 5
                        }
                    },
                    datasets: {
                        bar: {
                            barPercentage: 0.7,
                            categoryPercentage: 0.8
                        }
                    }
                }
            });
        }

        // Calculate player power ranking
        function visualizePowerRanking(gameData) {
            const continents = {
                'North America': {
                    territories: ['alaska', 'northwest territory', 'greenland', 'alberta', 'ontario', 'quebec', 'western united states', 'eastern united states', 'central america'],
                    bonus: 5
                },
                'South America': {
                    territories: ['venezuela', 'peru', 'brazil', 'argentina'],
                    bonus: 2
                },
                'Europe': {
                    territories: ['iceland', 'scandinavia', 'ukraine', 'great britain', 'northern europe', 'western europe', 'southern europe'],
                    bonus: 5
                },
                'Africa': {
                    territories: ['north africa', 'egypt', 'east africa', 'congo', 'south africa', 'madagascar'],
                    bonus: 3
                },
                'Asia': {
                    territories: ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 'mongolia', 'japan', 'afghanistan', 'china', 'middle east', 'india', 'siam'],
                    bonus: 7
                },
                'Australia': {
                    territories: ['indonesia', 'new guinea', 'western australia', 'eastern australia'],
                    bonus: 2
                }
            };

            // Calculate player stats
            const playerStats = {};
            
            Object.entries(gameData.territories).forEach(([territoryId, territory]) => {
                const owner = territory.owner;
                if (!playerStats[owner]) {
                    playerStats[owner] = { 
                        territories: 0, 
                        armies: 0,
                        continents: []
                    };
                }
                playerStats[owner].territories++;
                playerStats[owner].armies += territory.armies;
            });

            // Check continent ownership
            Object.entries(continents).forEach(([continentName, continentData]) => {
                const ownership = {};
                
                continentData.territories.forEach(territoryId => {
                    if (gameData.territories[territoryId]) {
                        const owner = gameData.territories[territoryId].owner;
                        ownership[owner] = (ownership[owner] || 0) + 1;
                    }
                });

                // Check if any player owns all territories in this continent
                Object.entries(ownership).forEach(([player, count]) => {
                    if (count === continentData.territories.length) {
                        playerStats[player].continents.push({
                            name: continentName,
                            bonus: continentData.bonus
                        });
                    }
                });
            });

            // Calculate power for each player
            const playerPower = Object.entries(playerStats).map(([player, stats]) => {
                const continentBonus = stats.continents.reduce((sum, c) => sum + c.bonus, 0);
                const territoryBonus = stats.territories / 3;
                const power = stats.armies + territoryBonus + continentBonus;
                
                // Build continent bonus text
                let continentText = '';
                if (stats.continents.length > 0) {
                    continentText = stats.continents.map(c => `${c.name} (+${c.bonus})`).join(', ');
                }

                return {
                    player,
                    power,
                    armies: stats.armies,
                    territories: stats.territories,
                    territoryBonus,
                    continentBonus,
                    continentText,
                    color: getPlayerColor(player)
                };
            });

            // Sort by power (descending)
            playerPower.sort((a, b) => b.power - a.power);

            // Create horizontal bar chart
            destroyChart('powerRankingChart');
            const ctx = document.getElementById('powerRankingChart').getContext('2d');

            const labels = playerPower.map(p => p.player);
            const data = playerPower.map(p => p.power);
            const colors = playerPower.map(p => p.color);

            chartInstances['powerRankingChart'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Power Score',
                        data: data,
                        backgroundColor: colors.map(c => c + 'CC'),
                        borderColor: colors,
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y', // Horizontal bars
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const playerData = playerPower[context.dataIndex];
                                    const lines = [];
                                    lines.push(`Power: ${playerData.power.toFixed(1)}`);
                                    lines.push(`  = ${playerData.armies} armies`);
                                    lines.push(`  + ${playerData.territoryBonus.toFixed(1)} (${playerData.territories}/3 territories)`);
                                    lines.push(`  + ${playerData.continentBonus} continent bonus`);
                                    if (playerData.continentText) {
                                        lines.push(`  [${playerData.continentText}]`);
                                    }
                                    return lines;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Power Score',
                                font: { size: 10 }
                            },
                            ticks: {
                                font: { size: 9 }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Player Ranking',
                                font: { size: 10 }
                            },
                            ticks: {
                                font: { size: 9 }
                            }
                        }
                    },
                    layout: {
                        padding: {
                            top: 5,
                            bottom: 5,
                            left: 5,
                            right: 5
                        }
                    },
                    datasets: {
                        bar: {
                            barPercentage: 0.7,
                            categoryPercentage: 0.8
                        }
                    }
                },
                plugins: [{
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        chart.data.datasets.forEach((dataset, datasetIndex) => {
                            const meta = chart.getDatasetMeta(datasetIndex);
                            meta.data.forEach((bar, index) => {
                                const playerData = playerPower[index];
                                const position = index + 1;
                                const text = `#${position} - ${playerData.power.toFixed(1)} (${playerData.armies}+${playerData.territoryBonus.toFixed(1)}+${playerData.continentBonus})`;
                                
                                ctx.fillStyle = '#fff';
                                ctx.font = '600 11px -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Arial, sans-serif'; /* Micro Text - 11px */
                                ctx.textAlign = 'left';
                                ctx.textBaseline = 'middle';
                                
                                const x = bar.x + 8;
                                const y = bar.y;
                                
                                ctx.fillText(text, x, y);
                            });
                        });
                    }
                }]
            });
        }

        // Capture historical snapshot of game state
        function captureHistoricalSnapshot(gameData) {
            const continents = {
                'North America': {
                    territories: ['alaska', 'northwest territory', 'greenland', 'alberta', 'ontario', 'quebec', 'western united states', 'eastern united states', 'central america'],
                    bonus: 5
                },
                'South America': {
                    territories: ['venezuela', 'peru', 'brazil', 'argentina'],
                    bonus: 2
                },
                'Europe': {
                    territories: ['iceland', 'scandinavia', 'ukraine', 'great britain', 'northern europe', 'western europe', 'southern europe'],
                    bonus: 5
                },
                'Africa': {
                    territories: ['north africa', 'egypt', 'east africa', 'congo', 'south africa', 'madagascar'],
                    bonus: 3
                },
                'Asia': {
                    territories: ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 'mongolia', 'japan', 'afghanistan', 'china', 'middle east', 'india', 'siam'],
                    bonus: 7
                },
                'Australia': {
                    territories: ['indonesia', 'new guinea', 'western australia', 'eastern australia'],
                    bonus: 2
                }
            };

            const turnNumber = gameData.turnNumber || gameData.currentTurn || historicalData.length + 1;
            
            // Check if we already have data for this turn
            if (historicalData.some(snap => snap.turn === turnNumber)) {
                return; // Don't duplicate
            }

            // Calculate player stats
            const playerStats = {};
            
            Object.entries(gameData.territories).forEach(([territoryId, territory]) => {
                const owner = territory.owner;
                if (!playerStats[owner]) {
                    playerStats[owner] = { 
                        territories: 0, 
                        armies: 0,
                        continents: [],
                        reinforcementsDeployed: 0,
                        unitsLost: 0
                    };
                }
                playerStats[owner].territories++;
                playerStats[owner].armies += territory.armies;
            });

            // Check continent ownership and calculate reinforcements
            Object.entries(continents).forEach(([continentName, continentData]) => {
                const ownership = {};
                
                continentData.territories.forEach(territoryId => {
                    if (gameData.territories[territoryId]) {
                        const owner = gameData.territories[territoryId].owner;
                        ownership[owner] = (ownership[owner] || 0) + 1;
                    }
                });

                Object.entries(ownership).forEach(([player, count]) => {
                    if (count === continentData.territories.length) {
                        playerStats[player].continents.push({
                            name: continentName,
                            bonus: continentData.bonus
                        });
                    }
                });
            });

            // Calculate metrics for each player
            const snapshot = {
                turn: turnNumber,
                timestamp: gameData.timestamp || Date.now(),
                players: {}
            };

            Object.entries(playerStats).forEach(([player, stats]) => {
                const continentBonus = stats.continents.reduce((sum, c) => sum + c.bonus, 0);
                const territoryBonus = Math.floor(stats.territories / 3);
                const reinforcements = Math.max(3, territoryBonus + continentBonus);
                const power = stats.armies + (stats.territories / 3) + continentBonus;
                
                // Try to get combat stats from gameData
                const combatStats = gameData.combatStats?.[player] || {};
                const reinforcementsDeployed = combatStats.reinforcementsDeployed || 0;
                const unitsLost = combatStats.unitsLost || 0;
                const surplus = reinforcementsDeployed - unitsLost;

                snapshot.players[player] = {
                    territories: stats.territories,
                    armies: stats.armies,
                    power: power,
                    reinforcements: reinforcements,
                    surplus: surplus,
                    reinforcementsDeployed: reinforcementsDeployed,
                    unitsLost: unitsLost
                };
            });

            historicalData.push(snapshot);
            console.log(`üìä Captured historical snapshot for turn ${turnNumber}:`, snapshot);
        }

        // Visualize historical data as line chart
        function visualizeHistoricalData() {
            if (historicalData.length === 0) {
                console.log('üìä No historical data available yet');
                return;
            }

            // Get all unique players across all snapshots
            const allPlayers = new Set();
            historicalData.forEach(snap => {
                Object.keys(snap.players).forEach(player => allPlayers.add(player));
            });

            // Prepare datasets for each player
            const datasets = Array.from(allPlayers).map(player => {
                const data = historicalData.map(snap => {
                    const playerData = snap.players[player];
                    if (!playerData) return null;
                    
                    switch(historicalVariable) {
                        case 'territories':
                            return playerData.territories;
                        case 'armies':
                            return playerData.armies;
                        case 'reinforcements':
                            return playerData.reinforcements;
                        case 'surplus':
                            return playerData.surplus;
                        case 'power':
                        default:
                            return playerData.power;
                    }
                });

                return {
                    label: player,
                    data: data,
                    borderColor: getPlayerColor(player),
                    backgroundColor: getPlayerColor(player) + '20',
                    borderWidth: 3,
                    pointRadius: 4,
                    pointHoverRadius: 6,
                    tension: 0.2,
                    fill: false
                };
            });

            // X-axis labels (turn numbers)
            const labels = historicalData.map(snap => `Turn ${snap.turn}`);

            // Create line chart
            destroyChart('historicalChart');
            const ctx = document.getElementById('historicalChart').getContext('2d');

            chartInstances['historicalChart'] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    return `Turn ${historicalData[context[0].dataIndex].turn}`;
                                },
                                label: function(context) {
                                    const playerName = context.dataset.label;
                                    const value = context.parsed.y;
                                    
                                    if (value === null) return null;
                                    
                                    switch(historicalVariable) {
                                        case 'territories':
                                            return `${playerName}: ${value} territories`;
                                        case 'armies':
                                            return `${playerName}: ${value} armies`;
                                        case 'reinforcements':
                                            return `${playerName}: ${value} reinforcements`;
                                        case 'surplus':
                                            return `${playerName}: ${value > 0 ? '+' : ''}${value} (surplus/deficit)`;
                                        case 'power':
                                        default:
                                            return `${playerName}: ${value.toFixed(1)} power`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Turn Number'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: getYAxisLabel()
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        // Get Y-axis label based on selected variable
        function getYAxisLabel() {
            switch(historicalVariable) {
                case 'territories':
                    return 'Number of Territories';
                case 'armies':
                    return 'Total Army Units';
                case 'reinforcements':
                    return 'Reinforcements Next Turn';
                case 'surplus':
                    return 'Turn Surplus/Deficit';
                case 'power':
                default:
                    return 'Player Power Score';
            }
        }


        // Visualize continent control
        function visualizeContinentControl(gameData) {
            const continents = {
                'North America': ['alaska', 'northwest territory', 'greenland', 'alberta', 'ontario', 'quebec', 'western united states', 'eastern united states', 'central america'],
                'South America': ['venezuela', 'peru', 'brazil', 'argentina'],
                'Europe': ['iceland', 'scandinavia', 'ukraine', 'great britain', 'northern europe', 'western europe', 'southern europe'],
                'Africa': ['north africa', 'egypt', 'east africa', 'congo', 'south africa', 'madagascar'],
                'Asia': ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 'mongolia', 'japan', 'afghanistan', 'china', 'middle east', 'india', 'siam'],
                'Australia': ['indonesia', 'new guinea', 'western australia', 'eastern australia']
            };
            
            const continentOwnership = {};
            
            // Calculate who owns territories/armies in each continent
            Object.entries(continents).forEach(([continentName, territories]) => {
                const owners = {};
                
                territories.forEach(territoryId => {
                    if (gameData.territories[territoryId]) {
                        const owner = gameData.territories[territoryId].owner;
                        if (continentMetric === 'armies') {
                            // Count armies
                            owners[owner] = (owners[owner] || 0) + gameData.territories[territoryId].armies;
                        } else {
                            // Count territories
                            owners[owner] = (owners[owner] || 0) + 1;
                        }
                    }
                });
                
                continentOwnership[continentName] = owners;
            });
            
            // Prepare data for stacked bar chart
            const players = [...new Set(Object.values(gameData.territories).map(t => t.owner))];
            const datasets = players.map(player => ({
                label: player,
                data: Object.keys(continentOwnership).map(continent => 
                    continentOwnership[continent][player] || 0
                ),
                backgroundColor: getPlayerColor(player),
                borderColor: '#fff',
                borderWidth: 1
            }));
            
            createBarChart('continentControlChart', {
                labels: Object.keys(continentOwnership),
                datasets: datasets
            }, 'Continent Control');
        }

        // Display player stats cards
        function displayPlayerStats(gameData) {
            const container = document.getElementById('player-stats');
            container.innerHTML = '';
            
            // Calculate comprehensive player metrics
            const playerMetrics = calculatePlayerMetrics(gameData);
            
            // Sort players by power ranking (descending)
            const sortedPlayers = Object.entries(playerMetrics).sort((a, b) => b[1].power - a[1].power);
            
            // Detect ranking changes
            const currentRankings = {};
            sortedPlayers.forEach(([playerName], index) => {
                currentRankings[playerName] = index + 1;
            });
            
            const rankChanges = detectRankingChanges(currentRankings);
            
            // Create table
            const table = document.createElement('table');
            table.className = 'player-overview-table';
            
            // Create table header
            table.innerHTML = `
                <thead>
                    <tr>
                        <th rowspan="2">Player</th>
                        <th class="category-header category-ranking" colspan="1">üèÜ Ranking</th>
                        <th class="category-header category-overview" colspan="4">üìä Player Overview</th>
                        <th class="category-header category-combat" colspan="3">‚öîÔ∏è Combat Efficiency</th>
                        <th class="category-header category-strategic" colspan="3">üéØ Strategic Overview</th>
                    </tr>
                    <tr>
                        <th data-category="ranking">Power</th>
                        <th data-category="overview">Territories</th>
                        <th data-category="overview">Armies</th>
                        <th data-category="overview">Avg Armies/Territory</th>
                        <th data-category="overview">Next Reinforcements</th>
                        <th data-category="combat">Previous Turn</th>
                        <th data-category="combat">Worst Turn</th>
                        <th data-category="combat">Avg S/D</th>
                        <th data-category="strategic">Strongest Continent</th>
                        <th data-category="strategic">David & Goliath</th>
                        <th data-category="strategic">Achilles' Heel</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            
            const tbody = table.querySelector('tbody');
            
            // Add rows for each player
            sortedPlayers.forEach(([playerName, metrics], index) => {
                const row = document.createElement('tr');
                row.style.borderLeftColor = metrics.color;
                
                // Add player name cell with color indicator and ranking change
                const playerCell = document.createElement('td');
                const rankChange = rankChanges[playerName];
                let rankIndicator = '';
                
                if (rankChange && rankChange !== 0) {
                    if (rankChange > 0) {
                        rankIndicator = `<span class="rank-change-indicator rank-change-up" title="Moved up ${rankChange} position(s)">‚Üë</span>`;
                    } else {
                        rankIndicator = `<span class="rank-change-indicator rank-change-down" title="Moved down ${Math.abs(rankChange)} position(s)">‚Üì</span>`;
                    }
                }
                
                playerCell.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 14px; height: 14px; border-radius: 50%; background: ${metrics.color}; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
                        <span style="font-weight: 600;">${playerName}</span>
                        ${rankIndicator}
                    </div>
                `;
                row.appendChild(playerCell);
                
                // RANKING: Power
                const powerCell = createMetricCell(metrics.power.toFixed(1), 'rank');
                powerCell.setAttribute('data-category', 'ranking');
                row.appendChild(powerCell);
                
                // PLAYER OVERVIEW: Territories, Armies, Avg Armies/Territory, Next Reinforcements
                const territoriesCell = createMetricCell(metrics.territories, 'overview');
                territoriesCell.setAttribute('data-category', 'overview');
                row.appendChild(territoriesCell);
                
                const armiesCell = createMetricCell(metrics.armies, 'overview');
                armiesCell.setAttribute('data-category', 'overview');
                row.appendChild(armiesCell);
                
                const avgArmiesCell = createMetricCell(metrics.avgArmiesPerTerritory.toFixed(1), 'overview');
                avgArmiesCell.setAttribute('data-category', 'overview');
                row.appendChild(avgArmiesCell);
                
                const reinforcementsCell = createMetricCell(metrics.nextReinforcements, 'overview');
                reinforcementsCell.setAttribute('data-category', 'overview');
                row.appendChild(reinforcementsCell);
                
                // COMBAT EFFICIENCY: Previous Turn S/D, Worst Turn S/D, Avg S/D
                const prevTurnCell = createMetricCell(formatSurplusDeficit(metrics.previousTurnSD), 'combat');
                prevTurnCell.setAttribute('data-category', 'combat');
                row.appendChild(prevTurnCell);
                
                const worstTurnCell = createMetricCell(formatSurplusDeficit(metrics.worstTurnSD), 'combat');
                worstTurnCell.setAttribute('data-category', 'combat');
                row.appendChild(worstTurnCell);
                
                const avgSDCell = createMetricCell(formatSurplusDeficit(metrics.avgSD), 'combat');
                avgSDCell.setAttribute('data-category', 'combat');
                row.appendChild(avgSDCell);
                
                // STRATEGIC OVERVIEW: Strongest Continent, David & Goliath, Achilles' Heel
                const continentCell = createMetricCell(metrics.strongestContinent || 'None', 'strategic', true);
                continentCell.setAttribute('data-category', 'strategic');
                row.appendChild(continentCell);
                
                const davidGoliathCell = createMetricCell(metrics.davidGoliath || 'N/A', 'strategic', true);
                davidGoliathCell.setAttribute('data-category', 'strategic');
                row.appendChild(davidGoliathCell);
                
                const achillesCell = createMetricCell(metrics.achillesHeel || 'N/A', 'strategic', true);
                achillesCell.setAttribute('data-category', 'strategic');
                row.appendChild(achillesCell);
                
                tbody.appendChild(row);
            });
            
            container.appendChild(table);
            
            // Apply initial filter (default to overview)
            applyCurrentFilter();
        }

        // Helper function to create metric cells
        function createMetricCell(value, type, isTerritory = false) {
            const cell = document.createElement('td');
            const span = document.createElement('span');
            span.className = `table-metric-value table-metric-${type}`;
            if (isTerritory) {
                span.className += ' table-territory-highlight';
            }
            span.textContent = value;
            cell.appendChild(span);
            return cell;
        }

        // Format surplus/deficit values
        function formatSurplusDeficit(value) {
            if (value === null || value === undefined || value === 'N/A') return 'N/A';
            const num = parseFloat(value);
            if (isNaN(num)) return 'N/A';
            return num > 0 ? `+${num.toFixed(1)}` : num.toFixed(1);
        }

        // Calculate comprehensive player metrics
        function calculatePlayerMetrics(gameData) {
            const continents = {
                'North America': {
                    territories: ['alaska', 'northwest territory', 'greenland', 'alberta', 'ontario', 'quebec', 'western united states', 'eastern united states', 'central america'],
                    bonus: 5
                },
                'South America': {
                    territories: ['venezuela', 'peru', 'brazil', 'argentina'],
                    bonus: 2
                },
                'Europe': {
                    territories: ['iceland', 'scandinavia', 'ukraine', 'great britain', 'northern europe', 'western europe', 'southern europe'],
                    bonus: 5
                },
                'Africa': {
                    territories: ['north africa', 'egypt', 'east africa', 'congo', 'south africa', 'madagascar'],
                    bonus: 3
                },
                'Asia': {
                    territories: ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 'mongolia', 'japan', 'afghanistan', 'china', 'middle east', 'india', 'siam'],
                    bonus: 7
                },
                'Australia': {
                    territories: ['indonesia', 'new guinea', 'western australia', 'eastern australia'],
                    bonus: 2
                }
            };

            const playerMetrics = {};
            
            // Initialize player stats from territories
            Object.entries(gameData.territories).forEach(([territoryId, territory]) => {
                const owner = territory.owner;
                if (!playerMetrics[owner]) {
                    playerMetrics[owner] = {
                        territories: 0,
                        armies: 0,
                        color: getPlayerColor(owner),
                        continentUnits: {}, // Track units per continent
                        territoryRatios: [] // Store attacker/defender ratios
                    };
                }
                playerMetrics[owner].territories++;
                playerMetrics[owner].armies += territory.armies;
                
                // Track which continent this territory belongs to
                for (const [continentName, continentData] of Object.entries(continents)) {
                    if (continentData.territories.includes(territoryId)) {
                        if (!playerMetrics[owner].continentUnits[continentName]) {
                            playerMetrics[owner].continentUnits[continentName] = 0;
                        }
                        playerMetrics[owner].continentUnits[continentName] += territory.armies;
                        break;
                    }
                }
                
                // Calculate attacker/defender ratios for neighboring territories
                if (territory.neighbors && Array.isArray(territory.neighbors)) {
                    territory.neighbors.forEach(neighborId => {
                        const neighbor = gameData.territories[neighborId];
                        if (neighbor && neighbor.owner !== owner) {
                            const ratio = territory.armies / neighbor.armies;
                            playerMetrics[owner].territoryRatios.push({
                                territory: territoryId,
                                ratio: ratio,
                                attackingArmy: territory.armies,
                                defendingArmy: neighbor.armies
                            });
                        }
                    });
                }
            });

            // Calculate derived metrics for each player
            Object.keys(playerMetrics).forEach(player => {
                const stats = playerMetrics[player];
                
                // Basic calculations
                stats.avgArmiesPerTerritory = stats.territories > 0 ? stats.armies / stats.territories : 0;
                
                // Calculate continent bonuses
                let continentBonus = 0;
                Object.entries(continents).forEach(([continentName, continentData]) => {
                    const playerTerritories = continentData.territories.filter(tid => 
                        gameData.territories[tid] && gameData.territories[tid].owner === player
                    );
                    if (playerTerritories.length === continentData.territories.length) {
                        continentBonus += continentData.bonus;
                    }
                });
                
                // Calculate next turn reinforcements
                const territoryBonus = Math.floor(stats.territories / 3);
                stats.nextReinforcements = Math.max(3, territoryBonus + continentBonus);
                
                // Calculate player power
                stats.power = stats.armies + (stats.territories / 3) + continentBonus;
                
                // Combat efficiency metrics from historical data
                const playerHistory = historicalData
                    .filter(snap => snap.players && snap.players[player])
                    .map(snap => snap.players[player]);
                
                if (playerHistory.length > 0) {
                    // Previous turn surplus/deficit
                    stats.previousTurnSD = playerHistory.length > 0 ? 
                        (playerHistory[playerHistory.length - 1].surplus || 0) : 0;
                    
                    // Worst turn surplus/deficit
                    const surplusValues = playerHistory.map(h => h.surplus || 0).filter(v => v !== 0);
                    stats.worstTurnSD = surplusValues.length > 0 ? Math.min(...surplusValues) : 0;
                    
                    // Average surplus/deficit
                    const avgSurplus = surplusValues.length > 0 ? 
                        surplusValues.reduce((a, b) => a + b, 0) / surplusValues.length : 0;
                    stats.avgSD = avgSurplus;
                } else {
                    stats.previousTurnSD = 'N/A';
                    stats.worstTurnSD = 'N/A';
                    stats.avgSD = 'N/A';
                }
                
                // Strategic overview metrics
                
                // 1. Strongest continent (most units concentrated)
                if (Object.keys(stats.continentUnits).length > 0) {
                    const strongestContinent = Object.entries(stats.continentUnits)
                        .sort((a, b) => b[1] - a[1])[0];
                    stats.strongestContinent = `${strongestContinent[0]} (${strongestContinent[1]} units)`;
                } else {
                    stats.strongestContinent = 'None';
                }
                
                // 2. David & Goliath - territory with highest attacker/defender ratio
                if (stats.territoryRatios.length > 0) {
                    const davidGoliath = stats.territoryRatios.sort((a, b) => b.ratio - a.ratio)[0];
                    stats.davidGoliath = `${formatTerritoryName(davidGoliath.territory)} (${davidGoliath.ratio.toFixed(1)}:1)`;
                } else {
                    stats.davidGoliath = 'N/A';
                }
                
                // 3. Achilles' Heel - territory with lowest attacker/defender ratio
                if (stats.territoryRatios.length > 0) {
                    const achillesHeel = stats.territoryRatios.sort((a, b) => a.ratio - b.ratio)[0];
                    stats.achillesHeel = `${formatTerritoryName(achillesHeel.territory)} (${achillesHeel.ratio.toFixed(1)}:1)`;
                } else {
                    stats.achillesHeel = 'N/A';
                }
            });
            
            return playerMetrics;
        }

        // Format territory names for display
        function formatTerritoryName(territoryId) {
            return territoryId
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        // Detect ranking changes compared to previous turn
        function detectRankingChanges(currentRankings) {
            const changes = {};
            
            Object.keys(currentRankings).forEach(playerName => {
                const currentRank = currentRankings[playerName];
                const previousRank = previousRankings[playerName];
                
                if (previousRank !== undefined) {
                    // Positive change means improvement (moved up in rank)
                    // Negative change means decline (moved down in rank)
                    changes[playerName] = previousRank - currentRank;
                } else {
                    changes[playerName] = 0; // New player, no change
                }
            });
            
            // Update previous rankings for next comparison
            previousRankings = { ...currentRankings };
            
            return changes;
        }

        // Toggle category filter visibility
        function toggleCategoryFilter() {
            const content = document.getElementById('filter-content');
            const toggle = document.getElementById('filter-toggle');
            
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                toggle.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
            } else {
                content.classList.add('hidden');
                toggle.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
            }
        }

        // Filter table columns by category
        function filterCategory(category) {
            currentCategoryFilter = category;
            
            // Update button states
            document.querySelectorAll('.category-filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Apply filter
            applyCurrentFilter();
        }

        // Apply the current filter to the table
        function applyCurrentFilter() {
            const table = document.querySelector('.player-overview-table');
            if (!table) return;
            
            const category = currentCategoryFilter;
            
            // Get all headers and cells with data-category attribute
            const headers = table.querySelectorAll('th[data-category]');
            const cells = table.querySelectorAll('td[data-category]');
            
            if (category === 'all') {
                // Show all columns
                headers.forEach(header => header.classList.remove('hidden-column'));
                cells.forEach(cell => cell.classList.remove('hidden-column'));
                
                // Show all category headers
                table.querySelectorAll('.category-header').forEach(header => {
                    header.classList.remove('hidden-column');
                });
            } else {
                // Hide/show based on category
                headers.forEach(header => {
                    const headerCategory = header.getAttribute('data-category');
                    if (headerCategory === category) {
                        header.classList.remove('hidden-column');
                    } else {
                        header.classList.add('hidden-column');
                    }
                });
                
                cells.forEach(cell => {
                    const cellCategory = cell.getAttribute('data-category');
                    if (cellCategory === category) {
                        cell.classList.remove('hidden-column');
                    } else {
                        cell.classList.add('hidden-column');
                    }
                });
                
                // Hide/show category headers
                table.querySelectorAll('.category-header').forEach(header => {
                    if (header.classList.contains(`category-${category}`)) {
                        header.classList.remove('hidden-column');
                    } else {
                        header.classList.add('hidden-column');
                    }
                });
            }
        }

        // Visualize continent territory breakdown with mini inline charts
        function visualizeContinentBreakdown(gameData) {
            const container = document.getElementById('continent-leaders-list');
            if (!container) return;
            
            container.className = 'continent-leaders-list';
            container.innerHTML = '';
            
            // Log all territory IDs to debug
            console.log('üìç All territory IDs in game data:', Object.keys(gameData.territories));
            
            const continents = {
                'North America': ['alaska', 'northwest territory', 'greenland', 'alberta', 'ontario', 'quebec', 'western united states', 'eastern united states', 'central america'],
                'South America': ['venezuela', 'peru', 'brazil', 'argentina'],
                'Europe': ['iceland', 'scandinavia', 'ukraine', 'great britain', 'northern europe', 'western europe', 'southern europe'],
                'Africa': ['north africa', 'egypt', 'east africa', 'congo', 'south africa', 'madagascar'],
                'Asia': ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 'mongolia', 'japan', 'afghanistan', 'china', 'middle east', 'india', 'siam'],
                'Australia': ['indonesia', 'new guinea', 'western australia', 'eastern australia']
            };
            
            Object.entries(continents).forEach(([continentName, territories]) => {
                const owners = {};
                let totalCount = 0; // Total territories or armies
                let foundCount = 0;
                let notFoundTerritories = [];
                
                // Count territories or armies per player
                territories.forEach(territoryId => {
                    if (gameData.territories[territoryId]) {
                        const owner = gameData.territories[territoryId].owner;
                        const territory = gameData.territories[territoryId];
                        
                        if (continentMetric === 'armies') {
                            owners[owner] = (owners[owner] || 0) + territory.armies;
                            totalCount += territory.armies;
                        } else {
                            owners[owner] = (owners[owner] || 0) + 1;
                            totalCount++;
                        }
                        foundCount++;
                    } else {
                        notFoundTerritories.push(territoryId);
                    }
                });
                
                // Debug logging
                if (notFoundTerritories.length > 0) {
                    console.warn(`‚ö†Ô∏è ${continentName}: Missing ${notFoundTerritories.length} territories:`, notFoundTerritories);
                }
                console.log(`‚úÖ ${continentName}: Found ${foundCount}/${territories.length} territories`);

                
                // Find max count (territory or army count)
                const maxCount = Math.max(...Object.values(owners));
                
                // Find all players with max count (ties)
                const leaders = Object.entries(owners)
                    .filter(([player, count]) => count === maxCount)
                    .map(([player, count]) => ({ player, count }));
                
                // Create continent item
                const continentItem = document.createElement('div');
                continentItem.className = 'continent-item';
                
                // Determine border color based on leadership
                let borderColor = '#667eea';
                if (leaders.length === 1) {
                    borderColor = getPlayerColor(leaders[0].player);
                }
                continentItem.style.borderColor = borderColor;
                
                // Build leader text (shortened)
                let leaderText = '';
                const metricLabel = continentMetric === 'armies' ? 'units' : 'terr.';
                
                if (leaders.length === 1) {
                    const percentage = ((leaders[0].count / totalCount) * 100).toFixed(0);
                    const isFullControl = continentMetric === 'territories' ? 
                        leaders[0].count === territories.length : 
                        Object.keys(owners).length === 1;
                    const crown = isFullControl ? ' üëë' : '';
                    leaderText = `<strong style="color: ${getPlayerColor(leaders[0].player)}">${leaders[0].player}</strong>${crown}<br>${leaders[0].count} ${metricLabel} (${percentage}%)`;
                } else {
                    const playerNames = leaders.map(l => `<strong style="color: ${getPlayerColor(l.player)}">${l.player}</strong>`).join(' & ');
                    leaderText = `${playerNames}<br>Tied ${maxCount} ${metricLabel}`;
                }
                
                // Create unique canvas ID
                const canvasId = `mini-chart-${continentName.replace(/\s+/g, '-').toLowerCase()}`;
                
                continentItem.innerHTML = `
                    <div class="continent-info">
                        <div class="continent-name">${continentName}</div>
                        <canvas id="${canvasId}" class="continent-mini-chart"></canvas>
                        <div class="continent-details">${leaderText}</div>
                    </div>
                `;
                
                container.appendChild(continentItem);
                
                // Create mini pie chart after DOM is ready
                setTimeout(() => {
                    createMiniPieChart(canvasId, leaders, maxCount, totalCount);
                }, 0);
            });
        }

        // Create mini pie chart for continent leaders
        function createMiniPieChart(canvasId, leaders, leaderCount, totalTerritories) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            destroyChart(canvasId);
            const ctx = canvas.getContext('2d');
            
            let chartData, chartColors;
            
            if (leaders.length === 1) {
                // Single leader - show leader's portion vs rest
                const leaderPortion = leaderCount;
                const restPortion = totalTerritories - leaderCount;
                
                chartData = [leaderPortion, restPortion];
                chartColors = [
                    getPlayerColor(leaders[0].player),
                    '#d0d0d0'  // Grey for unclaimed
                ];
            } else {
                // Multiple leaders tied - split equally among them
                const leaderPortion = leaderCount;
                const eachLeaderSlice = leaderPortion / leaders.length;
                const restPortion = totalTerritories - (leaders.length * leaderPortion);
                
                chartData = [];
                chartColors = [];
                
                // Add slice for each tied leader
                leaders.forEach(leader => {
                    chartData.push(leaderCount);
                    chartColors.push(getPlayerColor(leader.player));
                });
                
                // Add rest if any
                if (restPortion > 0) {
                    chartData.push(restPortion);
                    chartColors.push('#d0d0d0');
                }
            }
            
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'pie',
                data: {
                    datasets: [{
                        data: chartData,
                        backgroundColor: chartColors,
                        borderColor: '#fff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    }
                }
            });
        }

        // Display game status
        function displayGameStatus(gameData) {
            const container = document.getElementById('game-status');
            container.innerHTML = '';
            
            // Calculate total territories
            const totalTerritories = Object.keys(gameData.territories).length;
            
            // Calculate total armies
            const totalArmies = Object.values(gameData.territories).reduce((sum, t) => sum + t.armies, 0);
            
            // Count players
            const players = [...new Set(Object.values(gameData.territories).map(t => t.owner))];
            const playerCount = players.length;
            
            // Find leader
            const playerTerritories = {};
            Object.values(gameData.territories).forEach(t => {
                playerTerritories[t.owner] = (playerTerritories[t.owner] || 0) + 1;
            });
            const leader = Object.entries(playerTerritories).sort((a, b) => b[1] - a[1])[0];
            
            // Get current turn/phase if available
            const currentTurn = gameData.currentTurn || gameData.turnNumber || 'N/A';
            const currentPhase = gameData.currentPhase || 'Unknown';
            
            const statusItems = [
                { title: 'Total Territories', value: totalTerritories },
                { title: 'Total Armies', value: totalArmies },
                { title: 'Active Players', value: playerCount },
                { title: 'Current Leader', value: leader[0], color: getPlayerColor(leader[0]) },
                { title: 'Turn Number', value: currentTurn },
                { title: 'Current Phase', value: currentPhase }
            ];
            
            statusItems.forEach(item => {
                const card = document.createElement('div');
                card.className = 'status-card';
                card.innerHTML = `
                    <div class="status-card-title">${item.title}</div>
                    <div class="status-card-value" style="color: ${item.color || '#667eea'}">${item.value}</div>
                `;
                container.appendChild(card);
            });
        }

        // Listen for storage changes from game.html (primary sync method)
        window.addEventListener('storage', function(e) {
            if (e.key === 'riskGameData' || e.key === 'riskDashboardData') {
                console.log('üì° Storage event detected - game data updated');
                loadDashboardData();
            }
        });

        // Listen for custom events from game window
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'riskGameUpdate') {
                console.log('üì° PostMessage received - game data updated');
                loadDashboardData();
            }
        });

        // Broadcast channel communication (modern browsers) - most reliable method
        if ('BroadcastChannel' in window) {
            const gameChannel = new BroadcastChannel('risk-game-updates');
            gameChannel.addEventListener('message', function(event) {
                if (event.data && event.data.type === 'gameStateUpdated') {
                    console.log('üì° BroadcastChannel message received');
                    loadDashboardData();
                }
            });
            console.log('‚úÖ BroadcastChannel listener initialized');
        } else {
            console.warn('‚ö†Ô∏è BroadcastChannel not supported, using storage events only');
        }

        // Fallback: Check for updates every 5 seconds (only as backup)
        setInterval(function() {
            console.log('üîç Fallback check for updates...');
            loadDashboardData();
        }, 5000);

        // Initial load on page ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üìä Dashboard initialized - waiting for game data...');
            
            // Initialize drag and drop functionality
            initDragAndDrop();
            
            // Load saved section order and states
            loadSectionOrder();
            loadSectionStates();
            
            // Load dashboard data
            loadDashboardData();
        });
    </script>
</body>
</html>
