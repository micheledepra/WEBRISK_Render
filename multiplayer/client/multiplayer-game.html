<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Risk Multiplayer Game</title>
  <link rel="icon" type="image/x-icon" href="../../favicon.ico">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="../../js/firebase-config.js"></script>
  
  <!-- Import ALL game.html styles -->
  <link rel="stylesheet" href="../../css/combat-system.css">
  <link rel="stylesheet" href="../../css/combat-animations.css">
  <link rel="stylesheet" href="../../css/combat-testing.css">
  <link rel="stylesheet" href="../../css/army-counts.css">
  
  <style>
    /* Import game.html font definitions */
    @font-face {
      font-family: 'Australian Flying Corps Stencil';
      src: url('../../res/Font/Australianflyingcorpsstencil-gpR1.ttf') format('truetype');
      font-weight: 300;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Mechfire';
      src: url('../../res/Font/Second font/Mechfire-jq3v.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Mechfire';
      src: url('../../res/Font/Second font/MechfireBold-z1e1.ttf') format('truetype');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    /* Custom cursor */
    * {
      cursor: url('../../images/cursor1-32x32.png'), auto;
    }

    .custom-cursor {
      position: fixed;
      width: 32px;
      height: 32px;
      pointer-events: none;
      z-index: 99999;
      transition: transform 0.1s ease;
      filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.5));
    }

    .custom-cursor img {
      width: 100%;
      height: 100%;
    }

    .custom-cursor.clicking {
      transform: rotate(-15deg) scale(0.9);
    }

    body.custom-cursor-active * {
      cursor: none !important;
    }

    /* ============================================
       MULTIPLAYER OVERLAY - NON-INTRUSIVE LAYER
       ============================================ */
    
    /* Multiplayer HUD - Top bar overlay */
    #multiplayer-hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%);
      border-bottom: 3px solid #ffd700;
      display: none;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 10000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }
    
    #multiplayer-hud.active {
      display: flex;
    }
    
    #multiplayer-hud .session-info {
      display: flex;
      align-items: center;
      gap: 20px;
      color: #ffd700;
      font-weight: bold;
      font-size: 1.1em;
    }
    
    #multiplayer-hud .session-code {
      background: rgba(255, 215, 0, 0.2);
      padding: 8px 16px;
      border-radius: 8px;
      border: 2px solid #ffd700;
      font-size: 1.3em;
      letter-spacing: 0.2em;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    #multiplayer-hud .session-code:hover {
      background: rgba(255, 215, 0, 0.3);
      transform: scale(1.05);
    }
    
    #multiplayer-hud .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.9em;
    }
    
    #multiplayer-hud .connection-status.connected {
      background: rgba(0, 255, 0, 0.1);
      border: 2px solid #0f3;
      color: #0f3;
    }
    
    #multiplayer-hud .connection-status.connecting {
      background: rgba(255, 193, 7, 0.1);
      border: 2px solid #ffc107;
      color: #ffc107;
    }
    
    #multiplayer-hud .connection-status.disconnected {
      background: rgba(244, 67, 54, 0.1);
      border: 2px solid #f44336;
      color: #f44336;
    }
    
    #multiplayer-hud .online-players {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #eee;
    }
    
    #multiplayer-hud .player-dot {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    #multiplayer-hud .player-dot:hover {
      transform: scale(1.2);
    }
    
    #multiplayer-hud .player-dot.current-turn {
      box-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
      animation: pulse-turn 2s infinite;
    }
    
    @keyframes pulse-turn {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }
    
    /* Loading screen */
    #mp-loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 20000;
      flex-direction: column;
      color: #ffd700;
    }
    
    #mp-loading-screen .spinner {
      width: 60px;
      height: 60px;
      border: 6px solid rgba(255, 215, 0, 0.1);
      border-top-color: #ffd700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Push game content down when HUD is visible */
    body.multiplayer-active #game-root {
      margin-top: 60px;
      height: calc(100vh - 60px);
      overflow: hidden;
    }
    
    /* Copy notification */
    .copy-notification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      background: #4caf50;
      color: white;
      padding: 15px 30px;
      border-radius: 8px;
      font-weight: bold;
      z-index: 10001;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .copy-notification.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    
    /* Waiting overlay - when not player's turn */
    #waiting-overlay {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      pointer-events: none;
    }
    
    #waiting-overlay.active {
      display: flex;
    }
    
    #waiting-overlay .waiting-message {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #ffd700;
      border-radius: 20px;
      padding: 40px 60px;
      text-align: center;
      color: #ffd700;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }
    
    #waiting-overlay .waiting-message h2 {
      margin: 0 0 15px 0;
      font-size: 2em;
    }
    
    /* Player mapping badge */
    .player-mapping-badge {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      border: 2px solid #90caf9;
      font-size: 1em;
      font-weight: bold;
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-mapping-badge .player-color-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    /* Turn Controls - Enhanced for multiplayer */
    .turn-counter {
      font-size: 1.2em;
      font-weight: bold;
      color: #ffd700;
      padding: 10px;
      background: rgba(255, 215, 0, 0.1);
      border-radius: 5px;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .turn-counter:hover {
      background: rgba(255, 215, 0, 0.2);
      cursor: help;
    }
    
    /* Disabled button states for spectators */
    button:disabled {
      opacity: 0.5 !important;
      cursor: not-allowed !important;
      filter: grayscale(50%);
    }
    
    button:disabled:hover {
      transform: none !important;
      box-shadow: none !important;
    }
    
    /* Player turn indicators */
    .player-turn-item.current-turn {
      background: rgba(76, 175, 80, 0.2);
      border-left: 3px solid #4caf50;
      font-weight: bold;
    }
    
    .player-turn-item.my-turn {
      background: rgba(255, 215, 0, 0.1);
    }
    
    /* Mobile responsive adjustments */
    @media (max-width: 768px) {
      #multiplayer-hud {
        height: auto;
        padding: 8px 10px;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 0.85em;
      }
      
      #multiplayer-hud .session-code {
        font-size: 1em;
        padding: 6px 10px;
      }
      
      body.multiplayer-active #game-root {
        margin-top: 80px;
        height: calc(100vh - 80px);
      }
    }
  </style>
</head>
<body>
  <!-- Custom Cursor (from game.html) -->
  <div class="custom-cursor">
    <img src="../../images/cursor1-32x32.png" alt="cursor" onerror="this.style.display='none'">
  </div>

  <!-- Multiplayer Loading Screen -->
  <div id="mp-loading-screen">
    <div class="spinner"></div>
    <h2 style="font-size: 2em; margin: 10px 0;">Connecting to Game...</h2>
    <p id="loading-message" style="font-size: 1.2em;">Initializing multiplayer session</p>
  </div>
  
  <!-- Multiplayer HUD Overlay -->
  <div id="multiplayer-hud">
    <div class="session-info">
      <div>
        <span style="font-size: 0.8em;">SESSION:</span>
        <div class="session-code" id="hud-session-code" title="Click to copy"></div>
      </div>
      <div class="player-mapping-badge" id="player-mapping-badge" style="display:none;">
        <div class="player-color-dot" id="player-color-dot"></div>
        <span id="player-mapping-text">You are Player 1</span>
      </div>
      <div class="connection-status connected" id="connection-status">
        <span>üü¢</span>
        <span id="connection-text">Connected</span>
      </div>
    </div>
    
    <div style="text-align: center;">
      <div style="font-size: 0.8em; color: #999;">CURRENT TURN</div>
      <div id="hud-current-player" style="color: #ffd700; font-size: 1.3em; font-weight: bold;">
        Waiting...
      </div>
    </div>
    
    <div class="online-players">
      <span style="font-size: 0.9em;">Players:</span>
      <div id="online-player-list" style="display: flex; gap: 8px;"></div>
    </div>
  </div>
  
  <!-- Waiting Overlay -->
  <div id="waiting-overlay">
    <div class="waiting-message">
      <h2>‚è≥ Waiting for Turn</h2>
      <p id="waiting-player-name" style="font-size: 1.2em;">Player X is playing...</p>
      <div class="spinner"></div>
    </div>
  </div>
  
  <!-- Copy Notification -->
  <div class="copy-notification" id="copy-notification">
    ‚úÖ Session code copied to clipboard!
  </div>

  <!-- Game Container (will be injected from game.html) -->
  <div id="game-root"></div>
  
  <!-- Socket.IO Client -->
  <script src="/socket.io/socket.io.js"></script>
  
  <!-- Multiplayer State Management -->
  <script>
    console.log('üéÆ Multiplayer Game Loading...');
    
    // Global multiplayer state
    window.multiplayerState = {
      sessionId: null,
      userId: null,
      playerName: null,
      isMyTurn: false,
      currentPlayerName: null,
      players: {},
      isHost: false,
      isConnected: false
    };
    
    // Extract session ID from URL
    const urlParams = new URLSearchParams(window.location.search);
    window.multiplayerState.sessionId = urlParams.get('session');
    
    if (!window.multiplayerState.sessionId) {
      alert('No session ID provided!');
      window.location.href = 'lobby.html';
    }
    
    // Get stored player info
    window.multiplayerState.userId = localStorage.getItem('risk_userId') || generateUserId();
    window.multiplayerState.playerName = localStorage.getItem('risk_playerName') || 'Player';
    
    function generateUserId() {
      const id = 'user_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('risk_userId', id);
      return id;
    }
    
    function updateLoadingMessage(message) {
      const elem = document.getElementById('loading-message');
      if (elem) elem.textContent = message;
    }
    
    console.log('Session:', window.multiplayerState.sessionId);
    console.log('Player:', window.multiplayerState.playerName);
  </script>
  
  <!-- Load essential utilities first -->
  <script src="../../js/MusicPlayer.js"></script>
  <script src="../../js/SaveGameManager.js"></script>
  
  <!-- Multiplayer Bridge Scripts (load before game scripts) -->
  <script src="../shared/SessionCodeGenerator.js"></script>
  <script src="../shared/TurnValidator.js"></script>
  <script src="../shared/ConflictResolver.js"></script>
  <script src="MultiplayerClient.js"></script>
  <script src="MultiplayerGameAdapter.js"></script>
  
  <!-- Multiplayer Initialization & Bridging Logic -->
  <script>
    let multiplayerClient;
    let gameAdapter;
    
    /**
     * Main multiplayer initialization function
     * Bridges multiplayer users ‚Üí game players seamlessly
     */
    async function initializeMultiplayerGame() {
      try {
        updateLoadingMessage('Loading game structure...');
        
        // STEP 1: Load complete game.html content
        await loadGameHTML();
        
        // Debug: Check what game objects are available immediately after loading
        console.log('üîç Checking available game objects after HTML load:', {
          riskUI: typeof window.riskUI,
          gameState: typeof window.gameState,
          riskMap: typeof window.riskMap,
          riskGame: typeof window.riskGame,
          RiskUI: typeof window.RiskUI,
          GameState: typeof window.GameState,
          RiskMap: typeof window.RiskMap
        });
        
        // STEP 1.5: Setup resource path watcher for dynamically added resources
        setupResourcePathWatcher();
        
        updateLoadingMessage('Connecting to server...');
        
        // STEP 2: Initialize multiplayer client
        multiplayerClient = new MultiplayerClient();
        window.multiplayerClient = multiplayerClient;
        
        await multiplayerClient.connect();
        window.multiplayerState.isConnected = true;
        console.log('‚úÖ Connected to server');
        
        updateLoadingMessage('Joining session...');
        
        // STEP 3: Request session data (game already started)
        const sessionData = await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            console.error('‚ùå Session data request timeout');
            console.log('Debug info:', {
              sessionId: window.multiplayerState.sessionId,
              userId: window.multiplayerState.userId,
              playerName: window.multiplayerState.playerName,
              socketConnected: multiplayerClient.socket?.connected
            });
            reject(new Error('Session join timeout'));
          }, 15000);
          
          // Listen for session data response
          multiplayerClient.socket.once('sessionData', (data) => {
            clearTimeout(timeout);
            console.log('üìä Session data received:', data);
            resolve(data);
          });
          
          // Listen for errors
          multiplayerClient.socket.once('error', (error) => {
            clearTimeout(timeout);
            console.error('‚ùå Session error from server:', error);
            reject(new Error(error.message || 'Failed to get session data'));
          });
          
          // Get player info from localStorage (set by lobby)
          const playerName = localStorage.getItem('lastPlayerName') || 
                             window.multiplayerState.playerName || 
                             'Player';
          
          const userId = localStorage.getItem('risk_userId') || 
                         window.multiplayerState.userId;
          
          console.log('üì§ Requesting session data for:', {
            sessionCode: window.multiplayerState.sessionId,
            playerName: playerName,
            userId: userId
          });
          
          // Store in global state for adapter
          window.multiplayerState.playerName = playerName;
          window.multiplayerState.userId = userId;
          
          // Request session data (game already started via lobby)
          multiplayerClient.socket.emit('requestSessionData', {
            sessionCode: window.multiplayerState.sessionId
          });
        });
        
        updateLoadingMessage('Initializing game systems...');
        
        // STEP 4: Initialize game objects manually
        // Since we loaded game.html without its inline scripts, we need to create the objects ourselves
        await initializeGameObjects();
        
        // STEP 5: Verify GameState is ready (Fix 2 - GameState Timing)
        const gameState = window.gameState || window.riskUI?.gameState;
        if (!gameState) {
          throw new Error('GameState not available after initialization');
        }
        
        console.log('‚úÖ GameState verified:', {
          players: gameState.players,
          currentPlayer: gameState.getCurrentPlayer(),
          phase: gameState.phase
        });
        
        updateLoadingMessage('Mapping players...');
        
        // STEP 6: Map Firebase users to game players (Fix 1 - User‚ÜíPlayer Mapping)
        const userMapping = sessionData.users || [];
        const gamePlayers = gameState.players || [];
        
        console.log('üë• Mapping users to players:', {
          users: userMapping,
          gamePlayers: gamePlayers,
          myUserId: window.multiplayerState.userId
        });
        
        // Create mapping: userId ‚Üí playerName
        const userToPlayerMap = {};
        userMapping.forEach((user, index) => {
          if (index < gamePlayers.length) {
            userToPlayerMap[user.userId] = gamePlayers[index];
            console.log(`  üìå ${user.name} (${user.userId}) ‚Üí Player: ${gamePlayers[index]}`);
          }
        });
        
        // Find my player name
        const myPlayerName = userToPlayerMap[window.multiplayerState.userId];
        if (!myPlayerName) {
          console.error('‚ùå Could not map userId to player name!', {
            userId: window.multiplayerState.userId,
            mapping: userToPlayerMap
          });
          throw new Error('Player mapping failed - could not find your player');
        }
        
        console.log('‚úÖ My player name:', myPlayerName);
        
        // Store player mapping
        window.multiplayerState.playerName = myPlayerName;
        window.multiplayerState.myPlayerName = myPlayerName;
        window.multiplayerState.userToPlayerMap = userToPlayerMap;
        
        // Determine if it's my turn
        const currentPlayer = gameState.getCurrentPlayer();
        window.multiplayerState.isMyTurn = (currentPlayer === myPlayerName);
        window.multiplayerState.currentPlayerName = currentPlayer;
        
        console.log('üéØ Turn status:', {
          currentPlayer: currentPlayer,
          myPlayer: myPlayerName,
          isMyTurn: window.multiplayerState.isMyTurn
        });
        
        updateLoadingMessage('Initializing Combat System...');
        
        // STEP 7: Initialize Combat System in sequence (Fix 3 - Combat Sequencing)
        await initializeCombatSystem();
        console.log('‚úÖ Combat System ready');
        
        updateLoadingMessage('Setting up multiplayer...');
        
        // STEP 8: Initialize multiplayer adapter WITH gameState and player mapping
        gameAdapter = new MultiplayerGameAdapter(
          multiplayerClient,
          window.multiplayerState.sessionId,
          window.multiplayerState.userId,
          myPlayerName,
          userToPlayerMap
        );
        
        // Initialize with existing game state
        await gameAdapter.initialize({
          gameState: gameState,
          riskUI: window.riskUI,
          turnManager: window.turnManager || window.riskUI.turnManager,
          phaseManager: window.riskUI.phaseManager
        });
        
        window.gameAdapter = gameAdapter;
        console.log('‚úÖ Multiplayer adapter ready');
        
        updateLoadingMessage('Finalizing...');
        
        // STEP 9: Setup multiplayer UI overlays
        setupMultiplayerUI();
        console.log('‚úÖ Multiplayer UI ready');
        
        // STEP 10: Register event listeners
        setupMultiplayerListeners();
        console.log('‚úÖ Multiplayer listeners registered');
        
        // STEP 11: Initial UI sync
        updatePlayerList();
        updateTurnIndicator();
        updateWaitingOverlay();
        
        // Update turn UI with initial state
        if (window.updateTurnUI) {
          setTimeout(() => {
            window.updateTurnUI(
              gameState.turnNumber,
              gameState.getCurrentPlayer(),
              gameState.phase,
              gameState.players
            );
            
            if (window.updateTurnHeaderPanelColor) {
              window.updateTurnHeaderPanelColor();
            }
            
            if (window.updateReinforcementPanel) {
              window.updateReinforcementPanel();
            }
            
            if (window.riskGame && typeof window.riskGame.updateTerritoryColors === 'function') {
              window.riskGame.updateTerritoryColors();
            }
            
            console.log('‚úÖ Initial turn UI fully updated');
          }, 300);
        }
        
        // STEP 12: Hide loading screen & show HUD
        hideLoadingScreen();
        document.body.classList.add('multiplayer-active');
        document.getElementById('multiplayer-hud').classList.add('active');
        
        console.log('‚úÖ Multiplayer game fully initialized!');
        console.log(`   Session: ${window.multiplayerState.sessionId}`);
        console.log(`   My Player: ${myPlayerName}`);
        console.log(`   Is My Turn: ${window.multiplayerState.isMyTurn}`);
        
      } catch (error) {
        console.error('‚ùå Multiplayer initialization error:', error);
        showError('Failed to initialize game: ' + error.message);
      }
    }
    
    /**
     * Load complete game.html content into #game-root
     * FIXED: Prevents duplicate script execution and fixes all resource paths
     */
    async function loadGameHTML() {
      try {
        const response = await fetch('../../game.html');
        const html = await response.text();
        
        // Parse HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Extract <style> tags from head and fix their URLs
        const styleElements = doc.querySelectorAll('head style');
        styleElements.forEach(style => {
          const clonedStyle = style.cloneNode(true);
          // Fix CSS background-image URLs
          let cssText = clonedStyle.textContent;
          cssText = cssText.replace(
            /url\(['"]?(?!http|\/\/|data:)(\.\.\/)?([^'")\s]+)['"]?\)/g,
            'url("../../$2")'
          );
          clonedStyle.textContent = cssText;
          document.head.appendChild(clonedStyle);
        });
        
        console.log('‚úÖ CSS styles loaded and URLs fixed');
        
        // Extract body content WITHOUT script tags to prevent duplicate execution
        const bodyClone = doc.body.cloneNode(true);
        
        // Remove all script tags (already loaded via <script> tags in head)
        const scripts = bodyClone.querySelectorAll('script');
        scripts.forEach(script => script.remove());
        
        // Insert cleaned body content
        document.getElementById('game-root').innerHTML = bodyClone.innerHTML;
        
        // Fix ALL resource paths in HTML elements
        fixResourcePaths();
        
        console.log('‚úÖ Game HTML loaded (scripts excluded to prevent duplicates)');
        
        // ============================================
        // EXTRACT AND EXPOSE GAME.HTML UI FUNCTIONS
        // These functions manage turn UI elements
        // ============================================
        
        // Wait for DOM to be ready
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Function: Update Phase Progress Bar (from game.html lines 5241-5337)
        window.updatePhaseProgressBar = function(currentPhase) {
          const progressBar = document.getElementById("phase-progress-bar");
          if (!progressBar) return;

          const phases = ["reinforcement", "attack", "fortification"];
          const phaseNames = ["Reinforce", "Attack", "Fortify"];
          
          progressBar.innerHTML = "";

          if (currentPhase === 'startup') {
            const startupSegment = document.createElement("div");
            startupSegment.className = "phase-segment active";
            startupSegment.style.cssText = "flex: 1; text-align: center;";
            startupSegment.innerHTML = '<span class="phase-name">Initial Army Deployment</span>';
            progressBar.appendChild(startupSegment);
            console.log('üéØ Phase Progress Updated: STARTUP');
            return;
          }

          phases.forEach((phase, index) => {
            const segment = document.createElement("div");
            segment.className = "phase-segment";
            
            const currentIndex = phases.indexOf(currentPhase);
            const phaseIndex = phases.indexOf(phase);
            
            if (phase === currentPhase) {
              segment.classList.add("active");
            } else if (phaseIndex < currentIndex) {
              segment.classList.add("completed");
            } else {
              segment.classList.add("upcoming");
            }

            segment.innerHTML = `<span class="phase-name">${phaseNames[index]}</span>`;
            progressBar.appendChild(segment);
          });

          console.log(`üéØ Phase Progress Updated: ${currentPhase.toUpperCase()}`);
        };
        
        // Function: Update Players Turn Order (from game.html lines 5370-5418)
        window.updatePlayersTurnOrder = function(players, currentPlayer) {
          const playersList = document.getElementById("players-list-order");
          if (!playersList) return;

          playersList.innerHTML = "";

          players.forEach((player, index) => {
            const item = document.createElement("li");
            item.className = "player-order-item";

            if (player === currentPlayer) {
              item.classList.add("current");
            }

            const indicator = document.createElement("span");
            indicator.className = "player-order-indicator";
            indicator.textContent = index + 1;

            const colorDot = document.createElement("span");
            colorDot.className = "player-color-dot";
            
            const colorManager = window.ColorManager || 
                                (window.riskUI && window.riskUI.colorManager);
            if (colorManager) {
              const playerColor = colorManager.getPlayerColor(player);
              colorDot.style.backgroundColor = playerColor;
              if (player === currentPlayer) {
                indicator.style.backgroundColor = playerColor;
                indicator.style.color = "white";
              }
            }

            const nameSpan = document.createElement("span");
            nameSpan.textContent = player;

            item.appendChild(indicator);
            item.appendChild(nameSpan);
            item.appendChild(colorDot);

            playersList.appendChild(item);
          });
        };
        
        // Function: Update Turn Header Panel Color (from game.html lines 4887-4918)
        window.updateTurnHeaderPanelColor = function() {
          try {
            if (!window.gameState) return false;
            
            const currentPlayer = window.gameState.getCurrentPlayer();
            const turnHeaderPanel = document.getElementById("turn-header-panel");
            
            const colorManager = window.ColorManager || 
                                (window.riskUI && window.riskUI.colorManager);
            
            if (turnHeaderPanel && colorManager && currentPlayer) {
              const playerColor = colorManager.getPlayerColor(currentPlayer);
              turnHeaderPanel.style.background = 
                `linear-gradient(135deg, ${playerColor} 0%, ${playerColor}dd 100%)`;
              turnHeaderPanel.style.color = "white";
              turnHeaderPanel.style.boxShadow = `0 2px 8px ${playerColor}40`;
              
              console.log(`üé® Turn header panel color: ${currentPlayer} - ${playerColor}`);
              return true;
            }
            return false;
          } catch (error) {
            console.error("Error updating turn header panel color:", error);
            return false;
          }
        };
        
        // Function: Update Reinforcement Panel (from game.html lines 5066-5130)
        window.updateReinforcementPanel = function() {
          const currentPhase = window.gameState?.phase;
          const currentPlayer = window.gameState?.getCurrentPlayer();
          const remainingArmies = window.gameState?.remainingArmies?.[currentPlayer] || 0;
          
          const counterEl = document.getElementById("reinforcement-counter");
          const statusEl = document.getElementById("reinforcement-status");
          const panelEl = document.getElementById("reinforcement-panel");
          const turnHeaderPanel = document.getElementById("turn-header-panel");
          
          if (!counterEl || !statusEl || !panelEl) return;
          
          // Update counter
          counterEl.textContent = remainingArmies;
          counterEl.style.color = '#000000';
          
          // Match turn header panel styling
          if (turnHeaderPanel) {
            const turnHeaderBg = window.getComputedStyle(turnHeaderPanel).background;
            panelEl.style.background = turnHeaderBg;
            
            const colorManager = window.ColorManager || 
                                (window.riskUI && window.riskUI.colorManager);
            
            if (colorManager && currentPlayer) {
              const playerColor = colorManager.getPlayerColor(currentPlayer);
              panelEl.style.borderColor = playerColor;
              panelEl.style.boxShadow = 
                `0 6px 20px rgba(0, 0, 0, 0.25), 0 2px 8px ${playerColor}40`;
            }
          }
          
          // Update status based on phase
          if (currentPhase === 'startup') {
            statusEl.textContent = remainingArmies > 0 
              ? "Initial armies to deploy" 
              : "Initial deployment complete";
            panelEl.classList.toggle('active', remainingArmies > 0);
          } else if (currentPhase === 'reinforcement') {
            statusEl.textContent = remainingArmies > 0 
              ? "Ready to deploy reinforcements" 
              : "Reinforcement complete";
            panelEl.classList.toggle('active', remainingArmies > 0);
          } else {
            panelEl.classList.remove('active');
          }
        };
        
        console.log('‚úÖ Game UI functions exposed globally');
        
      } catch (error) {
        console.error('‚ùå Failed to load game HTML:', error);
        throw error;
      }
    }
    
    /**
     * Fix ALL relative paths in dynamically loaded content
     * FIXED: Comprehensive path correction for images, backgrounds, fonts, SVG
     */
    function fixResourcePaths() {
      const gameRoot = document.getElementById('game-root');
      
      // Fix image sources
      gameRoot.querySelectorAll('img').forEach(img => {
        const src = img.getAttribute('src');
        if (src && !src.startsWith('http') && !src.startsWith('../../')) {
          img.setAttribute('src', '../../' + src.replace(/^\.\.\//, ''));
        }
      });
      
      // Fix background images in style attributes
      gameRoot.querySelectorAll('[style]').forEach(el => {
        const style = el.getAttribute('style');
        if (style && style.includes('url(')) {
          // Fix paths like url("images/...") or url("res/...") or url("../images/...")
          const fixed = style.replace(
            /url\(["']?(?!http|\/\/|data:|\.\.\/\.\.\/)(\.\.\/)?([^"')]+)["']?\)/g, 
            'url("../../$2")'
          );
          el.setAttribute('style', fixed);
        }
      });
      
      // Fix SVG image elements
      gameRoot.querySelectorAll('image').forEach(img => {
        const href = img.getAttribute('href') || img.getAttribute('xlink:href');
        if (href && !href.startsWith('http') && !href.startsWith('../../')) {
          const fixed = '../../' + href.replace(/^\.\.\//, '');
          img.setAttribute('href', fixed);
          img.setAttribute('xlink:href', fixed);
        }
      });
      
      console.log('‚úÖ All resource paths fixed with ../../ prefix');
    }
    
    /**
     * Watch for dynamically added CSS/JS resources and fix their paths
     * Handles resources added by game scripts (like EnhancedAttackUI)
     */
    function setupResourcePathWatcher() {
      const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            // Fix dynamically added <link> stylesheets
            if (node.nodeName === 'LINK' && node.rel === 'stylesheet') {
              const href = node.getAttribute('href');
              if (href && !href.startsWith('http') && !href.startsWith('../../')) {
                node.setAttribute('href', '../../' + href.replace(/^\.\.\//, ''));
                console.log(`üîß Fixed dynamic CSS path: ${href} ‚Üí ../../${href}`);
              }
            }
            
            // Fix dynamically added <script> sources
            if (node.nodeName === 'SCRIPT' && node.src) {
              const src = node.src;
              const urlObj = new URL(src, window.location.href);
              const pathname = urlObj.pathname;
              if (!pathname.startsWith('/http') && !pathname.includes('../../')) {
                const newSrc = pathname.replace(/^\//, '../../');
                node.src = newSrc;
                console.log(`üîß Fixed dynamic script path: ${pathname} ‚Üí ${newSrc}`);
              }
            }
          });
        });
      });
      
      // Watch both <head> and <body> for dynamically added resources
      observer.observe(document.head, { childList: true, subtree: true });
      observer.observe(document.body, { childList: true, subtree: true });
      
      console.log('üëÅÔ∏è Resource path watcher active');
    }
    
    /**
     * Load game scripts dynamically (from game.html pattern)
     * This ensures scripts load in the correct order with proper dependencies
     */
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = () => {
          console.log(`‚úÖ Loaded: ${src}`);
          resolve();
        };
        script.onerror = () => reject(new Error(`Failed to load ${src}`));
        document.head.appendChild(script);
      });
    }
    
    /**
     * Load all game scripts in sequence (exact pattern from game.html)
     * Then initialize game objects
     */
    async function initializeGameObjects() {
      console.log('üéÆ Loading game scripts dynamically (game.html pattern)...');
      
      try {
        // Load all scripts in the EXACT order from game.html
        await loadScript('../../js/mapData.js')
          .then(() => loadScript('../../js/territory-paths.js'))
          .then(() => loadScript('../../js/ColorManager.js'))
          .then(() => loadScript('../../js/ArmyCountManager.js'))
          .then(() => loadScript('../../js/EnhancedTooltip.js'))
          .then(() => loadScript('../../js/DiceRoller.js'))
          .then(() => loadScript('../../js/DirectCombat.js'))
          .then(() => loadScript('../../js/attackLogic.js'))
          .then(() => loadScript('../../js/ReinforcementManager.js'))
          .then(() => loadScript('../../js/FortificationManager.js'))
          .then(() => loadScript('../../js/GameState.js'))
          .then(() => loadScript('../../js/GameStateManager.js'))
          .then(() => loadScript('../../js/FirebaseManager.js'))
          .then(() => loadScript('../../js/ValidationManager.js'))
          .then(() => loadScript('../../js/CombatSystem.js'))
          .then(() => loadScript('../../js/CombatAnimations.js'))
          .then(() => loadScript('../../js/CombatDebugger.js'))
          .then(() => loadScript('../../js/CombatManager.js'))
          .then(() => loadScript('../../js/CombatUI.js'))
          .then(() => loadScript('../../js/CombatEnhancements.js'))
          .then(() => loadScript('../../js/CombatEnhancedIntegration.js'))
          .then(() => loadScript('../../js/CombatTester.js'))
          .then(() => loadScript('../../js/PhaseManager.js'))
          .then(() => loadScript('../../js/PhaseSynchronizer.js'))
          .then(() => loadScript('../../js/PhaseDebugger.js'))
          .then(() => loadScript('../../js/TurnManager.js'))
          .then(() => loadScript('../../js/RiskUI.js'))
          .then(() => loadScript('../../js/RiskUI.AttackExtension.js'))
          .then(() => loadScript('../../js/CombatIntegration.js'))
          .then(() => loadScript('../../js/RiskMap.js'))
          .then(() => loadScript('../../js/MapCalibrationPresets.js'))
          .then(() => loadScript('../../js/MapCalibration.js'))
          .then(() => loadScript('../../js/RiskGame.js'))
          .then(() => loadScript('../../js/AttackManager.js'))
          .then(() => loadScript('../../js/AttackManager.integration.js'))
          .then(() => loadScript('../../js/AttackPathVisualizer.js'))
          .then(() => loadScript('../../js/EnhancedAttackUI.js'))
          .then(() => loadScript('../../js/EnhancedAttackUI.integration.js'))
          .then(() => loadScript('../../js/StatisticsManager.js'));
        
    console.log('‚úÖ All game scripts loaded successfully!');
    
    // Brief wait for script registration
    await new Promise(resolve => setTimeout(resolve, 100));
    
    // Verify required data is loaded
    if (typeof mapData === 'undefined' || typeof territoryPaths === 'undefined') {
      throw new Error('Required game data not loaded (mapData or territoryPaths missing)');
    }
    
    console.log('‚úÖ Game data verified (mapData, territoryPaths)');
    
    // ============================================
    // GAME.HTML INITIALIZATION PATTERN (EXACT COPY)
    // Lines 5998-6313 from game.html
    // ============================================
    
    console.log('üéÆ Initializing game objects (game.html pattern)...');
    
    // Pre-initialize attack modal elements (game.html line 5998)
    ensureAttackModalElements();
    
    // Get players from localStorage (set by lobby) or use defaults
    const storedPlayers = localStorage.getItem('multiplayerPlayers');
    const storedColors = localStorage.getItem('multiplayerColors');
    
    let players, playerColors;
    
    if (storedPlayers && storedColors) {
      players = JSON.parse(storedPlayers);
      playerColors = JSON.parse(storedColors);
      console.log('üìã Using stored players:', players);
    } else {
      // Fallback to defaults
      players = ['Player 1', 'Player 2'];
      playerColors = ['red', 'blue'];
      console.log('üìã Using default players:', players);
    }
    
    // Store colors for GameState constructor (game.html pattern)
    window.playerColors = playerColors;
    
    // Initialize game components in the correct order (game.html line 6079)
    const riskUI = new RiskUI();
    riskUI.initGame(players, window.playerColors || []);
    
    // Make riskUI globally available BEFORE initializing Combat System (game.html line 6082)
    window.riskUI = riskUI;
    
    console.log('  ‚úÖ RiskUI initialized');
    
    // Initialize StatisticsManager (game.html line 6085)
    if (typeof StatisticsManager !== 'undefined') {
      window.statsManager = new StatisticsManager(riskUI.gameState);
      console.log('  ‚úÖ StatisticsManager initialized');
    }
    
    // Expose ColorManager globally for easy access (game.html line 6091)
    window.colorManager = riskUI.colorManager;
    window.ColorManager = riskUI.colorManager;
    
    // Update turn header and reinforcement panel colors immediately (game.html line 6094)
    if (window.updateTurnHeaderPanelColor) {
      window.updateTurnHeaderPanelColor();
    }
    if (window.updateReinforcementPanel) {
      window.updateReinforcementPanel();
    }
    
    // Initialize Combat System after riskUI is available (game.html line 6104)
    setTimeout(() => {
      // Double-check critical elements are ready
      ensureAttackModalElements();

      if (typeof initializeCombatSystem === 'function') {
        const combatInitialized = initializeCombatSystem();
        if (combatInitialized) {
          console.log('  ‚úÖ Combat System initialized');
        }
      }
    }, 100);
    
    // Distribute territories randomly among players (game.html line 6298)
    riskUI.gameState.assignTerritoriesRandomly();
    
    // Update PhaseManager after territory distribution (game.html line 6301)
    riskUI.phaseManager.syncWithGameState();
    riskUI.updatePlayerStats();
    
    // Initialize RiskMap (game.html line 6304)
    const riskMap = new RiskMap(riskUI);
    const riskGame = new RiskGame(riskUI, riskMap);
    
    console.log('  ‚úÖ RiskMap initialized');
    console.log('  ‚úÖ RiskGame initialized');
    
    // Store references globally if needed (game.html line 6307)
    window.gameState = riskUI.gameState;
    window.riskUI = riskUI;
    window.riskMap = riskMap;
    window.riskGame = riskGame;
    
    // Initialize army count manager after RiskMap has created territories (game.html line 6312)
    if (window.ArmyCountManager) {
      try {
        riskUI.armyCountManager = new ArmyCountManager(riskUI.colorManager);
        console.log('  ‚úÖ ArmyCountManager instantiated');
        
        // Setup army count map integration
        riskUI.setupArmyCountMapIntegration();
        
        // Initialize territory visuals after map is ready
        riskUI.initializeVisualsAfterMap();
        
        console.log('  ‚úÖ ArmyCountManager integrated with RiskUI');
      } catch (error) {
        console.error('  ‚ö†Ô∏è Failed to initialize ArmyCountManager:', error);
      }
    }
    
    // Force update territory colors with proper opacity (crucial for multiplayer)
    if (riskGame && typeof riskGame.updateTerritoryColors === 'function') {
      riskGame.updateTerritoryColors();
      console.log('  ‚úÖ Territory colors and opacity updated');
    }
    
    // Store additional references (game.html pattern)
    window.turnManager = riskUI.turnManager;
    window.phaseSynchronizer = riskUI.phaseSynchronizer || window.phaseSynchronizer;
    
    // ============================================
    // MULTIPLAYER TURN UI INTEGRATION
    // Expose game.html's turn management functions for multiplayer
    // ============================================
    
    // Initialize turn UI update function (from game.html lines 5140-5236)
    window.updateTurnUI = function(turnNumber, currentPlayer, currentPhase, players) {
      try {
        // 1. Update Turn Number Display
        const turnNumberEl = document.getElementById("turn-number-display");
        const turnPrefixEl = document.getElementById("turn-prefix");
        
        if (turnNumberEl) {
          if (currentPhase === 'startup') {
            if (turnPrefixEl) turnPrefixEl.textContent = 'üéÆ ';
            turnNumberEl.textContent = 'Initial Setup';
          } else {
            if (turnPrefixEl) turnPrefixEl.textContent = 'üéÆ Turn ';
            turnNumberEl.textContent = turnNumber;
          }
        }

        // 2. Update Current Player Display
        const playerNameHeader = document.getElementById("current-player-name-header");
        const playerColorDot = document.getElementById("current-player-color");
        
        if (playerNameHeader) {
          playerNameHeader.textContent = currentPlayer;
        }
        
        if (playerColorDot && window.ColorManager) {
          playerColorDot.style.backgroundColor = window.ColorManager.getPlayerColor(currentPlayer);
        }

        // Update turn header panel background color
        if (window.updateTurnHeaderPanelColor) {
          window.updateTurnHeaderPanelColor();
        }

        // 3. Update Phase Progress Bar
        if (window.updatePhaseProgressBar) {
          window.updatePhaseProgressBar(currentPhase);
        }

        // 4. Update Players Turn Order List
        if (window.updatePlayersTurnOrder) {
          window.updatePlayersTurnOrder(players, currentPlayer);
        }

        // 5. Update Reinforcement Panel
        if (window.updateReinforcementPanel) {
          window.updateReinforcementPanel();
        }
        
        // 6. Refresh territory colors and opacity (ensure visual consistency)
        if (window.riskGame && typeof window.riskGame.updateTerritoryColors === 'function') {
          window.riskGame.updateTerritoryColors();
        }

        console.log(`‚úÖ Multiplayer Turn UI Updated - ${currentPhase === 'startup' ? 'Initial Setup' : `Turn ${turnNumber}`}, Player: ${currentPlayer}, Phase: ${currentPhase}`);
      } catch (error) {
        console.warn("Error updating multiplayer turn UI:", error);
      }
    };
    
    // Hook into turn manager to update UI automatically
    if (riskUI.turnManager) {
      const originalAdvancePhase = riskUI.turnManager.advancePhase;
      riskUI.turnManager.advancePhase = function() {
        originalAdvancePhase.call(this);
        
        // Update UI after phase advance
        setTimeout(() => {
          const gameState = window.gameState || riskUI.gameState;
          if (gameState && window.updateTurnUI) {
            window.updateTurnUI(
              gameState.turnNumber,
              gameState.getCurrentPlayer(),
              gameState.phase,
              gameState.players
            );
          }
        }, 100);
      };
      
      console.log('‚úÖ Multiplayer turn UI hooks installed');
    }
    
    // ============================================
    // TURN HANDLING FUNCTIONS
    // ============================================
    
    /**
     * Handle End Turn button click
     * ENHANCED: Fully preserves game.html turn flow + multiplayer sync
     */
    window.handleEndTurn = function() {
      console.log('üîÑ End Turn button clicked');
      
      try {
        // Get current game state
        const gameState = window.gameState || window.riskUI?.gameState;
        const turnManager = window.turnManager || window.riskUI?.turnManager;
        const phaseManager = window.riskUI?.phaseManager;
        
        if (!gameState || !turnManager) {
          console.error('‚ùå GameState or TurnManager not available');
          return;
        }
        
        const currentPhase = gameState.phase;
        const currentPlayer = gameState.getCurrentPlayer();
        
        console.log(`üìä Current state: ${currentPlayer} - ${currentPhase}`);
        
        // In multiplayer, check if it's our turn
        if (window.multiplayerState && !window.multiplayerState.isMyTurn) {
          console.warn('‚ö†Ô∏è Not your turn!');
          showNotification('Not your turn!', 'warning');
          return;
        }
        
        // ============================================
        // PHASE-SPECIFIC VALIDATION (from game.html)
        // ============================================
        
        // DRAFT phase - must place all armies
        if (currentPhase === 'draft') {
          const unplacedArmies = gameState.getUnplacedArmies(currentPlayer);
          if (unplacedArmies > 0) {
            showNotification(`You must place all ${unplacedArmies} armies before ending turn!`, 'warning');
            console.warn(`‚ö†Ô∏è Cannot end draft: ${unplacedArmies} armies remaining`);
            return;
          }
        }
        
        // ATTACK phase - check for card eligibility
        if (currentPhase === 'attack') {
          const conqueredThisTurn = gameState.conqueredTerritoryThisTurn;
          console.log(`üéØ Conquered territory this turn: ${conqueredThisTurn}`);
          
          // Card eligibility is tracked internally, no blocking needed
        }
        
        // FORTIFY phase - can end freely
        if (currentPhase === 'fortify') {
          console.log('üè∞ Fortify phase ending (optional action)');
        }
        
        // ============================================
        // CAPTURE CURRENT STATE FOR MULTIPLAYER SYNC
        // ============================================
        
        const stateBefore = {
          phase: currentPhase,
          player: currentPlayer,
          turnNumber: gameState.turnNumber,
          territories: captureTerritoriesState()
        };
        
        // ============================================
        // ADVANCE PHASE (game.html pattern)
        // ============================================
        
        turnManager.advancePhase();
        
        // ============================================
        // SYNC PHASE MANAGER (crucial for game.html compatibility)
        // ============================================
        
        if (phaseManager) {
          phaseManager.syncWithGameState();
        }
        
        // Update UI
        if (window.riskUI) {
          window.riskUI.updatePlayerStats();
        }
        
        // Update turn UI display
        if (window.updateTurnUI) {
          window.updateTurnUI(
            gameState.turnNumber,
            gameState.getCurrentPlayer(),
            gameState.phase,
            gameState.players
          );
        }
        
        // ============================================
        // MULTIPLAYER SYNCHRONIZATION
        // ============================================
        
        const stateAfter = {
          phase: gameState.phase,
          player: gameState.getCurrentPlayer(),
          turnNumber: gameState.turnNumber,
          territories: captureTerritoriesState()
        };
        
        // Send complete state change to server
        if (window.gameAdapter) {
          window.gameAdapter.sendAction({
            type: 'turnAdvance',
            stateBefore: stateBefore,
            stateAfter: stateAfter,
            timestamp: Date.now()
          });
          
          console.log(`‚úÖ Turn advanced and synced: ${stateAfter.player} - ${stateAfter.phase}`);
        }
        
        // Update multiplayer UI
        if (stateAfter.player !== stateBefore.player) {
          // Turn changed to different player
          const isMyTurn = stateAfter.player === window.multiplayerState.playerName;
          window.multiplayerState.isMyTurn = isMyTurn;
          window.multiplayerState.currentPlayerName = stateAfter.player;
          
          updateTurnIndicator();
          updateWaitingOverlay();
        }
        
      } catch (error) {
        console.error('‚ùå Error handling end turn:', error);
        showNotification('Error advancing turn', 'error');
      }
    };
    
    /**
     * Capture current territories state for sync
     */
    function captureTerritoriesState() {
      const gameState = window.gameState || window.riskUI?.gameState;
      if (!gameState || !gameState.territories) return {};
      
      const territoriesState = {};
      gameState.territories.forEach((territory, name) => {
        territoriesState[name] = {
          owner: territory.owner,
          armies: territory.armies
        };
      });
      
      return territoriesState;
    }
    
    /**
     * Handle incoming turn advance from other players
     * Called by MultiplayerGameAdapter when receiving turnAdvance action
     */
    window.handleRemoteTurnAdvance = function(data) {
      console.log('üì• Receiving remote turn advance:', data);
      
      try {
        const gameState = window.gameState || window.riskUI?.gameState;
        const turnManager = window.turnManager || window.riskUI?.turnManager;
        const phaseManager = window.riskUI?.phaseManager;
        
        if (!gameState || !turnManager) {
          console.error('‚ùå Cannot apply remote turn advance: GameState not ready');
          return;
        }
        
        // Apply territory state changes
        if (data.stateAfter.territories) {
          Object.entries(data.stateAfter.territories).forEach(([name, state]) => {
            const territory = gameState.territories.get(name);
            if (territory) {
              territory.owner = state.owner;
              territory.armies = state.armies;
            }
          });
        }
        
        // Update game state
        gameState.phase = data.stateAfter.phase;
        gameState.currentPlayerIndex = gameState.players.indexOf(data.stateAfter.player);
        gameState.turnNumber = data.stateAfter.turnNumber;
        
        // Sync phase manager
        if (phaseManager) {
          phaseManager.syncWithGameState();
        }
        
        // Update UI
        if (window.riskUI) {
          window.riskUI.updatePlayerStats();
        }
        
        if (window.updateTurnUI) {
          window.updateTurnUI(
            gameState.turnNumber,
            gameState.getCurrentPlayer(),
            gameState.phase,
            gameState.players
          );
        }
        
        // Update territory visuals
        if (window.riskGame && typeof window.riskGame.updateTerritoryColors === 'function') {
          window.riskGame.updateTerritoryColors();
        }
        
        // Update multiplayer state
        const isMyTurn = data.stateAfter.player === window.multiplayerState.playerName;
        window.multiplayerState.isMyTurn = isMyTurn;
        window.multiplayerState.currentPlayerName = data.stateAfter.player;
        
        updateTurnIndicator();
        updateWaitingOverlay();
        
        console.log(`‚úÖ Remote turn advance applied: ${data.stateAfter.player} - ${data.stateAfter.phase}`);
        
      } catch (error) {
        console.error('‚ùå Error applying remote turn advance:', error);
      }
    };
    
    /**
     * Show notification message
     */
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = 'copy-notification show';
      notification.textContent = message;
      
      if (type === 'warning') {
        notification.style.background = '#ff9800';
      } else if (type === 'error') {
        notification.style.background = '#f44336';
      }
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    }
    
    console.log('‚úÖ All game objects initialized successfully!');
    console.log('   riskUI:', typeof window.riskUI);
    console.log('   gameState:', typeof window.gameState);
    console.log('   riskMap:', typeof window.riskMap);
    console.log('   riskGame:', typeof window.riskGame);
        
        return true;
        
  } catch (error) {
    console.error('‚ùå Failed to initialize game objects:', error);
    console.log('     Available classes:', Object.keys(window).filter(k => 
      typeof window[k] === 'function' && 
      k.length > 3 &&
      (k.includes('Risk') || k.includes('Game') || k.includes('Map') || k.includes('Manager') || k.includes('State'))
    ));
    throw error;
  }
}
    
    /**
     * Initialize Combat System in sequence (Fix 3)
     * Ensures all dependencies are ready before combat initialization
     */
    async function initializeCombatSystem() {
      return new Promise((resolve) => {
        // Verify dependencies
        if (typeof CombatIntegration === 'undefined') {
          console.error('‚ùå CombatIntegration not loaded');
          resolve(false);
          return;
        }
        
        if (!window.riskUI || !window.riskUI.gameState) {
          console.error('‚ùå RiskUI or GameState not available for Combat System');
          resolve(false);
          return;
        }
        
        // Ensure attack modal elements exist
        ensureAttackModalElements();
        
        // Initialize combat with slight delay to ensure DOM is ready
        setTimeout(() => {
          try {
            if (typeof initializeCombatSystem !== 'undefined' && window.initializeCombatSystemOriginal) {
              const combatInitialized = window.initializeCombatSystemOriginal();
              if (combatInitialized) {
                console.log('‚úÖ Combat System initialized successfully');
                resolve(true);
              } else {
                console.warn('‚ö†Ô∏è Combat System initialization returned false');
                resolve(false);
              }
            } else {
              // Fallback: manually initialize
              const combat = new CombatIntegration(window.riskUI);
              window.combatSystem = combat;
              console.log('‚úÖ Combat System initialized successfully (fallback)');
              resolve(true);
            }
          } catch (error) {
            console.error('‚ùå Error initializing Combat System:', error);
            resolve(false);
          }
        }, 150);
      });
    }
    
    /**
     * Pre-initialize attack modal elements
     * From game.html - ensures critical DOM elements exist before game initialization
     */
    function ensureAttackModalElements() {
      const attackModal = document.getElementById('attack-modal');
      if (!attackModal) {
        console.warn('‚ö†Ô∏è Attack modal not found during pre-initialization (will be created later)');
        return;
      }
      
      const modalContent = attackModal.querySelector('.modal-content');
      if (!modalContent) return;
      
      // Find or create attack-selection container
      let attackSelection = attackModal.querySelector('#attack-modal-selection');
      if (!attackSelection) {
        attackSelection = document.createElement('div');
        attackSelection.id = 'attack-modal-selection';
        attackSelection.className = 'attack-selection';
        modalContent.appendChild(attackSelection);
      }
      
      console.log('‚úÖ Attack modal elements pre-initialized');
    }
    
    /**
     * Wait for game objects to be initialized
     * Checks for critical game components
     */
    async function waitForGame() {
      const maxAttempts = 50; // 10 seconds total (50 * 200ms)
      let attempts = 0;
      
      console.log('‚è≥ Waiting for game objects to initialize...');
      
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          attempts++;
          
          // Check what's available
          const hasRiskUI = typeof window.riskUI !== 'undefined' && window.riskUI !== null;
          const hasGameState = typeof window.gameState !== 'undefined' && window.gameState !== null;
          const hasRiskMap = typeof window.riskMap !== 'undefined' && window.riskMap !== null;
          
          // Log progress every 10 attempts
          if (attempts % 10 === 0) {
            console.log(`‚è≥ Attempt ${attempts}/${maxAttempts}:`, {
              riskUI: hasRiskUI,
              gameState: hasGameState,
              riskMap: hasRiskMap
            });
          }
          
          // Check if core components are ready
          if (hasRiskUI && hasGameState && hasRiskMap) {
            clearInterval(checkInterval);
            
            console.log('‚úÖ Game objects ready:', {
              riskUI: hasRiskUI,
              gameState: hasGameState,
              riskMap: hasRiskMap,
              riskGame: !!window.riskGame
            });
            
            resolve();
            return;
          }
          
          // Timeout check
          if (attempts >= maxAttempts) {
            clearInterval(checkInterval);
            
            console.error('‚ùå Game initialization timeout. Available objects:', {
              riskUI: hasRiskUI,
              gameState: hasGameState,
              riskMap: hasRiskMap,
              // List ALL window properties that might be game-related
              gameRelated: Object.keys(window).filter(key => 
                key.toLowerCase().includes('risk') || 
                key.toLowerCase().includes('game') ||
                key.toLowerCase().includes('phase') ||
                key.toLowerCase().includes('turn')
              )
            });
            
            reject(new Error('Game objects failed to initialize'));
          }
        }, 200); // Check every 200ms
      });
    }
    
    /**
     * Initialize game systems with multiplayer session players
     * DEPRECATED: Now handled by MultiplayerGameAdapter.initializeGame()
     */
    async function initializeGameSystems() {
      try {
        // Extract player data from session
        const sessionPlayers = window.multiplayerSession.players;
        const players = sessionPlayers.map(p => p.name);
        const playerColors = sessionPlayers.map(p => p.color);
        
        console.log('üéÆ Initializing game systems with players:');
        sessionPlayers.forEach(p => {
          console.log(`   ${p.name} - ${p.color} ${p.isHost ? '(HOST)' : ''}`);
        });
        
        // Wait for DOM to be ready
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Verify SVG map exists
        const svgMap = document.getElementById('risk-map');
        if (!svgMap) {
          throw new Error('SVG map not found in loaded HTML');
        }
        
        // Initialize RiskUI with multiplayer players
        if (typeof RiskUI !== 'undefined') {
          window.riskUI = new RiskUI(players, playerColors);
          console.log('‚úÖ RiskUI initialized');
        }
        
        // Initialize game state
        if (typeof GameState !== 'undefined') {
          window.gameState = new GameState(players, playerColors);
          console.log('‚úÖ GameState initialized');
        }
        
        // Initialize TurnManager
        if (typeof TurnManager !== 'undefined' && window.riskUI && window.gameState) {
          window.turnManager = new TurnManager(window.gameState, window.riskUI);
          console.log('‚úÖ TurnManager initialized');
        }
        
        // Initialize RiskMap
        if (typeof RiskMap !== 'undefined') {
          window.riskMap = new RiskMap();
          console.log('‚úÖ RiskMap initialized');
        }
        
        console.log('‚úÖ All game systems initialized');
      } catch (error) {
        console.error('‚ùå Failed to initialize game systems:', error);
        throw error;
      }
    }
    
    /**
     * Request session data from server
     */
    function requestSessionData(sessionCode) {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout waiting for session data'));
        }, 10000);
        
        multiplayerClient.socket.once('sessionData', (data) => {
          clearTimeout(timeout);
          resolve(data);
        });
        
        multiplayerClient.socket.once('error', (error) => {
          clearTimeout(timeout);
          reject(new Error(error.message || 'Failed to get session data'));
        });
        
        multiplayerClient.socket.emit('requestSessionData', { sessionCode });
      });
    }
    
    /**
     * Setup multiplayer UI overlay (non-intrusive)
     */
    function setupMultiplayerUI() {
      // Set session code
      const sessionCodeEl = document.getElementById('hud-session-code');
      sessionCodeEl.textContent = window.multiplayerState.sessionId;
      
      // Setup copy to clipboard
      sessionCodeEl.addEventListener('click', () => {
        navigator.clipboard.writeText(window.multiplayerState.sessionId);
        showCopyNotification();
      });
      
      // Show player mapping badge
      showPlayerMapping();
      
      // Update player list
      updatePlayerList();
      
      console.log('‚úÖ Multiplayer UI ready');
    }
    
    /**
     * Show player mapping badge (User ‚Üí Player)
     */
    function showPlayerMapping() {
      const currentPlayer = window.multiplayerSession?.currentPlayer;
      if (!currentPlayer) return;
      
      const sessionPlayers = window.multiplayerSession.players;
      const myIndex = sessionPlayers.findIndex(p => p.name === currentPlayer.name);
      
      if (myIndex === -1) return;
      
      const playerNumber = myIndex + 1;
      const playerColor = currentPlayer.color;
      
      const badge = document.getElementById('player-mapping-badge');
      const colorDot = document.getElementById('player-color-dot');
      const text = document.getElementById('player-mapping-text');
      
      if (badge && colorDot && text) {
        badge.style.display = 'flex';
        colorDot.style.backgroundColor = playerColor;
        text.textContent = `You are ${currentPlayer.name}`;
      }
    }
    
    /**
     * Setup multiplayer event listeners
     */
    function setupMultiplayerListeners() {
      // Connection status
      multiplayerClient.on('onConnect', () => {
        updateConnectionStatus('connected', 'Connected');
      });
      
      multiplayerClient.on('onDisconnect', () => {
        updateConnectionStatus('disconnected', 'Disconnected');
      });
      
      // Turn changes
      multiplayerClient.on('onTurnStart', (data) => {
        const currentPlayer = data.playerName;
        const isMyTurn = currentPlayer === window.multiplayerSession.currentPlayer?.name;
        
        window.multiplayerState.isMyTurn = isMyTurn;
        window.multiplayerState.currentPlayerName = currentPlayer;
        
        updateTurnIndicator();
        updateWaitingOverlay();
        
        console.log(`üéØ Turn changed: ${currentPlayer} (My turn: ${isMyTurn})`);
      });
      
      // Player actions
      multiplayerClient.on('onPlayerAction', (data) => {
        console.log('üì• Player action received:', data);
      });
      
      // Player joined/left
      multiplayerClient.on('onPlayerJoined', () => updatePlayerList());
      multiplayerClient.on('onPlayerLeft', () => updatePlayerList());
      
      console.log('‚úÖ Multiplayer listeners registered');
    }
    
    /**
     * Update connection status indicator
     */
    function updateConnectionStatus(status, text) {
      const statusEl = document.getElementById('connection-status');
      const textEl = document.getElementById('connection-text');
      
      statusEl.className = 'connection-status ' + status;
      textEl.textContent = text;
      
      const emoji = status === 'connected' ? 'üü¢' : 
                    status === 'connecting' ? 'üü°' : 'üî¥';
      statusEl.querySelector('span').textContent = emoji;
    }
    
    /**
     * Update player list (online dots)
     */
    function updatePlayerList() {
      const listEl = document.getElementById('online-player-list');
      const sessionData = multiplayerClient.sessionData;
      
      if (!sessionData || !sessionData.players) return;
      
      listEl.innerHTML = '';
      
      Object.entries(sessionData.players).forEach(([name, data]) => {
        const dot = document.createElement('div');
        dot.className = 'player-dot';
        dot.style.backgroundColor = data.color;
        dot.title = name;
        
        if (name === window.multiplayerState.currentPlayerName) {
          dot.classList.add('current-turn');
        }
        
        listEl.appendChild(dot);
      });
    }
    
    /**
     * Update turn indicator in HUD
     */
    function updateTurnIndicator() {
      const playerEl = document.getElementById('hud-current-player');
      const currentPlayer = window.multiplayerState.currentPlayerName;
      
      if (currentPlayer) {
        playerEl.textContent = currentPlayer;
        playerEl.style.color = window.multiplayerState.isMyTurn ? '#4caf50' : '#ffd700';
      }
      
      updatePlayerList();
    }
    
    /**
     * Update waiting overlay (shown when not player's turn)
     */
    function updateWaitingOverlay() {
      const overlay = document.getElementById('waiting-overlay');
      const playerNameEl = document.getElementById('waiting-player-name');
      
      if (window.multiplayerState.isMyTurn) {
        overlay.classList.remove('active');
      } else {
        overlay.classList.add('active');
        playerNameEl.textContent = `${window.multiplayerState.currentPlayerName} is playing...`;
      }
    }
    
    /**
     * Show copy notification
     */
    function showCopyNotification() {
      const notification = document.getElementById('copy-notification');
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 2000);
    }
    
    /**
     * Hide loading screen
     */
    function hideLoadingScreen() {
      const loadingScreen = document.getElementById('mp-loading-screen');
      loadingScreen.style.display = 'none';
    }
    
    /**
     * Show error message
     */
    function showError(message) {
      const loadingScreen = document.getElementById('mp-loading-screen');
      loadingScreen.innerHTML = `
        <div style="text-align: center; color: #f44336;">
          <h2 style="font-size: 2em; margin-bottom: 10px;">‚ùå Error</h2>
          <p style="font-size: 1.2em; margin-bottom: 20px;">${message}</p>
          <button onclick="window.location.href='lobby.html'" 
                  style="padding: 15px 30px; font-size: 1.2em; background: #4caf50; color: white; border: none; border-radius: 8px; cursor: pointer;">
            Return to Lobby
          </button>
        </div>
      `;
    }
    
    // Handle page unload
    window.addEventListener('beforeunload', () => {
      if (multiplayerClient) {
        multiplayerClient.disconnect();
      }
    });
    
    // Start initialization when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeMultiplayerGame);
    } else {
      initializeMultiplayerGame();
    }
  </script>

  <!-- Custom Cursor Animation (from game.html) -->
  <script>
    const customCursor = document.querySelector('.custom-cursor');
    let mouseX = 0;
    let mouseY = 0;

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      customCursor.style.left = mouseX + 'px';
      customCursor.style.top = mouseY + 'px';
    });

    document.addEventListener('mousedown', () => {
      customCursor.classList.add('clicking');
    });

    document.addEventListener('mouseup', () => {
      customCursor.classList.remove('clicking');
    });

    document.body.classList.add('custom-cursor-active');

    document.addEventListener('mouseleave', () => {
      customCursor.style.opacity = '0';
    });

    document.addEventListener('mouseenter', () => {
      customCursor.style.opacity = '1';
    });
  </script>
</body>
</html>
