<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Risk Multiplayer Game</title>
  <link rel="icon" type="image/x-icon" href="../../favicon.ico">
  
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  <script src="../../js/firebase-config.js"></script>
  
  <!-- Import ALL game.html styles -->
  <link rel="stylesheet" href="../../css/combat-system.css">
  <link rel="stylesheet" href="../../css/combat-animations.css">
  <link rel="stylesheet" href="../../css/combat-testing.css">
  <link rel="stylesheet" href="../../css/army-counts.css">
  
  <style>
    /* Import game.html font definitions */
    @font-face {
      font-family: 'Australian Flying Corps Stencil';
      src: url('../../res/Font/Australianflyingcorpsstencil-gpR1.ttf') format('truetype');
      font-weight: 300;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Mechfire';
      src: url('../../res/Font/Second font/Mechfire-jq3v.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }

    @font-face {
      font-family: 'Mechfire';
      src: url('../../res/Font/Second font/MechfireBold-z1e1.ttf') format('truetype');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }

    /* Custom cursor */
    * {
      cursor: url('../../images/cursor1-32x32.png'), auto;
    }

    .custom-cursor {
      position: fixed;
      width: 32px;
      height: 32px;
      pointer-events: none;
      z-index: 99999;
      transition: transform 0.1s ease;
      filter: drop-shadow(2px 2px 3px rgba(0, 0, 0, 0.5));
    }

    .custom-cursor img {
      width: 100%;
      height: 100%;
    }

    .custom-cursor.clicking {
      transform: rotate(-15deg) scale(0.9);
    }

    body.custom-cursor-active * {
      cursor: none !important;
    }

    /* ============================================
       MULTIPLAYER OVERLAY - NON-INTRUSIVE LAYER
       ============================================ */
    
    /* Multiplayer HUD - Top bar overlay */
    #multiplayer-hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: linear-gradient(135deg, rgba(26, 26, 46, 0.95) 0%, rgba(22, 33, 62, 0.95) 100%);
      border-bottom: 3px solid #ffd700;
      display: none;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
      z-index: 10000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }
    
    #multiplayer-hud.active {
      display: flex;
    }
    
    #multiplayer-hud .session-info {
      display: flex;
      align-items: center;
      gap: 20px;
      color: #ffd700;
      font-weight: bold;
      font-size: 1.1em;
    }
    
    #multiplayer-hud .session-code {
      background: rgba(255, 215, 0, 0.2);
      padding: 8px 16px;
      border-radius: 8px;
      border: 2px solid #ffd700;
      font-size: 1.3em;
      letter-spacing: 0.2em;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    #multiplayer-hud .session-code:hover {
      background: rgba(255, 215, 0, 0.3);
      transform: scale(1.05);
    }
    
    #multiplayer-hud .connection-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 0.9em;
    }
    
    #multiplayer-hud .connection-status.connected {
      background: rgba(0, 255, 0, 0.1);
      border: 2px solid #0f3;
      color: #0f3;
    }
    
    #multiplayer-hud .connection-status.connecting {
      background: rgba(255, 193, 7, 0.1);
      border: 2px solid #ffc107;
      color: #ffc107;
    }
    
    #multiplayer-hud .connection-status.disconnected {
      background: rgba(244, 67, 54, 0.1);
      border: 2px solid #f44336;
      color: #f44336;
    }
    
    #multiplayer-hud .online-players {
      display: flex;
      align-items: center;
      gap: 10px;
      color: #eee;
    }
    
    #multiplayer-hud .player-dot {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    #multiplayer-hud .player-dot:hover {
      transform: scale(1.2);
    }
    
    #multiplayer-hud .player-dot.current-turn {
      box-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
      animation: pulse-turn 2s infinite;
    }
    
    @keyframes pulse-turn {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }
    
    /* Loading screen */
    #mp-loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 20000;
      flex-direction: column;
      color: #ffd700;
    }
    
    #mp-loading-screen .spinner {
      width: 60px;
      height: 60px;
      border: 6px solid rgba(255, 215, 0, 0.1);
      border-top-color: #ffd700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Push game content down when HUD is visible */
    body.multiplayer-active #game-root {
      margin-top: 60px;
      height: calc(100vh - 60px);
      overflow: hidden;
    }
    
    /* Copy notification */
    .copy-notification {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(-100px);
      background: #4caf50;
      color: white;
      padding: 15px 30px;
      border-radius: 8px;
      font-weight: bold;
      z-index: 10001;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .copy-notification.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }
    
    /* Waiting overlay - when not player's turn */
    #waiting-overlay {
      position: fixed;
      top: 60px;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      pointer-events: none;
    }
    
    #waiting-overlay.active {
      display: flex;
    }
    
    #waiting-overlay .waiting-message {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 3px solid #ffd700;
      border-radius: 20px;
      padding: 40px 60px;
      text-align: center;
      color: #ffd700;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }
    
    #waiting-overlay .waiting-message h2 {
      margin: 0 0 15px 0;
      font-size: 2em;
    }
    
    /* Player mapping badge */
    .player-mapping-badge {
      background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      border: 2px solid #90caf9;
      font-size: 1em;
      font-weight: bold;
      box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .player-mapping-badge .player-color-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    /* Turn Controls - Enhanced for multiplayer */
    .turn-counter {
      font-size: 1.2em;
      font-weight: bold;
      color: #ffd700;
      padding: 10px;
      background: rgba(255, 215, 0, 0.1);
      border-radius: 5px;
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .turn-counter:hover {
      background: rgba(255, 215, 0, 0.2);
      cursor: help;
    }
    
    /* Disabled button states for spectators */
    button:disabled {
      opacity: 0.5 !important;
      cursor: not-allowed !important;
      filter: grayscale(50%);
    }
    
    button:disabled:hover {
      transform: none !important;
      box-shadow: none !important;
    }
    
    /* Player turn indicators */
    .player-turn-item.current-turn {
      background: rgba(76, 175, 80, 0.2);
      border-left: 3px solid #4caf50;
      font-weight: bold;
    }
    
    .player-turn-item.my-turn {
      background: rgba(255, 215, 0, 0.1);
    }
    
    /* Mobile responsive adjustments */
    @media (max-width: 768px) {
      #multiplayer-hud {
        height: auto;
        padding: 8px 10px;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 0.85em;
      }
      
      #multiplayer-hud .session-code {
        font-size: 1em;
        padding: 6px 10px;
      }
      
      body.multiplayer-active #game-root {
        margin-top: 80px;
        height: calc(100vh - 80px);
      }
    }
  </style>
</head>
<body>
  <!-- Custom Cursor (from game.html) -->
  <div class="custom-cursor">
    <img src="../../images/cursor1-32x32.png" alt="cursor" onerror="this.style.display='none'">
  </div>

  <!-- Multiplayer Loading Screen -->
  <div id="mp-loading-screen">
    <div class="spinner"></div>
    <h2 style="font-size: 2em; margin: 10px 0;">Connecting to Game...</h2>
    <p id="loading-message" style="font-size: 1.2em;">Initializing multiplayer session</p>
  </div>
  
  <!-- Multiplayer HUD Overlay -->
  <div id="multiplayer-hud">
    <div class="session-info">
      <div>
        <span style="font-size: 0.8em;">SESSION:</span>
        <div class="session-code" id="hud-session-code" title="Click to copy"></div>
      </div>
      <div class="player-mapping-badge" id="player-mapping-badge" style="display:none;">
        <div class="player-color-dot" id="player-color-dot"></div>
        <span id="player-mapping-text">You are Player 1</span>
      </div>
      <div class="connection-status connected" id="connection-status">
        <span>üü¢</span>
        <span id="connection-text">Connected</span>
      </div>
    </div>
    
    <div style="text-align: center;">
      <div style="font-size: 0.8em; color: #999;">CURRENT TURN</div>
      <div id="hud-current-player" style="color: #ffd700; font-size: 1.3em; font-weight: bold;">
        Waiting...
      </div>
    </div>
    
    <div class="online-players">
      <span style="font-size: 0.9em;">Players:</span>
      <div id="online-player-list" style="display: flex; gap: 8px;"></div>
    </div>
  </div>
  
  <!-- Waiting Overlay -->
  <div id="waiting-overlay">
    <div class="waiting-message">
      <h2>‚è≥ Waiting for Turn</h2>
      <p id="waiting-player-name" style="font-size: 1.2em;">Player X is playing...</p>
      <div class="spinner"></div>
    </div>
  </div>
  
  <!-- Copy Notification -->
  <div class="copy-notification" id="copy-notification">
    ‚úÖ Session code copied to clipboard!
  </div>

  <!-- Game Container (will be injected from game.html) -->
  <div id="game-root"></div>
  
  <!-- Socket.IO Client -->
  <script src="/socket.io/socket.io.js"></script>
  
  <!-- Multiplayer State Management -->
  <script>
    console.log('üéÆ Multiplayer Game Loading...');
    
    // Global multiplayer state
    window.multiplayerState = {
      sessionId: null,
      userId: null,
      playerName: null,
      isMyTurn: false,
      currentPlayerName: null,
      players: {},
      isHost: false,
      isConnected: false
    };
    
    // Extract session ID from URL
    const urlParams = new URLSearchParams(window.location.search);
    window.multiplayerState.sessionId = urlParams.get('session');
    
    if (!window.multiplayerState.sessionId) {
      alert('No session ID provided!');
      window.location.href = 'lobby.html';
    }
    
    // Get stored player info
    window.multiplayerState.userId = localStorage.getItem('risk_userId') || generateUserId();
    window.multiplayerState.playerName = localStorage.getItem('risk_playerName') || 'Player';
    
    function generateUserId() {
      const id = 'user_' + Math.random().toString(36).substr(2, 9);
      localStorage.setItem('risk_userId', id);
      return id;
    }
    
    function updateLoadingMessage(message) {
      const elem = document.getElementById('loading-message');
      if (elem) elem.textContent = message;
    }
    
    console.log('Session:', window.multiplayerState.sessionId);
    console.log('Player:', window.multiplayerState.playerName);
  </script>
  
  <!-- Load ALL game.html scripts in order -->
  <script src="../../js/MusicPlayer.js"></script>
  <script src="../../js/mapData.js"></script>
  <script src="../../js/territory-paths.js"></script>
  <script src="../../js/ColorManager.js"></script>
  <script src="../../js/ArmyCountManager.js"></script>
  <script src="../../js/EnhancedTooltip.js"></script>
  <script src="../../js/DiceRoller.js"></script>
  <script src="../../js/DirectCombat.js"></script>
  <script src="../../js/attackLogic.js"></script>
  <script src="../../js/ReinforcementManager.js"></script>
  <script src="../../js/FortificationManager.js"></script>
  <script src="../../js/GameState.js"></script>
  <script src="../../js/GameStateManager.js"></script>
  <script src="../../js/FirebaseManager.js"></script>
  <script src="../../js/ValidationManager.js"></script>
  <script src="../../js/CombatSystem.js"></script>
  <script src="../../js/CombatAnimations.js"></script>
  <script src="../../js/CombatDebugger.js"></script>
  <script src="../../js/CombatManager.js"></script>
  <script src="../../js/CombatUI.js"></script>
  <script src="../../js/CombatEnhancements.js"></script>
  <script src="../../js/CombatEnhancedIntegration.js"></script>
  <script src="../../js/CombatTester.js"></script>
  <script src="../../js/PhaseManager.js"></script>
  <script src="../../js/PhaseSynchronizer.js"></script>
  <script src="../../js/PhaseDebugger.js"></script>
  <script src="../../js/TurnManager.js"></script>
  <script src="../../js/RiskUI.js"></script>
  <script src="../../js/RiskUI.AttackExtension.js"></script>
  <script src="../../js/CombatIntegration.js"></script>
  <script src="../../js/RiskMap.js"></script>
  <script src="../../js/MapCalibrationPresets.js"></script>
  <script src="../../js/MapCalibration.js"></script>
  <script src="../../js/RiskGame.js"></script>
  <script src="../../js/AttackManager.js"></script>
  <script src="../../js/AttackManager.integration.js"></script>
  <script src="../../js/AttackPathVisualizer.js"></script>
  <script src="../../js/EnhancedAttackUI.js"></script>
  <script src="../../js/EnhancedAttackUI.integration.js"></script>
  <script src="../../js/StatisticsManager.js"></script>
  <script src="../../js/SaveGameManager.js"></script>
  
  <!-- Multiplayer Bridge Scripts -->
  <script src="../shared/SessionCodeGenerator.js"></script>
  <script src="../shared/TurnValidator.js"></script>
  <script src="../shared/ConflictResolver.js"></script>
  <script src="MultiplayerClient.js"></script>
  <script src="MultiplayerGameAdapter.js"></script>
  
  <!-- Multiplayer Initialization & Bridging Logic -->
  <script>
    let multiplayerClient;
    let gameAdapter;
    
    /**
     * Main multiplayer initialization function
     * Bridges multiplayer users ‚Üí game players seamlessly
     */
    async function initializeMultiplayerGame() {
      try {
        updateLoadingMessage('Loading game structure...');
        
        // STEP 1: Load complete game.html content
        await loadGameHTML();
        
        // STEP 1.5: Setup resource path watcher for dynamically added resources
        setupResourcePathWatcher();
        
        updateLoadingMessage('Connecting to server...');
        
        // STEP 2: Initialize multiplayer client
        multiplayerClient = new MultiplayerClient();
        window.multiplayerClient = multiplayerClient;
        
        await multiplayerClient.connect();
        window.multiplayerState.isConnected = true;
        console.log('‚úÖ Connected to server');
        
        updateLoadingMessage('Joining session...');
        
        // STEP 3: Join session and get session data
        const sessionData = await new Promise((resolve, reject) => {
          const timeout = setTimeout(() => reject(new Error('Session join timeout')), 10000);
          
          multiplayerClient.socket.once('sessionData', (data) => {
            clearTimeout(timeout);
            console.log('üìä Session data received:', data);
            resolve(data);
          });
          
          multiplayerClient.socket.emit('joinSession', {
            sessionCode: window.multiplayerState.sessionId,
            playerName: window.multiplayerState.playerName,
            userId: window.multiplayerState.userId
          });
        });
        
        updateLoadingMessage('Initializing game systems...');
        
        // STEP 4: Wait for game objects to be ready
        await waitForGame();
        console.log('‚úÖ Game objects ready:', {
          riskUI: !!window.riskUI,
          gameState: !!window.gameState,
          riskMap: !!window.riskMap,
          riskGame: !!window.riskGame
        });
        
        updateLoadingMessage('Setting up multiplayer...');
        
        // STEP 5: Initialize game adapter with session data
        // This maps lobby users ‚Üí game players using existing structures
        gameAdapter = new MultiplayerGameAdapter(multiplayerClient, window.riskGame);
        window.gameAdapter = gameAdapter;
        
        // Initialize game with user‚Üíplayer mapping
        await gameAdapter.initializeGame({
          sessionCode: sessionData.sessionId,
          sessionId: sessionData.sessionId,
          players: sessionData.players,
          gameState: sessionData.gameState
        });
        
        // Setup action interceptors
        gameAdapter.setupActionInterceptors();
        
        // Register multiplayer listeners
        gameAdapter.registerListeners();
        
        console.log('‚úÖ Multiplayer adapter ready');
        
        updateLoadingMessage('Finalizing...');
        
        // STEP 6: Setup multiplayer UI overlays
        setupMultiplayerUI();
        
        // Register multiplayer event listeners
        registerMultiplayerListeners();
        
        // STEP 8: Hide loading screen & show HUD
        hideLoadingScreen();
        document.body.classList.add('multiplayer-active');
        document.getElementById('multiplayer-hud').classList.add('active');
        
        console.log('‚úÖ Multiplayer game fully initialized!');
        console.log(`   Session: ${window.multiplayerState.sessionId}`);
        console.log(`   My Player: ${window.multiplayerState.myPlayerName}`);
        
      } catch (error) {
        console.error('‚ùå Multiplayer initialization error:', error);
        showError('Failed to initialize game: ' + error.message);
      }
    }
    
    /**
     * Load complete game.html content into #game-root
     * FIXED: Prevents duplicate script execution and fixes all resource paths
     */
    async function loadGameHTML() {
      try {
        const response = await fetch('../../game.html');
        const html = await response.text();
        
        // Parse HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Extract <style> tags from head
        const styleElements = doc.querySelectorAll('head style');
        styleElements.forEach(style => {
          document.head.appendChild(style.cloneNode(true));
        });
        
        // Extract body content WITHOUT script tags to prevent duplicate execution
        const bodyClone = doc.body.cloneNode(true);
        
        // Remove all script tags (already loaded via <script> tags in head)
        const scripts = bodyClone.querySelectorAll('script');
        scripts.forEach(script => script.remove());
        
        // Insert cleaned body content
        document.getElementById('game-root').innerHTML = bodyClone.innerHTML;
        
        // Fix ALL resource paths
        fixResourcePaths();
        
        console.log('‚úÖ Game HTML loaded (scripts excluded to prevent duplicates)');
      } catch (error) {
        console.error('‚ùå Failed to load game HTML:', error);
        throw error;
      }
    }
    
    /**
     * Fix ALL relative paths in dynamically loaded content
     * FIXED: Comprehensive path correction for images, backgrounds, fonts, SVG
     */
    function fixResourcePaths() {
      const gameRoot = document.getElementById('game-root');
      
      // Fix image sources
      gameRoot.querySelectorAll('img').forEach(img => {
        const src = img.getAttribute('src');
        if (src && !src.startsWith('http') && !src.startsWith('../../')) {
          img.setAttribute('src', '../../' + src.replace(/^\.\.\//, ''));
        }
      });
      
      // Fix background images in style attributes
      gameRoot.querySelectorAll('[style]').forEach(el => {
        const style = el.getAttribute('style');
        if (style && style.includes('url(')) {
          // Fix paths like url("images/...") or url("res/...") or url("../images/...")
          const fixed = style.replace(
            /url\(["']?(?!http|\/\/|data:|\.\.\/\.\.\/)(\.\.\/)?([^"')]+)["']?\)/g, 
            'url("../../$2")'
          );
          el.setAttribute('style', fixed);
        }
      });
      
      // Fix SVG image elements
      gameRoot.querySelectorAll('image').forEach(img => {
        const href = img.getAttribute('href') || img.getAttribute('xlink:href');
        if (href && !href.startsWith('http') && !href.startsWith('../../')) {
          const fixed = '../../' + href.replace(/^\.\.\//, '');
          img.setAttribute('href', fixed);
          img.setAttribute('xlink:href', fixed);
        }
      });
      
      console.log('‚úÖ All resource paths fixed with ../../ prefix');
    }
    
    /**
     * Watch for dynamically added CSS/JS resources and fix their paths
     * Handles resources added by game scripts (like EnhancedAttackUI)
     */
    function setupResourcePathWatcher() {
      const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            // Fix dynamically added <link> stylesheets
            if (node.nodeName === 'LINK' && node.rel === 'stylesheet') {
              const href = node.getAttribute('href');
              if (href && !href.startsWith('http') && !href.startsWith('../../')) {
                node.setAttribute('href', '../../' + href.replace(/^\.\.\//, ''));
                console.log(`üîß Fixed dynamic CSS path: ${href} ‚Üí ../../${href}`);
              }
            }
            
            // Fix dynamically added <script> sources
            if (node.nodeName === 'SCRIPT' && node.src) {
              const src = node.src;
              const urlObj = new URL(src, window.location.href);
              const pathname = urlObj.pathname;
              if (!pathname.startsWith('/http') && !pathname.includes('../../')) {
                const newSrc = pathname.replace(/^\//, '../../');
                node.src = newSrc;
                console.log(`üîß Fixed dynamic script path: ${pathname} ‚Üí ${newSrc}`);
              }
            }
          });
        });
      });
      
      // Watch both <head> and <body> for dynamically added resources
      observer.observe(document.head, { childList: true, subtree: true });
      observer.observe(document.body, { childList: true, subtree: true });
      
      console.log('üëÅÔ∏è Resource path watcher active');
    }
    
    /**
     * Wait for game objects to be available
     * Polls until window.riskGame and core objects exist
     */
    async function waitForGame() {
      const maxAttempts = 50;
      let attempts = 0;
      
      while (attempts < maxAttempts) {
        if (window.riskGame || (window.riskUI && window.gameState && window.riskMap)) {
          // Ensure riskGame object exists with all components
          if (!window.riskGame) {
            window.riskGame = {
              riskUI: window.riskUI,
              gameState: window.gameState,
              riskMap: window.riskMap,
              turnManager: window.turnManager,
              phaseManager: window.phaseManager
            };
          }
          return true;
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }
      
      throw new Error('Game objects failed to initialize');
    }
    
    /**
     * Initialize game systems with multiplayer session players
     * DEPRECATED: Now handled by MultiplayerGameAdapter.initializeGame()
     */
    async function initializeGameSystems() {
      try {
        // Extract player data from session
        const sessionPlayers = window.multiplayerSession.players;
        const players = sessionPlayers.map(p => p.name);
        const playerColors = sessionPlayers.map(p => p.color);
        
        console.log('üéÆ Initializing game systems with players:');
        sessionPlayers.forEach(p => {
          console.log(`   ${p.name} - ${p.color} ${p.isHost ? '(HOST)' : ''}`);
        });
        
        // Wait for DOM to be ready
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Verify SVG map exists
        const svgMap = document.getElementById('risk-map');
        if (!svgMap) {
          throw new Error('SVG map not found in loaded HTML');
        }
        
        // Initialize RiskUI with multiplayer players
        if (typeof RiskUI !== 'undefined') {
          window.riskUI = new RiskUI(players, playerColors);
          console.log('‚úÖ RiskUI initialized');
        }
        
        // Initialize game state
        if (typeof GameState !== 'undefined') {
          window.gameState = new GameState(players, playerColors);
          console.log('‚úÖ GameState initialized');
        }
        
        // Initialize TurnManager
        if (typeof TurnManager !== 'undefined' && window.riskUI && window.gameState) {
          window.turnManager = new TurnManager(window.gameState, window.riskUI);
          console.log('‚úÖ TurnManager initialized');
        }
        
        // Initialize RiskMap
        if (typeof RiskMap !== 'undefined') {
          window.riskMap = new RiskMap();
          console.log('‚úÖ RiskMap initialized');
        }
        
        console.log('‚úÖ All game systems initialized');
      } catch (error) {
        console.error('‚ùå Failed to initialize game systems:', error);
        throw error;
      }
    }
    
    /**
     * Request session data from server
     */
    function requestSessionData(sessionCode) {
      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout waiting for session data'));
        }, 10000);
        
        multiplayerClient.socket.once('sessionData', (data) => {
          clearTimeout(timeout);
          resolve(data);
        });
        
        multiplayerClient.socket.once('error', (error) => {
          clearTimeout(timeout);
          reject(new Error(error.message || 'Failed to get session data'));
        });
        
        multiplayerClient.socket.emit('requestSessionData', { sessionCode });
      });
    }
    
    /**
     * Setup multiplayer UI overlay (non-intrusive)
     */
    function setupMultiplayerUI() {
      // Set session code
      const sessionCodeEl = document.getElementById('hud-session-code');
      sessionCodeEl.textContent = window.multiplayerState.sessionId;
      
      // Setup copy to clipboard
      sessionCodeEl.addEventListener('click', () => {
        navigator.clipboard.writeText(window.multiplayerState.sessionId);
        showCopyNotification();
      });
      
      // Show player mapping badge
      showPlayerMapping();
      
      // Update player list
      updatePlayerList();
      
      console.log('‚úÖ Multiplayer UI ready');
    }
    
    /**
     * Show player mapping badge (User ‚Üí Player)
     */
    function showPlayerMapping() {
      const currentPlayer = window.multiplayerSession?.currentPlayer;
      if (!currentPlayer) return;
      
      const sessionPlayers = window.multiplayerSession.players;
      const myIndex = sessionPlayers.findIndex(p => p.name === currentPlayer.name);
      
      if (myIndex === -1) return;
      
      const playerNumber = myIndex + 1;
      const playerColor = currentPlayer.color;
      
      const badge = document.getElementById('player-mapping-badge');
      const colorDot = document.getElementById('player-color-dot');
      const text = document.getElementById('player-mapping-text');
      
      if (badge && colorDot && text) {
        badge.style.display = 'flex';
        colorDot.style.backgroundColor = playerColor;
        text.textContent = `You are ${currentPlayer.name}`;
      }
    }
    
    /**
     * Setup multiplayer event listeners
     */
    function setupMultiplayerListeners() {
      // Connection status
      multiplayerClient.on('onConnect', () => {
        updateConnectionStatus('connected', 'Connected');
      });
      
      multiplayerClient.on('onDisconnect', () => {
        updateConnectionStatus('disconnected', 'Disconnected');
      });
      
      // Turn changes
      multiplayerClient.on('onTurnStart', (data) => {
        const currentPlayer = data.playerName;
        const isMyTurn = currentPlayer === window.multiplayerSession.currentPlayer?.name;
        
        window.multiplayerState.isMyTurn = isMyTurn;
        window.multiplayerState.currentPlayerName = currentPlayer;
        
        updateTurnIndicator();
        updateWaitingOverlay();
        
        console.log(`üéØ Turn changed: ${currentPlayer} (My turn: ${isMyTurn})`);
      });
      
      // Player actions
      multiplayerClient.on('onPlayerAction', (data) => {
        console.log('üì• Player action received:', data);
      });
      
      // Player joined/left
      multiplayerClient.on('onPlayerJoined', () => updatePlayerList());
      multiplayerClient.on('onPlayerLeft', () => updatePlayerList());
      
      console.log('‚úÖ Multiplayer listeners registered');
    }
    
    /**
     * Update connection status indicator
     */
    function updateConnectionStatus(status, text) {
      const statusEl = document.getElementById('connection-status');
      const textEl = document.getElementById('connection-text');
      
      statusEl.className = 'connection-status ' + status;
      textEl.textContent = text;
      
      const emoji = status === 'connected' ? 'üü¢' : 
                    status === 'connecting' ? 'üü°' : 'üî¥';
      statusEl.querySelector('span').textContent = emoji;
    }
    
    /**
     * Update player list (online dots)
     */
    function updatePlayerList() {
      const listEl = document.getElementById('online-player-list');
      const sessionData = multiplayerClient.sessionData;
      
      if (!sessionData || !sessionData.players) return;
      
      listEl.innerHTML = '';
      
      Object.entries(sessionData.players).forEach(([name, data]) => {
        const dot = document.createElement('div');
        dot.className = 'player-dot';
        dot.style.backgroundColor = data.color;
        dot.title = name;
        
        if (name === window.multiplayerState.currentPlayerName) {
          dot.classList.add('current-turn');
        }
        
        listEl.appendChild(dot);
      });
    }
    
    /**
     * Update turn indicator in HUD
     */
    function updateTurnIndicator() {
      const playerEl = document.getElementById('hud-current-player');
      const currentPlayer = window.multiplayerState.currentPlayerName;
      
      if (currentPlayer) {
        playerEl.textContent = currentPlayer;
        playerEl.style.color = window.multiplayerState.isMyTurn ? '#4caf50' : '#ffd700';
      }
      
      updatePlayerList();
    }
    
    /**
     * Update waiting overlay (shown when not player's turn)
     */
    function updateWaitingOverlay() {
      const overlay = document.getElementById('waiting-overlay');
      const playerNameEl = document.getElementById('waiting-player-name');
      
      if (window.multiplayerState.isMyTurn) {
        overlay.classList.remove('active');
      } else {
        overlay.classList.add('active');
        playerNameEl.textContent = `${window.multiplayerState.currentPlayerName} is playing...`;
      }
    }
    
    /**
     * Show copy notification
     */
    function showCopyNotification() {
      const notification = document.getElementById('copy-notification');
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 2000);
    }
    
    /**
     * Hide loading screen
     */
    function hideLoadingScreen() {
      const loadingScreen = document.getElementById('mp-loading-screen');
      loadingScreen.style.display = 'none';
    }
    
    /**
     * Show error message
     */
    function showError(message) {
      const loadingScreen = document.getElementById('mp-loading-screen');
      loadingScreen.innerHTML = `
        <div style="text-align: center; color: #f44336;">
          <h2 style="font-size: 2em; margin-bottom: 10px;">‚ùå Error</h2>
          <p style="font-size: 1.2em; margin-bottom: 20px;">${message}</p>
          <button onclick="window.location.href='lobby.html'" 
                  style="padding: 15px 30px; font-size: 1.2em; background: #4caf50; color: white; border: none; border-radius: 8px; cursor: pointer;">
            Return to Lobby
          </button>
        </div>
      `;
    }
    
    // Handle page unload
    window.addEventListener('beforeunload', () => {
      if (multiplayerClient) {
        multiplayerClient.disconnect();
      }
    });
    
    // Start initialization when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeMultiplayerGame);
    } else {
      initializeMultiplayerGame();
    }
  </script>

  <!-- Custom Cursor Animation (from game.html) -->
  <script>
    const customCursor = document.querySelector('.custom-cursor');
    let mouseX = 0;
    let mouseY = 0;

    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      customCursor.style.left = mouseX + 'px';
      customCursor.style.top = mouseY + 'px';
    });

    document.addEventListener('mousedown', () => {
      customCursor.classList.add('clicking');
    });

    document.addEventListener('mouseup', () => {
      customCursor.classList.remove('clicking');
    });

    document.body.classList.add('custom-cursor-active');

    document.addEventListener('mouseleave', () => {
      customCursor.style.opacity = '0';
    });

    document.addEventListener('mouseenter', () => {
      customCursor.style.opacity = '1';
    });
  </script>
</body>
</html>
