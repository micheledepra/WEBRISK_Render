<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Risk Game</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    
    <!-- Firebase SDK - Cloud Persistence -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="js/firebase-config.js"></script>
    
    <link rel="stylesheet" href="css/combat-system.css" />
    <link rel="stylesheet" href="css/combat-animations.css" />
    <link rel="stylesheet" href="css/combat-testing.css" />
    <link rel="stylesheet" href="css/army-counts.css" />
    <style>
      /* Custom Font - Australian Flying Corps Stencil */
      @font-face {
        font-family: 'Australian Flying Corps Stencil';
        src: url('res/Font/Australianflyingcorpsstencil-gpR1.ttf') format('truetype');
        font-weight: 300;
        font-style: normal;
        font-display: swap;
      }

      /* Custom Font - Mechfire */
      @font-face {
        font-family: 'Mechfire';
        src: url('res/Font/Second font/Mechfire-jq3v.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
        font-display: swap;
      }

      @font-face {
        font-family: 'Mechfire';
        src: url('res/Font/Second font/MechfireBold-z1e1.ttf') format('truetype');
        font-weight: bold;
        font-style: normal;
        font-display: swap;
      }

      /* CSS Variables for synchronized animations */
      :root {
        --pop-duration: 200ms;
        --pop-ease: cubic-bezier(.2, .9, .2, 1);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        cursor: url('images/cursor1-32x32.png'), auto;
      }

      /* Custom cursor container for click animation */
      .custom-cursor {
        position: fixed;
        width: 27px;
        height: 27px;
        pointer-events: none;
        z-index: 99999;
        transition: transform 0.1s ease;
        filter: drop-shadow(2.3px 2.3px 3.5px rgba(0, 0, 0, 0.5));
      }

      .custom-cursor img {
        width: 100%;
        height: 100%;
      }

      .custom-cursor.clicking {
        transform: rotate(-15deg) scale(0.9);
        filter: drop-shadow(1.15px 1.15px 2.3px rgba(0, 0, 0, 0.7));
      }

      body.custom-cursor-active * {
        cursor: none !important;
      }

      body {
        font-family: 'Australian Flying Corps Stencil', Arial, sans-serif;
        font-weight: 300;
        letter-spacing: 0.5px;
        background-color: #f0f0f0;
        height: 100vh;
        overflow: hidden;
      }

      .game-container {
        display: flex;
        height: 100vh;
        position: relative;
      }

      /* Sidebar Styles */
      .sidebar {
        width: 320px;
        position: relative;
        padding: 20px;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
        z-index: 2;
        overflow-y: auto;
        flex-shrink: 0;
      }

      /* Sidebar background layer with vignette effect */
      .sidebar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: url('res/ui/gameScreenElements/LeftPanel/wood1.png');
        background-size: 100% 100%;
        background-position: center center;
        background-repeat: no-repeat;
        opacity: 0.85;
        z-index: -1;
      }

      /* Vignette overlay - dynamic radial gradient */
      .sidebar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
          ellipse at center,
          rgba(0, 0, 0, 0) 0%,
          rgba(0, 0, 0, 0) 30%,
          rgba(0, 0, 0, 0.15) 60%,
          rgba(0, 0, 0, 0.4) 100%
        );
        pointer-events: none;
        z-index: -1;
        animation: vignetteSubtle 8s ease-in-out infinite alternate;
        filter: blur(2px);
      }

      @keyframes vignetteSubtle {
        0% {
          opacity: 0.7;
        }
        100% {
          opacity: 1;
        }
      }

      /* Reinforcement Display Styles */
      .reinforcement-panel {
        background: linear-gradient(360deg, rgba(255, 243, 205, 0.162) 15%, rgba(255, 234, 167, 0.923) 100%);
        border: 2px #ffeaa7;
        border-radius: 16px;
        padding: 15px 25px;
        min-width: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: fixed;
        top: 40px;
        left: 340px;
        z-index: 1000;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15);
        transition: all 0.3s ease;
      }

      .reinforcement-panel.active {
        border-color: rgba(40, 167, 69, 0.6);
      }

      /* Pop animation when deploying units */
      @keyframes reinforcement-pop {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.15);
        }
        100% {
          transform: scale(1);
        }
      }

      .reinforcement-panel.deploy-pop {
        animation: reinforcement-pop 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      .reinforcement-counter {
        font-size: 2em;
        font-weight: bold;
        color: #000000;
        text-align: center;
        line-height: 1;
        transition: color 0.3s ease;
      }

      .reinforcement-info {
        display: none; /* Hide the text to avoid duplicate count */
      }

      .reinforcement-info.active .reinforcement-status {
        color: #000000;
        font-weight: bold;
      }

      .reinforcement-info.complete .reinforcement-status {
        color: #004085;
        font-weight: bold;
      }

      /* Enhanced Attack Panel Styles */
      .attack-panel {
        background: linear-gradient(135deg, rgba(255, 243, 205, 0.6) 0%, rgba(255, 234, 167, 0.6) 100%);
        border: 2px solid #ffeaa7;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 20px;
        display: none;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .attack-panel.active {
        display: block;
        border-color: #ff6b6b;
        background: linear-gradient(135deg, #ffe0e0 0%, #ffcccc 100%);
        animation: slideIn 0.3s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(-10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .attack-info h4 {
        margin: 0 0 10px 0;
        color: #721c24;
        font-size: 1.2em;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        text-align: center;
      }

      .attack-status {
        font-weight: 500;
        color: #856404;
        font-size: 0.95em;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.7);
        border-radius: 6px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        text-align: center;
      }

      .attack-selection {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        border: 1px solid rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-between;
      }

      .attack-territory,
      .defend-territory {
        flex: 1;
        text-align: center;
        padding: 12px;
        border-radius: 8px;
        margin: 0 8px;
        transition: all 0.3s ease;
      }

      .attack-territory {
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        border: 2px solid #2196f3;
        box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
      }

      .defend-territory {
        background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
        border: 2px solid #f44336;
        box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
      }

      .territory-label {
        font-size: 0.85em;
        font-weight: bold;
        color: #666;
        margin-bottom: 5px;
        text-transform: uppercase;
      }

      .territory-name {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
        text-transform: capitalize;
      }

      .territory-armies {
        font-size: 0.9em;
        color: #666;
        font-weight: 500;
      }

      /* Enhanced Dice Selection */
      .dice-selection {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        padding: 15px;
        margin: 15px 0;
        border: 1px solid rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: space-around;
        align-items: center;
        gap: 20px;
      }

      .dice-controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
      }

      .dice-controls label {
        font-size: 0.9em;
        font-weight: bold;
        color: #495057;
        text-align: center;
      }

      .dice-count {
        font-size: 1.4em;
        font-weight: bold;
        padding: 8px 16px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 8px;
        min-width: 40px;
        text-align: center;
        border: 2px solid #dee2e6;
        color: #495057;
      }

      .dice-btn {
        background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
        color: white;
        border: none;
        border-radius: 50%;
        width: 32px;
        height: 32px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .dice-btn:hover:not(:disabled) {
        background: linear-gradient(135deg, #5a6268 0%, #495057 100%);
        transform: translateY(-1px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      }

      .dice-btn:disabled {
        background: #dee2e6;
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
        box-shadow: none;
      }

      /* Enhanced Combat Results */
      .combat-results {
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 8px;
        padding: 20px;
        margin-top: 15px;
        text-align: center;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      .combat-results h5 {
        margin: 0 0 15px 0;
        color: #495057;
        font-size: 1.1em;
      }

      .dice-display {
        display: flex;
        justify-content: space-around;
        margin: 15px 0;
        padding: 15px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 6px;
      }

      .dice-group {
        text-align: center;
      }

      .dice-group > div:first-child {
        font-size: 0.9em;
        font-weight: bold;
        color: #666;
        margin-bottom: 8px;
      }

      .dice-rolls {
        display: flex;
        gap: 8px;
        justify-content: center;
      }

      .die {
        width: 36px;
        height: 36px;
        background: white;
        border: 3px solid #333;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 16px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
      }

      .die.attacker {
        border-color: #2196f3;
        color: #2196f3;
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
      }

      .die.defender {
        border-color: #f44336;
        color: #f44336;
        background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
      }

      .battle-result {
        margin: 15px 0;
        padding: 12px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 6px;
        font-weight: 500;
        color: #495057;
        border: 1px solid rgba(0, 0, 0, 0.1);
      }

      /* Enhanced Attack Buttons */
      .attack-btn {
        background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        cursor: url('images/cursor1-32x32.png'), pointer;
        font-size: 16px;
        font-weight: 600;
        width: 100%;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .attack-btn:hover:not(:disabled) {
        background: linear-gradient(135deg, #c82333 0%, #bd2130 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
      }

      .attack-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
        box-shadow: none;
      }

      .attack-options {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .attack-options .attack-btn {
        flex: 1;
        min-width: 140px;
      }

      /* Map Container Styles */
      .map-container {
        flex: 1;
        position: relative;
        overflow: hidden;
        background-image: url('res/ui/gameScreenElements/waterTextures/brown_leather_texture_spotted_high_resolution_stoc_by_texturex_com_d928p3q-fullview.jpg');
        background-size: 400px 400px;
        background-position: 0 0;
        background-repeat: repeat;
        image-rendering: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
        height: 100vh;
        margin: 0;
        aspect-ratio: 16 / 9;
        filter: blur(0px);
      }
      
      /* Texture blending overlay for seamless tiling */
      .map-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-image: url('res/ui/gameScreenElements/waterTextures/brown_leather_texture_spotted_high_resolution_stoc_by_texturex_com_d928p3q-fullview.jpg');
        background-size: 400px 400px;
        background-position: 200px 200px;
        background-repeat: repeat;
        opacity: 0.5;
        pointer-events: none;
        mix-blend-mode: overlay;
        filter: blur(0.4px);
        z-index: 0;
      }

      #risk-map {
        width: 100%;
        height: 100%;
        max-width: 100%;
        max-height: 100%;
        display: block;
        margin: 0;
        cursor: default;
        overflow: visible;
      }
      
      /* Ocean texture animation */
      #risk-map rect[fill*="ocean-texture"] {
        animation: ocean-wave 20s ease-in-out infinite;
      }
      
      @keyframes ocean-wave {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: 0.95;
        }
      }

      .map-group {
        transform-origin: center;
        transition: transform 0.3s ease;
        transform: translate(0, 0) scale(1);
        width: 100%;
        height: 100%;
      }

      #risk-map:active {
        cursor: grabbing;
      }
      
      /* Delete duplicate tooltip styles */

      /* Territory and Continent Styles */
      .territory {
        fill: #f4d03f;
        stroke: #333;
        stroke-width: 3;
        transition: transform var(--pop-duration) var(--pop-ease),
                    filter var(--pop-duration) var(--pop-ease),
                    stroke-width var(--pop-duration) var(--pop-ease),
                    all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        cursor: url('images/cursor1-32x32.png'), pointer;
        opacity: 0.9;
        pointer-events: all;
        vector-effect: non-scaling-stroke;
        transform-origin: center;
        transform-box: fill-box;
      }

      .territory:hover,
      .territory.territory-popped {
        opacity: 0.95 !important;
        fill-opacity: 0.95 !important;
        stroke-width: 4;
        stroke: #000000;
        transform: scale(1.05);
        filter: drop-shadow(0 5.33px 13.33px rgba(0, 0, 0, 0.4)) 
                drop-shadow(0 2.67px 6.67px rgba(0, 0, 0, 0.27))
                drop-shadow(0 0 13.33px currentColor)
                drop-shadow(0 0 20px currentColor)
                brightness(1.15) saturate(1.2);
        z-index: 100;
        animation: territory-glow 1.5s ease-in-out infinite;
      }
      
      /* Neighbor desaturation effect - MUST have higher specificity to override other filters */
      .territory.neighbor-desaturated {
        filter: saturate(0.1) brightness(0.8) !important;
        stroke: #3c3c3c !important;
        stroke-width: 3 !important;
        stroke-opacity: 0.9 !important;
        transition: filter 0.2s ease-out, stroke 0.2s ease-out, stroke-width 0.2s ease-out !important;
      }
      
      @keyframes territory-glow {
        0%, 100% {
          filter: drop-shadow(0 5.33px 13.33px rgba(0, 0, 0, 0.4)) 
                  drop-shadow(0 2.67px 6.67px rgba(0, 0, 0, 0.27))
                  drop-shadow(0 0 13.33px currentColor)
                  drop-shadow(0 0 20px currentColor)
                  brightness(1.15) saturate(1.2);
        }
        50% {
          filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.47)) 
                  drop-shadow(0 4px 10px rgba(0, 0, 0, 0.33))
                  drop-shadow(0 0 20px currentColor)
                  drop-shadow(0 0 30px currentColor)
                  brightness(1.25) saturate(1.3);
        }
      }

      .territory.selected {
        outline: 3px solid #ffd700;
        outline-offset: 2px;
        filter: brightness(1.2) drop-shadow(0 0 15px rgba(252, 215, 1, 0.8)) drop-shadow(0 0 25px rgba(255, 215, 0, 0.6));
        cursor: pointer;
        animation: backward-glow 1.5s ease-in-out infinite;
      }

      @keyframes backward-glow {
        0%, 100% {
          filter: brightness(1.2) drop-shadow(0 0 15px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 25px rgba(255, 215, 0, 0.6));
        }
        50% {
          filter: brightness(1.3) drop-shadow(0 0 25px rgba(255, 215, 0, 1)) drop-shadow(0 0 40px rgba(255, 215, 0, 0.8));
        }
      }

      .territory.valid-target {
        stroke: #4caf50;
        stroke-width: 4;
        cursor: url('images/cursor1-32x32.png'), pointer;
      }

      /* Territory Highlighting for Attack Phase */
      .territory.highlight-attackable {
        stroke: #4caf50 !important;
        stroke-width: 5px !important;
        filter: drop-shadow(0 0 5.33px #4caf50);
        animation: pulse-glow 2s infinite;
        cursor: pointer;
      }

      .territory.highlight-attacking-from {
        stroke: #2196f3 !important;
        stroke-width: 6px !important;
        filter: drop-shadow(0 0 6.67px #2196f3);
        cursor: pointer;
      }

      .territory.highlight-selected-attacker {
        stroke: #ffd700 !important;
        stroke-width: 6px !important;
        filter: drop-shadow(0 0 8px #ffd700);
        animation: pulse-selected 1.5s infinite;
      }

      .territory.highlight-selected-target {
        stroke: #f44336 !important;
        stroke-width: 6px !important;
        filter: drop-shadow(0 0 8px #f44336);
        animation: pulse-selected 1.5s infinite;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          filter: drop-shadow(0 0 5.33px currentColor);
          stroke-opacity: 1;
        }
        50% {
          filter: drop-shadow(0 0 10px currentColor);
          stroke-opacity: 0.7;
        }
      }

      @keyframes pulse-selected {
        0%,
        100% {
          filter: drop-shadow(0 0 8px currentColor);
          stroke-opacity: 1;
        }
        50% {
          filter: drop-shadow(0 0 13.33px currentColor);
          stroke-opacity: 0.8;
        }
      }

      @keyframes pulse-target {
        0%,
        100% {
          filter: drop-shadow(0 0 5.33px currentColor);
          stroke-opacity: 1;
        }
        50% {
          filter: drop-shadow(0 0 10px currentColor);
          stroke-opacity: 0.7;
        }
      }

      /* Continent Colors */
      .continent-na .territory {
        fill: #ffd700;
      } /* North America - Yellow */
      .continent-sa .territory {
        fill: #ff4444;
      } /* South America - Red */
      .continent-eu .territory {
        fill: #4444ff;
      } /* Europe - Blue */
      .continent-af .territory {
        fill: #ff8c00;
      } /* Africa - Orange */
      .continent-as .territory {
        fill: #00cc00;
      } /* Asia - Green */
      .continent-au .territory {
        fill: #ff00ff;
      } /* Australia - Purple */

      /* Player Info and Controls */
      .player-info {
        margin-bottom: 20px;
        padding: 15px;
        background-color: #f8f8f8;
        border-radius: 8px;
      }

      .current-player {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #eee;
      }

      .current-player h2 {
        font-size: 1.2em;
        color: #333;
        margin-bottom: 5px;
      }

      #current-player-name {
        font-size: 1.4em;
        font-weight: bold;
        color: #4caf50;
      }

      .player-list h3 {
        font-size: 1.1em;
        color: #666;
        margin-bottom: 10px;
      }

      .player-item {
        padding: 8px;
        margin: 4px 0;
        border-radius: 4px;
        background-color: #fff;
        border: 1px solid #ddd;
      }

      .player-item.active {
        background-color: #e8f5e9;
        border-color: #4caf50;
      }

      /* Controls */
      .controls {
        margin-top: 20px;
        padding-top: 10px;
        border-top: 2px solid #eee;
      }

      .btn {
        padding: 8px 16px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        background-color: #4caf50;
        color: white;
        cursor: url('images/cursor1-32x32.png'), pointer;
        transition: background-color 0.2s;
      }

      .btn:hover {
        background-color: #45a049;
      }

      /* Tooltip */
      .tooltip {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        pointer-events: none;
        z-index: 1000;
        display: none;
      }

      /* Modal Styles - Common for all modals */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        align-items: center;
        justify-content: center;
        overflow-y: auto;
        padding: 20px;
      }

      .modal-content {
        background: white;
        border-radius: 12px;
        padding: 24px;
        min-width: 400px;
        max-width: 700px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        position: relative;
        margin: 40px auto;
      }

      .close {
        position: absolute;
        right: 20px;
        top: 15px;
        font-size: 28px;
        font-weight: bold;
        cursor: url('images/cursor1-32x32.png'), pointer;
      }

      .close:hover {
        color: #f44336;
      }

      /* Rules Modal specific styles */
      .rules-table {
        width: 100%;
        border-collapse: collapse;
        margin: 10px 0 20px;
      }

      .rules-table th,
      .rules-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
      }

      .rules-table tr:nth-child(even) {
        background-color: #f2f2f2;
      }

      .rules-table th {
        background-color: #4caf50;
        color: white;
      }

      /* Deployment Modal Styles - keep existing styles for compatibility */
      .deployment-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        align-items: center;
        justify-content: center;
      }

      .deployment-modal-content {
        background: white;
        border-radius: 12px;
        padding: 24px;
        min-width: 400px;
        max-width: 500px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      .deployment-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 12px;
        border-bottom: 2px solid #e9ecef;
      }

      .deployment-header h3 {
        margin: 0;
        color: #343a40;
      }

      .close-btn {
        background: none;
        border: none;
        font-size: 24px;
        cursor: url('images/cursor1-32x32.png'), pointer;
        color: #6c757d;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .close-btn:hover {
        color: #dc3545;
      }

      .deployment-info {
        margin-bottom: 20px;
      }

      .available-armies {
        margin-top: 12px;
        padding: 12px;
        background: #e3f2fd;
        border-radius: 6px;
        border-left: 4px solid #2196f3;
      }

      .available-armies p {
        margin: 0;
        font-weight: 500;
        color: #1565c0;
      }

      .deployment-controls {
        margin-bottom: 20px;
      }

      .deployment-controls label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        color: #495057;
      }

      .army-input-group {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 12px;
      }

      .army-input-group button {
        width: 36px;
        height: 36px;
        border: 1px solid #ced4da;
        background: #f8f9fa;
        border-radius: 4px;
        cursor: url('images/cursor1-32x32.png'), pointer;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .army-input-group button:hover {
        background: #e9ecef;
        border-color: #adb5bd;
      }

      .army-input-group input {
        flex: 1;
        height: 36px;
        text-align: center;
        border: 1px solid #ced4da;
        border-radius: 4px;
        font-size: 16px;
        font-weight: bold;
      }

      .army-slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #e9ecef;
        outline: none;
      }

      .army-slider::-webkit-slider-thumb {
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #28a745;
        cursor: url('images/cursor1-32x32.png'), pointer;
      }

      .army-slider::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #28a745;
        cursor: url('images/cursor1-32x32.png'), pointer;
        border: none;
      }

      .deployment-preview {
        background: #f8f9fa;
        border-radius: 6px;
        padding: 16px;
        margin-bottom: 20px;
      }

      .preview-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
      }

      .preview-item:last-child {
        margin-bottom: 0;
      }

      .preview-item span:first-child {
        color: #6c757d;
      }

      .preview-item span:last-child {
        font-weight: bold;
        color: #495057;
      }

      .deployment-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .deploy-btn {
        background: #28a745;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 500;
        cursor: url('images/cursor1-32x32.png'), pointer;
        transition: background 0.2s ease;
      }

      .deploy-btn:hover:not(:disabled) {
        background: #218838;
      }

      .deploy-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
      }

      .cancel-btn {
        background: #6c757d;
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 500;
        cursor: url('images/cursor1-32x32.png'), pointer;
        transition: background 0.2s ease;
      }

      .cancel-btn:hover {
        background: #5a6268;
      }

      /* Victory Screen */
      .victory-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .victory-content {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        text-align: center;
      }

      /* Fortification Modal */
      .fortification-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .fortification-modal-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
        width: 500px;
        max-width: 90vw;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      }

      .fortification-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }

      .fortification-header h3 {
        margin: 0;
        color: #333;
      }

      .movement-path {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 6px;
      }

      .movement-arrow {
        font-size: 24px;
        font-weight: bold;
        color: #666;
        margin: 0 20px;
      }

      .movement-constraints {
        margin-bottom: 20px;
        padding: 10px;
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 4px;
      }

      .constraint-note {
        font-size: 12px;
        color: #856404;
        margin: 5px 0 0 0;
      }

      .fortification-controls {
        margin-bottom: 20px;
      }

      .fortification-controls label {
        display: block;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .fortification-preview {
        margin-bottom: 20px;
        padding: 15px;
        background: #e8f5e8;
        border-radius: 6px;
      }

      .fortification-preview h4 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #2e7d32;
      }

      .fortification-actions {
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }

      .fortification-actions button {
        flex: 1;
        padding: 10px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
      }

      .secondary-btn {
        background: #6c757d;
        color: white;
      }

      .secondary-btn:hover {
        background: #5a6268;
      }

      .primary-btn {
        background: #007bff;
        color: white;
      }

      .primary-btn:hover {
        background: #0056b3;
      }

      /* Fortification highlighting */
      .highlight-valid-source {
        stroke: #4caf50 !important;
        stroke-width: 3px !important;
        stroke-dasharray: 5, 5;
        animation: pulse-green 2s infinite;
      }

      .highlight-valid-destination {
        stroke: #2196f3 !important;
        stroke-width: 3px !important;
        stroke-dasharray: 3, 3;
        animation: pulse-blue 2s infinite;
      }

      .highlight-selected-source {
        stroke: #ff9800 !important;
        stroke-width: 4px !important;
        filter: brightness(1.2);
      }

      .highlight-selected-destination {
        stroke: #e91e63 !important;
        stroke-width: 4px !important;
        filter: brightness(1.2);
      }

      @keyframes pulse-green {
        0%,
        100% {
          stroke-opacity: 1;
        }
        50% {
          stroke-opacity: 0.5;
        }
      }

      @keyframes pulse-blue {
        0%,
        100% {
          stroke-opacity: 1;
        }
        50% {
          stroke-opacity: 0.7;
        }
      }

      .victory-content h1 {
        color: #4caf50;
        margin-bottom: 1rem;
      }

      .victory-content button {
        padding: 0.5rem 1rem;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1.1em;
      }

      /* Enhanced Visual System Styles */
      .highlight-selected {
        stroke: #ffd700 !important;
        stroke-width: 4px !important;
        filter: drop-shadow(0 0 8px #ffd700);
      }

      .highlight-validTarget {
        stroke: #4caf50 !important;
        stroke-width: 3px !important;
        filter: drop-shadow(0 0 6px #4caf50);
      }

      .highlight-invalidTarget {
        stroke: #f44336 !important;
        stroke-width: 3px !important;
        filter: drop-shadow(0 0 6px #f44336);
      }

      .highlight-ownTerritory {
        stroke: #2196f3 !important;
        stroke-width: 2px !important;
      }

      .highlight-hover {
        stroke: #ff9800 !important;
        stroke-width: 2px !important;
        filter: drop-shadow(0 0 4px #ff9800);
      }

      /* Army count styling */
      .army-count {
        font-family: "Arial", sans-serif;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
      }

      /* Enhanced tooltip improvements */
      .enhanced-tooltip {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.4;
        opacity: 0;
        transform: scale(0.95);
      }

      /* Tooltip popped state - synced with territory */
      .enhanced-tooltip.territory-popped {
        opacity: 1;
        transform: scale(1);
        box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      }

      .enhanced-tooltip .tooltip-header {
        text-transform: capitalize;
        font-weight: 600;
      }

      /* Phase indication styles */
      .phase-info {
        margin-top: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 6px;
      }

      .current-phase-name {
        font-weight: bold;
        font-size: 16px;
        color: #4caf50;
        margin-bottom: 5px;
      }

      .phase-instructions {
        font-size: 12px;
        color: #ccc;
        font-style: italic;
      }

      /* Clear selection button */
      #clear-selection {
        background: #ff5722;
        margin-top: 5px;
      }

      #clear-selection:hover {
        background: #e64a19;
      }

      /* Player color indicator */
      .player-color-indicator {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid white;
        margin-right: 10px;
      }

      /* Battle Management Modal Styles */
      .battle-modal-content {
        min-width: 500px;
        max-width: 600px;
      }

      .battle-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 12px;
        border-bottom: 2px solid #e9ecef;
      }

      .battle-header h3 {
        margin: 0;
        color: #343a40;
        font-size: 1.3em;
      }

      .battle-territories {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding: 15px;
        background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        border-radius: 8px;
        border: 1px solid #dee2e6;
      }

      .battle-territory {
        flex: 1;
        text-align: center;
        padding: 12px;
        border-radius: 8px;
        margin: 0 8px;
      }

      .battle-territory.attacker {
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        border: 2px solid #2196f3;
      }

      .battle-territory.defender {
        background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
        border: 2px solid #f44336;
      }

      .battle-vs {
        font-size: 1.5em;
        font-weight: bold;
        color: #495057;
        margin: 0 15px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
      }

      .territory-label {
        font-size: 0.8em;
        font-weight: bold;
        color: #666;
        margin-bottom: 5px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .territory-name {
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
        text-transform: capitalize;
      }

      .territory-owner {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
        font-style: italic;
      }

      .territory-armies {
        font-size: 1em;
        font-weight: bold;
        color: #495057;
      }

      .battle-instructions {
        margin-bottom: 20px;
        padding: 15px;
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 6px;
      }

      .battle-instructions p {
        margin: 5px 0;
        color: #856404;
      }

      .battle-note {
        font-size: 0.9em;
        font-style: italic;
      }

      .battle-inputs {
        margin-bottom: 20px;
      }

      .battle-input-group {
        margin-bottom: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 6px;
        border: 1px solid #dee2e6;
      }

      .battle-input-group label {
        display: block;
        margin-bottom: 10px;
        font-weight: 600;
        color: #495057;
      }

      .army-input-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 8px;
      }

      .army-input-controls button {
        width: 36px;
        height: 36px;
        border: 1px solid #ced4da;
        background: #fff;
        border-radius: 4px;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .army-input-controls button:hover:not(:disabled) {
        background: #e9ecef;
        border-color: #adb5bd;
      }

      .army-input-controls button:disabled {
        background: #f8f9fa;
        color: #6c757d;
        cursor: not-allowed;
        opacity: 0.6;
      }

      .army-input-controls input {
        flex: 1;
        height: 36px;
        text-align: center;
        border: 2px solid #ced4da;
        border-radius: 4px;
        font-size: 16px;
        font-weight: bold;
        background: white;
      }

      .army-input-controls input:focus {
        border-color: #007bff;
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      }

      .input-constraint {
        font-size: 0.85em;
        color: #6c757d;
        font-style: italic;
      }

      .battle-preview {
        background: #e8f5e8;
        border: 1px solid #c3e6cb;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 20px;
      }

      .battle-preview h4 {
        margin: 0 0 12px 0;
        color: #2e7d32;
        font-size: 1.1em;
      }

      .battle-preview-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        padding: 5px 0;
      }

      .battle-preview-item span:first-child {
        color: #495057;
        font-weight: 500;
      }

      .battle-preview-item span:last-child {
        font-weight: bold;
        color: #2e7d32;
      }

      .battle-conquest {
        margin-top: 15px;
        padding: 12px;
        background: #d4edda;
        border: 1px solid #c3e6cb;
        border-radius: 4px;
        text-align: center;
        color: #155724;
        font-size: 1.1em;
      }

      .battle-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .resolve-btn {
        background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 600;
        cursor: url('images/cursor1-32x32.png'), pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
      }

      .resolve-btn:hover:not(:disabled) {
        background: linear-gradient(135deg, #c82333 0%, #bd2130 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
      }

      .resolve-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
        box-shadow: none;
      }

      /* Unit Transfer Modal Styles */
      .unit-transfer-modal-content {
        min-width: 550px;
        max-width: 650px;
      }

      .transfer-header {
        text-align: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #28a745;
      }

      .transfer-header h3 {
        margin: 0 0 10px 0;
        color: #28a745;
        font-size: 1.4em;
      }

      .conquest-message {
        margin: 0;
        color: #6c757d;
        font-size: 1em;
        font-style: italic;
      }

      .transfer-territories {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding: 15px;
        background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
        border-radius: 8px;
        border: 1px solid #c8e6c9;
      }

      .transfer-territory {
        flex: 1;
        text-align: center;
        padding: 12px;
        border-radius: 8px;
        margin: 0 8px;
      }

      .transfer-territory.source {
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        border: 2px solid #2196f3;
      }

      .transfer-territory.destination {
        background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
        border: 2px solid #28a745;
      }

      .transfer-arrow {
        font-size: 1.5em;
        margin: 0 15px;
        color: #28a745;
      }

      .transfer-constraints {
        margin-bottom: 20px;
        padding: 15px;
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 6px;
      }

      .transfer-constraints p {
        margin: 0 0 10px 0;
        color: #856404;
        font-weight: 600;
      }

      .transfer-constraints ul {
        margin: 0;
        padding-left: 20px;
        color: #856404;
      }

      .transfer-constraints li {
        margin: 5px 0;
        font-size: 0.9em;
      }

      .transfer-controls {
        margin-bottom: 20px;
      }

      .transfer-controls > label {
        display: block;
        margin-bottom: 15px;
        font-weight: 600;
        color: #495057;
        font-size: 1.1em;
      }

      .transfer-input-group {
        display: flex;
        gap: 20px;
        align-items: flex-start;
      }

      .slider-container {
        flex: 2;
      }

      .transfer-slider {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: #e9ecef;
        outline: none;
        margin-bottom: 10px;
      }

      .transfer-slider::-webkit-slider-thumb {
        appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #28a745;
        cursor: url('images/cursor1-32x32.png'), pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .transfer-slider::-moz-range-thumb {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: #28a745;
        cursor: url('images/cursor1-32x32.png'), pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.9em;
        color: #6c757d;
      }

      .direct-input {
        flex: 1;
      }

      .direct-input label {
        display: block;
        margin-bottom: 8px;
        font-size: 0.9em;
        color: #6c757d;
      }

      .transfer-number-input {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .transfer-number-input button {
        width: 32px;
        height: 32px;
        border: 1px solid #ced4da;
        background: #fff;
        border-radius: 4px;
        cursor: url('images/cursor1-32x32.png'), pointer;
        font-size: 16px;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .transfer-number-input button:hover:not(:disabled) {
        background: #e9ecef;
        border-color: #adb5bd;
      }

      .transfer-number-input button:disabled {
        background: #f8f9fa;
        color: #6c757d;
        cursor: not-allowed;
        opacity: 0.6;
      }

      .transfer-number-input input {
        width: 60px;
        height: 32px;
        text-align: center;
        border: 2px solid #ced4da;
        border-radius: 4px;
        font-size: 16px;
        font-weight: bold;
      }

      .transfer-preview {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 20px;
      }

      .transfer-preview h4 {
        margin: 0 0 12px 0;
        color: #495057;
        font-size: 1.1em;
      }

      .transfer-result {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .result-item {
        display: flex;
        justify-content: space-between;
        padding: 8px 12px;
        background: white;
        border-radius: 4px;
        border: 1px solid #e9ecef;
      }

      .result-item span:first-child {
        font-weight: 500;
        color: #495057;
      }

      .result-item span:last-child {
        font-weight: bold;
        color: #28a745;
      }

      .transfer-error {
        min-height: 24px;
        margin-top: 10px;
      }

      .transfer-error .error-message {
        color: #f44336;
        font-weight: bold;
        font-size: 14px;
        text-align: center;
        margin: 5px 0;
      }

      .transfer-actions {
        display: flex;
        gap: 12px;
        justify-content: flex-end;
      }

      .transfer-actions button {
        padding: 12px 20px;
        border: none;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .primary-btn {
        background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
      }

      .primary-btn:hover:not(:disabled) {
        background: linear-gradient(135deg, #218838 0%, #1e7e34 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(40, 167, 69, 0.4);
      }

      .primary-btn:disabled {
        background: #6c757d;
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
        box-shadow: none;
      }

      /* Attack Modal Styles */
      .attack-modal-content {
        min-width: 550px;
        max-width: 700px;
      }

      /* Target Selection Modal Styles */
      .target-selection-modal-content {
        min-width: 400px;
        max-width: 500px;
      }

      .target-list {
        max-height: 400px;
        overflow-y: auto;
        margin: 15px 0;
      }

      .target-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 15px;
        margin: 8px 0;
        border-radius: 8px;
        border: 2px solid transparent;
        transition: all 0.2s ease;
        cursor: pointer;
      }

      .target-item:hover {
        border-color: #ff9800;
        transform: translateX(5px);
      }

      .target-item.selected {
        border-color: #ffd700;
        background: rgba(255, 215, 0, 0.1);
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      }

      .target-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .target-name {
        font-weight: bold;
        font-size: 1.1em;
        text-transform: capitalize;
      }

      .target-armies {
        font-size: 0.9em;
        color: #666;
      }

      .attacking-territory-display {
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        border: 2px solid #2196f3;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
        text-align: center;
      }

      .attacking-territory-display .territory-name {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
        text-transform: capitalize;
        margin-bottom: 5px;
      }

      .attacking-territory-display .territory-armies {
        font-size: 1em;
        color: #666;
      }

      .attack-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 12px;
        border-bottom: 2px solid #e9ecef;
      }

      .attack-header h3 {
        margin: 0;
        color: #dc3545;
        font-size: 1.3em;
      }

      .attack-vs {
        font-size: 1.5em;
        font-weight: bold;
        color: #495057;
        margin: 0 15px;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
      }

      /* Attack Button in Sidebar */
      #attack-button-container .attack-btn {
        width: 100%;
        background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        border: none;
        padding: 12px 20px;
        border-radius: 8px;
        color: white;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
      }

      #attack-button-container .attack-btn:hover {
        background: linear-gradient(135deg, #c82333 0%, #bd2130 100%);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
      }

      /* Territory highlighting for phases */
      .territory.highlight-own {
        stroke: #4caf50 !important;
        stroke-width: 3px !important;
        filter: drop-shadow(0 0 5.33px #4caf50);
        animation: pulse-glow 2s infinite;
      }

      .territory.highlight-attackable {
        stroke: #f44336 !important;
        stroke-width: 3px !important;
        filter: drop-shadow(0 0 5.33px #f44336);
        animation: pulse-glow 2s infinite;
      }

      .territory.highlight-fortifiable {
        stroke: #2196f3 !important;
        stroke-width: 3px !important;
        filter: drop-shadow(0 0 5.33px #2196f3);
        animation: pulse-glow 2s infinite;
      }

      .territory.highlight-valid-source {
        stroke: #ff9800 !important;
        stroke-width: 4px !important;
        filter: drop-shadow(0 0 6.67px #ff9800);
      }

      @keyframes pulse-glow {
        0%,
        100% {
          filter: drop-shadow(0 0 5.33px currentColor);
          stroke-opacity: 1;
        }
        50% {
          filter: drop-shadow(0 0 10px currentColor);
          stroke-opacity: 0.7;
        }
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .phase-notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #ff9800;
        color: white;
        padding: 12px 20px;
        border-radius: 6px;
        z-index: 10001;
        animation: slideIn 0.3s ease-out;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      /* Phase-specific button styling */
      /* ========================================
         TURN MANAGEMENT UI - Enhanced
         ======================================== */

      /* Turn Counter Panel (First element in sidebar) */
      .turn-counter-panel {
        background-image: url('images/rugged map.png');
        background-size: 100%;
        background-position: center; 
        color: rgba(0, 0, 0, 0.979);
        padding: 2px 15px;
        position: relative;
        border: 3px solid;
        border-color: #691b05a5 #8b3010 #4a1504 #6b2108;
        border-radius: 3px;
        margin-bottom: 15px;
        box-shadow: 
          0 2px 8px rgba(102, 126, 234, 0.3),
          inset 0 1px 2px rgba(0, 0, 0, 0.4),
          inset 0 -1px 2px rgba(255, 255, 255, 0.1);
        text-align: left;
        font-size: 1em;
        font-weight: 300;
        position: relative;
        filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.3));
        width: fit-content;
      }
      
      .turn-counter-panel::before {
        content: '';
        position: absolute;
        inset: -3px;
        border-radius: 8px;
        padding: 3px;
        background: linear-gradient(135deg, 
          rgba(139, 48, 16, 0.6) 0%, 
          rgba(74, 21, 4, 0.8) 25%,
          rgba(107, 33, 8, 0.7) 50%,
          rgba(105, 27, 5, 0.6) 75%,
          rgba(139, 48, 16, 0.5) 100%);
        -webkit-mask: 
          linear-gradient(#fff 0 0) content-box, 
          linear-gradient(#fff 0 0);
        -webkit-mask-composite: xor;
        mask: 
          linear-gradient(#fff 0 0) content-box, 
          linear-gradient(#fff 0 0);
        mask-composite: exclude;
        pointer-events: none;
        opacity: 0.8;
      }

      .turn-counter-panel .turn-prefix {
        opacity: 0.92;
        font-weight: 50;
        font-size: 1.1em;
        color:#0b0b0b
      }

      .turn-counter-panel .turn-number {
        font-weight: 400;
        font-size: 1.3em;
        margin-left: 5px;
      }

      /* Turn Header Panel (Now outside sidebar, below reinforcement panel) */
      .turn-header-panel {
        position: fixed;
        left: 340px;
        top: 19px;
        z-index: 1000;
        background: linear-gradient(135deg, #667eea37 0%, #764ba24c 100%);
        color: white;
        padding: 5px 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        transition: background 0.3s ease, box-shadow 0.3s ease;
        min-width: 50px;
        width: 150;
        filter: opacity(99%);
      }

      .current-player-display {
        font-size: 1em;
        font-weight: 550;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        width: fit-content;
        height: fit-content;
      }

      /* Phase Progress Indicator */
      .phase-progress-panel {
        background-image: url('res/ui/gameScreenElements/woodTextures/wooden-texture.jpg?v=2');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        border: 3px solid #410e02bc;
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        position: relative;
        overflow: hidden;
        opacity: 0.85;
      }

      /* Reflection effect shader for phase progress panel */
      .phase-progress-panel::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -100%;
        width: 100%;
        height: 200%;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0) 0%,
          rgba(255, 255, 255, 0.15) 25%,
          rgba(255, 255, 255, 0.5) 50%,
          rgba(255, 255, 255, 0.15) 75%,
          rgba(255, 255, 255, 0) 100%
        );
        transform: skewX(-25deg);
        opacity: 0;
        transition: opacity 0.3s ease, left 0.6s ease;
        pointer-events: none;
        z-index: 0;
      }

      .phase-progress-panel:hover::before {
        left: 150%;
        opacity: 1;
      }

      .phase-progress-panel > * {
        position: relative;
        z-index: 1;
      }

      .phase-progress-header {
        font-size: 0.95em;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #000000;
        margin-bottom: 8px;
        font-weight: 350;
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.3);
        background: rgba(255, 255, 255, 0.05);
        padding: 8px 12px;
        border-radius: 6px;
        backdrop-filter: blur(0.5px);
        text-align: center;
      }

      .phase-progress-bar {
        display: flex;
        gap: 4px;
        margin-bottom: 10px;
      }

      .phase-segment {
        flex: 1;
        height: 28px;
        border-radius: 6px;
        background: #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.80em;
        font-weight: 200;
        color: #666;
        position: relative;
        overflow: hidden;
        cursor: url('images/cursor1-32x32.png'), help;
        transition: all 0.3s ease;
        border: 3px solid transparent;
      }

      .phase-segment.active {
        background: linear-gradient(345deg, #e7e003d8 25%, #6901015d 100%);
        color: rgb(6, 6, 6);
        box-shadow: 0 2px 8px rgba(54, 21, 1, 0.4);
        border-color: #ef811b28;
        transform: translateY(-1px);
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.6);
        padding: 8px 12px;
        border-radius: 6px;
        backdrop-filter: blur(0.5px);
      }

      .phase-segment.completed {
        background: linear-gradient(135deg, #4caf4f6a 0%, #45a049 100%);
        color: white;
        border-color: #43a047;
        font-size: 0.65em;
      }

      .phase-segment.upcoming {
        background: #f5f5f5;
        color: #999;
        border-color: #e0e0e0;
      }

      .phase-segment:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      }

      .phase-segment .phase-emoji {
        margin-right: 4px;
        font-size: 1.1em;
      }

      .phase-segment .phase-name {
        font-weight: 600;
        letter-spacing: 0.3px;
      }

      /* Players Turn Order */
      .players-turn-order {
        background-image: url('res/ui/gameScreenElements/woodTextures/wooden-texture.jpg?v=2');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        border: 3px solid #410e02bc;
        border-radius: 8px;
        padding: 10px;
        margin-bottom: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        position: relative;
        overflow: hidden;
      }

      /* Reflection effect shader for players turn order */
      .players-turn-order::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -100%;
        width: 100%;
        height: 200%;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0) 0%,
          rgba(255, 255, 255, 0.15) 25%,
          rgba(255, 255, 255, 0.5) 50%,
          rgba(255, 255, 255, 0.15) 75%,
          rgba(255, 255, 255, 0) 100%
        );
        transform: skewX(-25deg);
        opacity: 0;
        transition: opacity 0.3s ease, left 0.6s ease;
        pointer-events: none;
        z-index: 0;
      }

      .players-turn-order:hover::before {
        left: 150%;
        opacity: 1;
      }

      .players-turn-order > * {
        position: relative;
        z-index: 1;
      }

      .players-order-header {
        font-size: 0.85em;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #000000;
        margin-bottom: 8px;
        font-weight: 600;
        text-align: center;
      }

      .players-list-order {
        list-style: none;
        margin: 0;
        padding: 0;
      }

      .player-order-item {
        padding: 6px;
        margin: 3px 0;
        border-radius: 4px;
        font-size: 0.85em;
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(223, 223, 223, 0.488);
        border: 1px solid #ffffff89;
        transition: all 0.2s ease;
        position: relative;
      }
      
      .player-order-item span:last-child {
        margin-left: auto;
      }

      .player-order-item.current {
        background: linear-gradient(135deg, #49130af7 0%, #ffffff83 100%);
        color: rgb(255, 255, 255);
        border: 1px solid rgba(248, 252, 0, 0.441);
        font-weight: 350;
        box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3),
                    0 0 20px rgba(150, 41, 1, 0.4),
                    0 0 40px rgba(252, 80, 0, 0.2);
        transition: all 0.3s ease;
        transform: scale(1.04);
        animation: gentle-bloom 2s ease-in-out infinite;
      }

      @keyframes gentle-bloom {
        0%, 100% {
          box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3),
                      0 0 20px rgba(252, 0, 0, 0.4),
                      0 0 35px rgba(252, 0, 0, 0.2);
        }
        50% {
          box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3),
                      0 0 30px rgba(252, 0, 0, 0.4),
                      0 0 35px rgba(252, 21, 0, 0.2);
        }
      }

      .player-order-item.current:hover {
        transform: scale(1.08) translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5),
                    0 0 35px rgba(248, 252, 0, 0.7),
                    0 0 70px rgba(248, 252, 0, 0.4);
      }

      .player-order-item.completed {
        opacity: 0.6;
        text-decoration: line-through;
      }

      .player-order-indicator {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        font-size: 0.7em;
        font-weight: 700;
      }

      .player-order-item.current .player-order-indicator {
        background: rgba(255, 255, 255, 0.3);
        color: white;
      }

      .player-order-item .player-order-indicator {
        background: #e0e0e0;
        color: #666;
      }

      .player-order-item.completed .player-order-indicator::after {
        content: "";
      }

      .player-color-dot {
        display: inline-block;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        box-shadow: 
          0 2px 4px rgba(0, 0, 0, 0.3),
          0 1px 2px rgba(0, 0, 0, 0.2),
          inset 0 -1px 3px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.4);
        border: 1px solid rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
      }

      .player-color-dot:hover {
        transform: scale(1.1);
        box-shadow: 
          0 3px 6px rgba(0, 0, 0, 0.4),
          0 2px 4px rgba(0, 0, 0, 0.3),
          inset 0 -1px 3px rgba(0, 0, 0, 0.2),
          inset 0 1px 2px rgba(255, 255, 255, 0.5);
      }

      /* Player Territory Border Highlighting */
      /* Base turn highlighting - shows player's territories with animated border */
      .territory.player-turn-highlight {
        stroke-width: 2.5 !important;
        stroke-dasharray: 20, 15;
        stroke-linecap: round;
        stroke-linejoin: round;
        animation: dash-animate 0.6s linear infinite;
        filter: drop-shadow(0 0 12px currentColor) 
                drop-shadow(0 0 8px currentColor) 
                brightness(1.2);
        transition: stroke 0.3s ease, stroke-width 0.3s ease;
        opacity: 1 !important;
      }

      /* Add pop-out effect when hovering over player's highlighted territories */
      .territory.player-turn-highlight:hover,
      .territory.player-turn-highlight.territory-popped {
        transform: scale(1.05);
        stroke-width: 3 !important;
        filter: drop-shadow(0 5.33px 13.33px rgba(0, 0, 0, 0.4)) 
                drop-shadow(0 2.67px 6.67px rgba(0, 0, 0, 0.27))
                drop-shadow(0 0 13.33px currentColor)
                drop-shadow(0 0 20px currentColor)
                brightness(1.15) saturate(1.2);
        animation: dash-animate 0.6s linear infinite, territory-glow 1.5s ease-in-out infinite;
      }

      /* Ensure attack/fortification highlights override turn highlighting */
      .territory.highlight-attackable,
      .territory.highlight-attacking-from,
      .territory.highlight-selected-attacker,
      .territory.highlight-selected-target,
      .territory.highlight-valid-source,
      .territory.highlight-selected-source,
      .territory.highlight-valid-destination,
      .territory.highlight-selected-destination {
        stroke-dasharray: none !important;
        animation: none !important;
      }

      @keyframes dash-animate {
        0% {
          stroke-dashoffset: 0;
        }
        100% {
          stroke-dashoffset: 36;
        }
      }

      /* Phase Completion Messages */
      .phase-completion-notice {
        padding: 8px;
        border-radius: 4px;
        font-size: 0.8em;
        margin-bottom: 10px;
        display: none;
      }

      .phase-completion-notice.show {
        display: block;
      }

      .phase-completion-notice.required {
        background: #ffebee;
        color: #c62828;
        border-left: 3px solid #d32f2f;
      }

      .phase-completion-notice.optional {
        background: #fff3e0;
        color: #e65100;
        border-left: 3px solid #ff9800;
      }

      .phase-completion-notice.success {
        background: #e8f5e9;
        color: #2e7d32;
        border-left: 3px solid #4caf50;
      }

      /* Skip Phase Button */
      .skip-phase-button {
        width: 100%;
        padding: 10px;
        background: #ffc107;
        color: #333;
        border: none;
        border-radius: 4px;
        font-size: 0.85em;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 8px;
      }

      .skip-phase-button:hover:not(:disabled) {
        background: #ffb300;
        transform: translateY(-1px);
      }

      .skip-phase-button:disabled {
        background: #ccc;
        color: #666;
        cursor: not-allowed;
        opacity: 0.5;
      }

      /* Phase Skip Animation */
      @keyframes fadeInOut {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      /* Phase Control Panel & Next Phase Button */
      .phase-control-panel {
        padding: 15px;
        background-image: url('res/ui/gameScreenElements/woodTextures/wooden-texture.jpg?v=2');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        border: 3px solid #410e02bc;
        border-radius: 8px;
        margin-bottom: 15px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      /* Reflection effect shader for phase control panel */
      .phase-control-panel::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -100%;
        width: 100%;
        height: 200%;
        background: linear-gradient(
          90deg,
          rgba(255, 255, 255, 0) 0%,
          rgba(255, 255, 255, 0.15) 25%,
          rgba(255, 255, 255, 0.5) 50%,
          rgba(255, 255, 255, 0.15) 75%,
          rgba(255, 255, 255, 0) 100%
        );
        transform: skewX(-25deg);
        opacity: 0;
        transition: opacity 0.3s ease, left 0.6s ease;
        pointer-events: none;
        z-index: 0;
      }

      .phase-control-panel:hover::before {
        left: 150%;
        opacity: 1;
      }

      .phase-control-panel > * {
        position: relative;
        z-index: 1;
      }

      .end-turn-button-enhanced {
        width: 100%;
        padding: 14px 20px;
        font-size: 16px;
        font-weight: 600;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        margin-bottom: 0px;
      }

      .end-turn-button-enhanced:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .end-turn-button-enhanced:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .end-turn-button-enhanced.phase-deploy {
        background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        color: white;
      }

      .end-turn-button-enhanced.phase-reinforce {
        background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        color: white;
      }

      .end-turn-button-enhanced.phase-attack {
        background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        color: white;
      }

      .end-turn-button-enhanced.phase-fortify {
        background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        color: white;
      }

      #end-turn-enhanced {
        font-family: 'Mechfire', Arial, sans-serif;
        background-image: url('res/ui/gameScreenElements/waterTextures/brown_leather_texture_spotted_high_resolution_stoc_by_texturex_com_d928p3q-fullview.jpg');
        background-size: 100%;
        background-position: center;
        background-repeat: no-repeat;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.7);
        transform: scale(1);
        transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.90);
        filter: drop-shadow(0 0 8px rgba(0, 0, 0, 0.4));
      }

      #end-turn-enhanced:hover {
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.5), 0 0 30px rgba(0, 0, 0, 0.3);
        transform: scale(1.05);
        filter: drop-shadow(0 0 12px rgba(0, 0, 0, 0.2));
      }

      /* Mobile Navigation Buttons */
      .mobile-nav-buttons {
        position: fixed;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 1000;
      }

      .mobile-nav-button {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: linear-gradient(270deg, #f4d0049d 0%, #ffed4e 100%);
        border: 3px solid rgba(255, 215, 0, 0.5);
        font-size: 1.5em;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
        text-decoration: none;
        color: #333;
      }

      .mobile-nav-button:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
        background: linear-gradient(135deg, #ffed4e 0%, #ffd700 100%);
      }

      .mobile-nav-button:active {
        transform: scale(0.95);
      }

      .mobile-nav-button.music-button {
        background: linear-gradient(270deg, #4CAF50 0%, #66BB6A 100%);
        border-color: rgba(76, 175, 80, 0.5);
      }

      .mobile-nav-button.music-button:hover {
        background: linear-gradient(135deg, #66BB6A 0%, #4CAF50 100%);
        box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
      }

      .mobile-nav-button.sizing-button {
        background: linear-gradient(270deg, #2196F3 0%, #42A5F5 100%);
        border-color: rgba(33, 150, 243, 0.5);
      }

      .mobile-nav-button.sizing-button:hover {
        background: linear-gradient(135deg, #42A5F5 0%, #2196F3 100%);
        box-shadow: 0 6px 20px rgba(33, 150, 243, 0.5);
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .mobile-nav-buttons {
          right: 5px;
          gap: 8px;
        }

        .mobile-nav-button {
          width: 45px;
          height: 45px;
          font-size: 1.3em;
        }
      }

      @media (max-width: 480px) {
        .mobile-nav-buttons {
          gap: 6px;
        }

        .mobile-nav-button {
          width: 40px;
          height: 40px;
          font-size: 1.2em;
        }
      }

      /* ========================================
         MOBILE & TABLET RESPONSIVE LAYOUT
         ======================================== */
      
      /* Tablet Landscape & Small Desktop */
      @media (max-width: 1024px) and (min-width: 769px) and (orientation: landscape) {
        .sidebar {
          width: 280px !important;
          padding: 15px !important;
        }

        .game-container {
          flex-direction: row !important;
        }
      }

      /* LANDSCAPE MODE - Collapsible Sidebar */
      @media (max-width: 1024px) and (orientation: landscape) {
        .sidebar {
          position: fixed !important;
          left: 0 !important;
          top: 0 !important;
          bottom: 0 !important;
          width: 280px !important;
          height: 100vh !important;
          max-height: 100vh !important;
          transform: translateX(-100%) !important;
          transition: transform 0.3s ease-in-out !important;
          z-index: 9998 !important;
          box-shadow: 4px 0 12px rgba(0, 0, 0, 0.3) !important;
          padding: 15px !important;
          overflow-y: auto !important;
        }

        .sidebar.expanded {
          transform: translateX(0) !important;
        }

        /* Toggle button for landscape */
        .sidebar-toggle {
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          width: 50px !important;
          height: 50px !important;
          position: fixed !important;
          left: 10px !important;
          top: 50% !important;
          transform: translateY(-50%) !important;
          background: rgba(255, 215, 0, 0.95) !important;
          border: 3px solid #1a1a2e !important;
          border-radius: 50% !important;
          cursor: pointer !important;
          font-size: 24px !important;
          z-index: 9999 !important;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4) !important;
        }

        .sidebar.expanded ~ .sidebar-toggle {
          left: 290px !important;
        }

        .map-container {
          margin-left: 0 !important;
          width: 100% !important;
          height: 100vh !important;
          position: relative !important;
        }

        .game-container {
          flex-direction: row !important;
          height: 100vh !important;
        }

        /* Optimize sidebar content */
        .sidebar * {
          font-size: 0.9em;
        }

        .player-panel {
          padding: 8px !important;
          margin-bottom: 8px !important;
        }
      }

      /* PORTRAIT MODE - Bottom Drawer */
      @media (max-width: 768px) and (orientation: portrait) {
        body {
          overflow: auto;
          -webkit-overflow-scrolling: touch;
        }

        .game-container {
          flex-direction: column !important;
          height: 100vh !important;
        }

        .sidebar {
          position: fixed !important;
          bottom: 0 !important;
          left: 0 !important;
          right: 0 !important;
          top: auto !important;
          width: 100% !important;
          max-width: 100% !important;
          max-height: 50vh !important;
          height: auto !important;
          padding: 12px !important;
          overflow-y: auto !important;
          overflow-x: hidden !important;
          z-index: 9998 !important;
          transform: translateY(calc(100% - 60px)) !important;
          transition: transform 0.3s ease-in-out !important;
          border-top: 3px solid rgba(255, 215, 0, 0.7) !important;
          box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3) !important;
        }

        .sidebar.expanded {
          transform: translateY(0) !important;
        }

        /* Pull-up indicator */
        .sidebar::before {
          content: '' !important;
          position: absolute !important;
          top: 15px !important;
          left: 50% !important;
          transform: translateX(-50%) !important;
          font-size: 28px !important;
          color: #ffd700 !important;
          z-index: 10 !important;
          pointer-events: none !important;
          display: block !important;
        }

        /* Hide landscape toggle in portrait */
        .sidebar-toggle {
          display: none !important;
        }

        .map-container {
          width: 100% !important;
          height: calc(50vh) !important;
          max-height: calc(50vh) !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          margin: 0 auto !important;
          position: relative !important;
          touch-action: pan-x pan-y pinch-zoom;
        }

        #risk-map {
          max-width: 100% !important;
          max-height: 100% !important;
          width: auto !important;
          height: auto !important;
          touch-action: none;
        }

        /* Optimize sidebar content for portrait */
        .sidebar > * {
          font-size: 0.92em !important;
        }

        .turn-counter-panel,
        .phase-progress-panel {
          font-size: 0.88em !important;
          padding: 8px !important;
          margin-bottom: 8px !important;
        }

        .player-panel {
          padding: 8px !important;
          margin-bottom: 8px !important;
        }

        .player-info h3 {
          font-size: 1em !important;
        }

        .player-stats {
          font-size: 0.85em !important;
        }

        .reinforcement-panel {
          padding: 10px !important;
        }

        .end-turn-container {
          padding: 10px !important;
        }

        #end-turn-enhanced {
          padding: 12px 20px !important;
          font-size: 0.95em !important;
        }

        /* Touch-friendly buttons */
        button, .button, a {
          min-height: 44px !important;
          min-width: 44px !important;
          padding: 10px 16px !important;
          touch-action: manipulation !important;
        }

        /* Adjust modals for portrait */
        .modal {
          padding: 10px;
        }

        .modal-content {
          width: 95% !important;
          max-width: 95% !important;
          max-height: 85vh !important;
          overflow-y: auto;
          font-size: 0.95em;
        }

        .turn-header-panel {
          position: relative;
          font-size: 0.9em;
          padding: 8px;
        }
      }

      /* Small phones in portrait */
      @media (max-width: 480px) and (orientation: portrait) {
        .sidebar {
          transform: translateY(calc(100% - 50px)) !important;
          max-height: 55vh !important;
          padding: 12px 8px !important;
        }

        .sidebar::before {
          font-size: 24px !important;
          top: 12px !important;
        }

        .map-container {
          height: calc(45vh) !important;
          max-height: calc(45vh) !important;
        }

        .sidebar > * {
          font-size: 0.88em !important;
        }

        .sidebar .player-panel {
          padding: 6px !important;
        }

        button, .button {
          font-size: 0.9em !important;
        }
      }

      /* Extra small landscape */
      @media (max-height: 500px) and (orientation: landscape) {
        .sidebar {
          width: 260px !important;
          font-size: 0.85em;
        }

        .sidebar > * {
          padding: 6px;
        }
      }

      /* Hide sidebar toggle on desktop */
      @media (min-width: 1025px) {
        .sidebar-toggle {
          display: none !important;
        }

        .mobile-only {
          display: none !important;
        }
      }

      /* Show mobile elements on mobile */
      @media (max-width: 1024px) {
        .mobile-only {
          display: block !important;
        }

        .desktop-only {
          display: none !important;
        }
      }

      /* Touch-friendly enhancements */
      @media (hover: none) and (pointer: coarse) {
        /* This targets touch devices specifically */
        button, .button, a, [onclick] {
          min-height: 44px;
          padding: 10px 15px;
        }

        /* Increase territory click areas */
        .territory {
          stroke-width: 3;
        }

        /* Remove hover effects on touch devices */
        *:hover {
          transition: none;
        }

        /* Add active state instead */
        *:active {
          opacity: 0.7;
          transition: opacity 0.1s;
        }
      }

      /* Music Manager Modal */
      #musicManagerModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        justify-content: center;
        align-items: center;
      }

      .music-manager-container {
        background-color: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .music-manager-header {
        background: linear-gradient(135deg, #4CAF50, #45a049);
        color: white;
        padding: 1.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .music-manager-header h2 {
        margin: 0;
        font-size: 1.5rem;
      }

      .music-close-btn {
        background: none;
        border: none;
        color: white;
        font-size: 1.8rem;
        cursor: pointer;
        width: auto;
        padding: 0;
        line-height: 1;
      }

      .music-close-btn:hover {
        background: none;
        color: #ffcccc;
      }

      .music-manager-body {
        padding: 1.5rem;
        overflow-y: auto;
        flex: 1;
      }

      .music-section {
        margin-bottom: 1.5rem;
      }

      .music-section h3 {
        color: #333;
        margin-bottom: 0.75rem;
        font-size: 1.1rem;
      }

      .music-folders {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-bottom: 1rem;
      }

      .music-folder-btn {
        padding: 0.5rem 1rem;
        background-color: #f0f0f0;
        border: 2px solid #ddd;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
      }

      .music-folder-btn:hover {
        background-color: #e0e0e0;
        border-color: #4CAF50;
      }

      .music-folder-btn.active {
        background-color: #4CAF50;
        color: white;
        border-color: #45a049;
      }

      .music-tracks {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #ddd;
        border-radius: 6px;
        background-color: white;
      }

      .track-item {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .track-item:last-child {
        border-bottom: none;
      }

      .track-item:hover {
        background-color: #f5f5f5;
      }

      .track-folder-header {
        padding: 0.5rem 1rem;
        background-color: #4CAF50;
        color: white;
        font-weight: bold;
        font-size: 0.9rem;
        border-bottom: 2px solid #45a049;
      }

      .now-playing {
        background-color: #e8f5e9;
        padding: 0.75rem;
        border-radius: 6px;
        text-align: center;
        margin-bottom: 1rem;
        font-weight: 500;
        color: #2e7d32;
      }

      .music-shortcuts {
        background-color: #fff3cd;
        padding: 0.75rem;
        border-radius: 6px;
        font-size: 0.85rem;
        color: #856404;
        margin-top: 1rem;
      }

      .music-shortcuts strong {
        display: block;
        margin-bottom: 0.25rem;
      }
    </style>
  </head>
  <body>
    <!-- Custom Cursor -->
    <div class="custom-cursor">
        <img src="images/cursor1-32x32.png" alt="cursor">
    </div>

    <!-- Mobile Navigation Buttons -->
    <div class="mobile-nav-buttons">
      <a href="Stats/dashboard.html" class="mobile-nav-button dashboard-nav-button" title="Open Dashboard" target="_blank" rel="noopener"></a>
      <button class="mobile-nav-button music-button" id="mobile-music-button" title="Open Music Manager (N)"></button>
      <button class="mobile-nav-button sizing-button" id="mobile-sizing-button" title="Open Map Calibration (C)"></button>
    </div>

    <div class="game-container">
      <div class="sidebar">
        <!-- Mobile Sidebar Toggle -->
        <div class="sidebar-toggle mobile-only" id="sidebar-toggle" title="Tap to expand/collapse">
          <span></span>
        </div>

        <!-- 1. Turn Counter (NEW - First Element) -->
        <div class="turn-counter-panel" id="turn-counter-panel">
          <span class="turn-prefix"> Turn: </span><span class="turn-number" id="turn-number-display">1</span>
        </div>

        <!-- 2. Phase Progress Indicator -->
        <div class="phase-progress-panel" id="phase-progress-panel">
          <div class="phase-progress-header">Phase Progress</div>
          <div class="phase-progress-bar" id="phase-progress-bar">
            <!-- Dynamically populated by JavaScript -->
          </div>
        </div>

        <!-- 3. Players Turn Order -->
        <div class="players-turn-order" id="players-turn-order">
          <div class="players-order-header">Turn Order</div>
          <ul class="players-list-order" id="players-list-order">
            <!-- Dynamically populated with player list -->
          </ul>
        </div>

        <!-- 4. Phase Completion Notice -->
        <div class="phase-completion-notice" id="phase-completion-notice"></div>

        <!-- 5. Next Phase / End Turn Button -->
        <div class="phase-control-panel">
          <button 
            class="end-turn-button-enhanced phase-deploy" 
            id="end-turn-enhanced"
            onclick="window.handleEndTurn()"
          >
            Next Phase
          </button>
          <button 
            class="skip-phase-button" 
            id="skip-phase-button"
            onclick="window.handleSkipPhase()"
            style="display: none"
          >
             Skip This Phase
          </button>
        </div>

        <!-- 6. Original Player Info (Hidden but preserved for compatibility) -->
        <div class="player-info" style="display: none">
          <div class="current-player">
            <h2>Current Turn</h2>
            <div id="current-player-name"></div>
          </div>
          <div class="player-list">
            <h3>Players</h3>
            <div id="player-list-container"></div>
          </div>
        </div>

        <!-- 7. Ready to Deploy Panel (BOTTOM) -->
        <div class="reinforcement-panel" id="reinforcement-panel">
          <div class="reinforcement-counter" id="reinforcement-counter">0</div>
          <div class="reinforcement-info" id="reinforcement-info">
            <div class="reinforcement-status" id="reinforcement-status">Ready to deploy</div>
          </div>
        </div>

        <!-- Attack Button in Sidebar (appears when valid attacking territory is selected) -->
        <div
          id="attack-button-container"
          style="display: none; margin-bottom: 20px"
        >
          <button
            class="attack-btn"
            id="open-attack-modal"
            onclick="window.openAttackModal()"
          >
             Launch Attack
          </button>
          <div
            class="attack-info"
            style="
              margin-top: 10px;
              padding: 10px;
              background: #fff3cd;
              border-radius: 6px;
            "
          >
            <div
              id="selected-attacking-territory"
              style="font-weight: bold; color: #856404"
            ></div>
            <div style="font-size: 0.9em; color: #666">
              Click to open attack window
            </div>
          </div>
        </div>

        <!-- Game Controls -->
        <div class="controls">
          <button class="btn" id="reset-view">Reset View</button>
          <button class="btn" id="rules-btn">Game Rules</button>
        </div>

        <!-- Game Rules Modal -->
        <div id="rules-modal" class="modal">
          <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Risk Game Rules</h2>

            <h3>Initial Army Count</h3>
            <p>
              At the beginning of the game, each player receives armies based on
              the number of players:
            </p>
            <table class="rules-table">
              <tr>
                <th>Players</th>
                <th>Initial Armies</th>
              </tr>
              <tr>
                <td>2 players</td>
                <td>40 armies each</td>
              </tr>
              <tr>
                <td>3 players</td>
                <td>35 armies each</td>
              </tr>
              <tr>
                <td>4 players</td>
                <td>30 armies each</td>
              </tr>
              <tr>
                <td>5 players</td>
                <td>25 armies each</td>
              </tr>
              <tr>
                <td>6 players</td>
                <td>20 armies each</td>
              </tr>
            </table>

            <h3>Reinforcement Rules</h3>
            <p>At the beginning of each turn, you receive:</p>
            <ul>
              <li>1 army for every 3 territories you control (minimum of 3)</li>
              <li>
                Continent bonus armies if you control an entire continent:
                <ul>
                  <li>North America: 5 armies</li>
                  <li>South America: 2 armies</li>
                  <li>Europe: 5 armies</li>
                  <li>Africa: 3 armies</li>
                  <li>Asia: 7 armies</li>
                  <li>Australia: 2 armies</li>
                </ul>
              </li>
            </ul>
          </div>
        </div>

        <!-- Battle Management Modal -->
        <div id="battle-modal" class="modal">
          <div class="modal-content battle-modal-content">
            <div class="battle-header">
              <h3>Battle Resolution</h3>
              <button class="close-btn" onclick="window.closeBattleModal()">
                &times;
              </button>
            </div>

            <div class="battle-info">
              <div class="battle-territories">
                <div class="battle-territory attacker">
                  <div class="territory-label">ATTACKER</div>
                  <div class="territory-name" id="battle-attacker-name">
                    Territory Name
                  </div>
                  <div class="territory-owner" id="battle-attacker-owner">
                    Player Name
                  </div>
                  <div class="territory-armies" id="battle-attacker-armies">
                    0 armies
                  </div>
                </div>
                <div class="battle-vs">VS</div>
                <div class="battle-territory defender">
                  <div class="territory-label">DEFENDER</div>
                  <div class="territory-name" id="battle-defender-name">
                    Territory Name
                  </div>
                  <div class="territory-owner" id="battle-defender-owner">
                    Player Name
                  </div>
                  <div class="territory-armies" id="battle-defender-armies">
                    0 armies
                  </div>
                </div>
              </div>

              <div class="battle-instructions">
                <p>Enter the number of armies remaining after the battle:</p>
                <p class="battle-note">
                  Note: Armies cannot exceed initial numbers. If defender has 0
                  armies, territory will be conquered.
                </p>
              </div>

              <div class="battle-inputs">
                <div class="battle-input-group">
                  <label for="attacker-remaining"
                    >Attacker Remaining Armies:</label
                  >
                  <div class="army-input-controls">
                    <button
                      type="button"
                      onclick="window.adjustBattleArmies('attacker', -1)"
                    >
                      
                    </button>
                    <input
                      type="number"
                      id="attacker-remaining"
                      min="1"
                      max="0"
                      value="0"
                    />
                    <button
                      type="button"
                      onclick="window.adjustBattleArmies('attacker', 1)"
                    >
                      +
                    </button>
                  </div>
                  <div class="input-constraint" id="attacker-constraint">
                    Max: 0 armies
                  </div>
                </div>

                <div class="battle-input-group">
                  <label for="defender-remaining"
                    >Defender Remaining Armies:</label
                  >
                  <div class="army-input-controls">
                    <button
                      type="button"
                      onclick="window.adjustBattleArmies('defender', -1)"
                    >
                      
                    </button>
                    <input
                      type="number"
                      id="defender-remaining"
                      min="0"
                      max="0"
                      value="0"
                    />
                    <button
                      type="button"
                      onclick="window.adjustBattleArmies('defender', 1)"
                    >
                      +
                    </button>
                  </div>
                  <div class="input-constraint" id="defender-constraint">
                    Max: 0 armies
                  </div>
                </div>
              </div>

              <div class="battle-preview">
                <h4>Battle Result Preview:</h4>
                <div class="battle-preview-item">
                  <span id="preview-attacker-name">Attacker</span>:
                  <span id="preview-attacker-armies">0 armies</span>
                </div>
                <div class="battle-preview-item">
                  <span id="preview-defender-name">Defender</span>:
                  <span id="preview-defender-armies">0 armies</span>
                </div>
                <div
                  class="battle-conquest"
                  id="battle-conquest"
                  style="display: none"
                >
                  <strong> Territory will be conquered!</strong>
                </div>
              </div>

              <div class="battle-actions">
                <button class="cancel-btn" onclick="window.closeBattleModal()">
                  Cancel
                </button>
                <button
                  class="resolve-btn"
                  id="resolve-battle-btn"
                  onclick="window.resolveBattle()"
                >
                  Resolve Battle
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Unit Transfer Modal -->
        <div id="unit-transfer-modal" class="modal">
          <div class="modal-content unit-transfer-modal-content">
            <div class="transfer-header">
              <h3> Territory Conquered!</h3>
              <p class="conquest-message">
                Choose how many armies to move to your new territory
              </p>
            </div>

            <div class="transfer-info">
              <div class="transfer-territories">
                <div class="transfer-territory source">
                  <div class="territory-label">FROM</div>
                  <div class="territory-name" id="transfer-source-name">
                    Attacking Territory
                  </div>
                  <div class="territory-armies" id="transfer-source-armies">
                    0 armies
                  </div>
                </div>
                <div class="transfer-arrow"></div>
                <div class="transfer-territory destination">
                  <div class="territory-label">TO (CONQUERED)</div>
                  <div class="territory-name" id="transfer-destination-name">
                    Conquered Territory
                  </div>
                  <div
                    class="territory-armies"
                    id="transfer-destination-armies"
                  >
                    1 army (minimum)
                  </div>
                </div>
              </div>

              <div class="transfer-constraints">
                <p><strong>Transfer Rules:</strong></p>
                <ul>
                  <li>Minimum 1 army must move to conquered territory</li>
                  <li>At least 1 army must remain in attacking territory</li>
                  <li id="transfer-range">You can transfer 1-0 armies</li>
                </ul>
              </div>

              <div class="transfer-controls">
                <label for="transfer-slider">Armies to Transfer:</label>
                <div class="transfer-input-group">
                  <div class="slider-container">
                    <input
                      type="range"
                      id="transfer-slider"
                      min="1"
                      max="1"
                      value="1"
                      aria-label="Armies to Transfer - drag slider to select amount"
                      title="Drag slider to select number of armies to transfer"
                      class="transfer-slider"
                    />
                    <div class="slider-labels">
                      <span>1</span>
                      <span id="slider-max-label">1</span>
                    </div>
                  </div>
                  <div class="direct-input">
                    <label for="transfer-input">Or type directly:</label>
                    <div class="transfer-number-input">
                      <button
                        type="button"
                        aria-label="Decrease transfer armies"
                        title="Decrease armies to transfer"
                        onclick="window.adjustTransferArmies(-1)"
                      >
                        
                      </button>
                      <input
                        type="number"
                        id="transfer-input"
                        min="1"
                        max="1"
                        value="1"
                        aria-label="Transfer armies - enter amount directly"
                        title="Enter number of armies to transfer"
                      />
                      <button
                        type="button"
                        aria-label="Increase transfer armies"
                        title="Increase armies to transfer"
                        onclick="window.adjustTransferArmies(1)"
                      >
                        +
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <div class="transfer-preview">
                <h4>Result Preview:</h4>
                <div class="transfer-result">
                  <div class="result-item">
                    <span id="preview-source-name">Attacking Territory</span>:
                    <span id="preview-source-armies">0 armies remaining</span>
                  </div>
                  <div class="result-item">
                    <span id="preview-destination-name"
                      >Conquered Territory</span
                    >:
                    <span id="preview-destination-armies">1 army total</span>
                  </div>
                </div>
              </div>

              <div class="transfer-error">
                <p id="transfer-error-message" class="error-message"></p>
              </div>

              <div class="transfer-actions">
                <button class="secondary-btn" id="use-minimum-btn">
                  Use Minimum (1 army)
                </button>
                <button class="primary-btn" id="confirm-transfer-btn">
                  Confirm Transfer
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Attack Modal Window -->
        <div id="attack-modal" class="modal">
          <div class="modal-content attack-modal-content">
            <div class="attack-header">
              <h3> Attack Phase</h3>
              <button class="close-btn" onclick="window.closeAttackModal()">
                
              </button>
            </div>

            <div class="attack-info">
              <div class="attack-status" id="attack-modal-status">
                Select territories to attack
              </div>
            </div>

            <!-- Step 1: Territory Selection Display -->
            <div class="attack-selection" id="attack-modal-selection">
              <div class="attack-territory">
                <div class="territory-label"> Attacking From</div>
                <div class="territory-name" id="attack-modal-attacking-name">
                  -
                </div>
                <div
                  class="territory-armies"
                  id="attack-modal-attacking-armies"
                >
                  0 armies
                </div>
              </div>
              <div class="attack-vs">VS</div>
              <div class="defend-territory">
                <div class="territory-label"> Defending</div>
                <div class="territory-name" id="attack-modal-defending-name">
                  Select target
                </div>
                <div
                  class="territory-armies"
                  id="attack-modal-defending-armies"
                >
                  0 armies
                </div>
              </div>
            </div>

            <!-- Step 2: Direct Army Input Controls -->
            <div
              class="army-input"
              id="attack-modal-army-input"
              style="
                display: none;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 8px;
                padding: 15px;
                margin: 15px 0;
                border: 1px solid rgba(0, 0, 0, 0.1);
              "
            >
              <div
                style="
                  margin-bottom: 10px;
                  text-align: center;
                  font-weight: bold;
                  color: #333;
                "
              >
                Enter armies remaining after battle
              </div>
              <div class="army-controls" style="margin-bottom: 15px">
                <label
                  style="
                    display: block;
                    margin-bottom: 5px;
                    font-weight: 600;
                    color: #2196f3;
                  "
                  >Attacker Remaining Armies:</label
                >
                <div style="display: flex; align-items: center; gap: 8px">
                  <button
                    type="button"
                    aria-label="Decrease attacker armies"
                    title="Decrease attacker armies"
                    style="
                      width: 36px;
                      height: 36px;
                      border: 1px solid #ced4da;
                      background: #fff;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 18px;
                      font-weight: bold;
                    "
                    onclick="const attackerInput = document.getElementById('attack-modal-attacker-armies-input'); if(parseInt(attackerInput.value) > parseInt(attackerInput.min)) attackerInput.value = parseInt(attackerInput.value) - 1;"
                  >
                    
                  </button>
                  <input
                    type="number"
                    id="attack-modal-attacker-armies-input"
                    min="1"
                    title="Attacker remaining armies after battle"
                    placeholder="Enter attacker armies"
                    aria-label="Attacker remaining armies after battle"
                    style="
                      flex: 1;
                      height: 36px;
                      text-align: center;
                      border: 2px solid #2196f3;
                      border-radius: 4px;
                      font-size: 16px;
                      font-weight: bold;
                    "
                    class="army-input-field"
                  />
                  <button
                    type="button"
                    aria-label="Increase attacker armies"
                    title="Increase attacker armies"
                    style="
                      width: 36px;
                      height: 36px;
                      border: 1px solid #ced4da;
                      background: #fff;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 18px;
                      font-weight: bold;
                    "
                    onclick="const attackerInput2 = document.getElementById('attack-modal-attacker-armies-input'); if(parseInt(attackerInput2.value) < parseInt(attackerInput2.max)) attackerInput2.value = parseInt(attackerInput2.value) + 1;"
                  >
                    +
                  </button>
                </div>
              </div>
              <div class="army-controls">
                <label
                  style="
                    display: block;
                    margin-bottom: 5px;
                    font-weight: 600;
                    color: #f44336;
                  "
                  >Defender Remaining Armies:</label
                >
                <div style="display: flex; align-items: center; gap: 8px">
                  <button
                    type="button"
                    aria-label="Decrease defender armies"
                    title="Decrease defender armies"
                    style="
                      width: 36px;
                      height: 36px;
                      border: 1px solid #ced4da;
                      background: #fff;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 18px;
                      font-weight: bold;
                    "
                    onclick="const defenderInput = document.getElementById('attack-modal-defender-armies-input'); if(parseInt(defenderInput.value) > parseInt(defenderInput.min)) defenderInput.value = parseInt(defenderInput.value) - 1;"
                  >
                    
                  </button>
                  <input
                    type="number"
                    id="attack-modal-defender-armies-input"
                    min="0"
                    title="Defender remaining armies after battle"
                    placeholder="Enter defender armies"
                    aria-label="Defender remaining armies after battle"
                    style="
                      flex: 1;
                      height: 36px;
                      text-align: center;
                      border: 2px solid #f44336;
                      border-radius: 4px;
                      font-size: 16px;
                      font-weight: bold;
                    "
                    class="army-input-field"
                  />
                  <button
                    type="button"
                    aria-label="Increase defender armies"
                    title="Increase defender armies"
                    style="
                      width: 36px;
                      height: 36px;
                      border: 1px solid #ced4da;
                      background: #fff;
                      border-radius: 4px;
                      cursor: pointer;
                      font-size: 18px;
                      font-weight: bold;
                    "
                    onclick="const defenderInput2 = document.getElementById('attack-modal-defender-armies-input'); if(parseInt(defenderInput2.value) < parseInt(defenderInput2.max)) defenderInput2.value = parseInt(defenderInput2.value) + 1;"
                  >
                    +
                  </button>
                </div>
                <div
                  style="
                    margin-top: 8px;
                    font-size: 0.8em;
                    color: #666;
                    font-style: italic;
                  "
                >
                  Set to 0 to conquer the territory
                </div>
              </div>
            </div>

            <!-- Step 3: Attack Execution Button -->
            <!-- Event listener attached by CombatUI.initializeEventListeners() - no inline onclick needed -->
            <button
              class="attack-btn"
              id="attack-modal-execute"
              style="display: none"
            >
               COMMENCE BATTLE!
            </button>

            <!-- Step 4: Combat Results Display -->
            <div
              class="combat-results"
              id="attack-modal-results"
              style="display: none"
            >
              <h5> Battle Results</h5>
              <div class="losses-display">
                <div class="losses-group">
                  <div><strong>Attacker Losses</strong></div>
                  <div
                    class="losses-display"
                    id="attack-modal-attacker-losses"
                  ></div>
                </div>
                <div class="losses-group">
                  <div><strong>Defender Losses</strong></div>
                  <div
                    class="losses-display"
                    id="attack-modal-defender-losses"
                  ></div>
                </div>
              </div>
              <div class="battle-result" id="attack-modal-battle-result"></div>

              <!-- Step 5: Post-Combat Decisions -->
              <!-- Event listeners attached by CombatUI.initializeEventListeners() - no inline onclick needed -->
              <div class="attack-options" style="margin-top: 15px">
                <button
                  class="attack-btn"
                  id="attack-modal-continue"
                  style="display: none; background: #28a745"
                >
                   Continue Attack
                </button>
                <button
                  class="attack-btn"
                  id="attack-modal-end"
                  style="background: #6c757d"
                >
                   End Attack
                </button>
              </div>
            </div>

            <!-- Reset Attack Button -->
            <button
              class="attack-btn"
              id="attack-modal-reset"
              onclick="window.resetAttackState()"
              style="
                display: none;
                background: #ffc107;
                color: #000;
                margin-top: 10px;
              "
            >
               Select New Territories
            </button>
          </div>
        </div>

        <!-- Target Selection Modal (for keyboard navigation) -->
        <div id="target-selection-modal" class="modal" style="display: none;">
          <div class="modal-content target-selection-modal-content">
            <div class="attack-header">
              <h3> Select Attack Target</h3>
              <button class="close-btn" onclick="window.closeTargetSelectionModal()"></button>
            </div>

            <div class="attacking-territory-display">
              <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Attacking from:</div>
              <div class="territory-name" id="target-modal-attacking-name">-</div>
              <div class="territory-armies" id="target-modal-attacking-armies">0 armies</div>
            </div>

            <div style="text-align: center; margin-bottom: 10px; font-weight: bold; color: #333;">
              Select target territory:
            </div>
            <div style="text-align: center; margin-bottom: 15px; font-size: 0.85em; color: #666;">
              Use  arrow keys to navigate, Enter to select
            </div>

            <div class="target-list" id="target-list">
              <!-- Target territories will be populated here -->
            </div>
          </div>
        </div>

        <!-- Music Manager Modal -->
        <div id="musicManagerModal">
          <div class="music-manager-container">
            <div class="music-manager-header">
              <h2> Music Manager</h2>
              <button class="music-close-btn" onclick="musicPlayer.closeMusicManager()">&times;</button>
            </div>
            <div class="music-manager-body">
              <div class="now-playing" id="nowPlayingInfo">
                Now Playing: Select a track or folder
              </div>
              
              <div class="music-section">
                <h3>Select Music Folder</h3>
                <div class="music-folders" id="musicFolders">
                  <!-- Folder buttons will be dynamically added -->
                </div>
              </div>
              
              <div class="music-section">
                <h3>Available Tracks</h3>
                <div class="music-tracks" id="musicTracks">
                  <!-- Track list will be dynamically added -->
                </div>
              </div>
              
              <div class="music-shortcuts">
                <strong>Keyboard Shortcuts:</strong>
                M - Mute/Unmute | + - Next Track | - - Previous Track | N - Music Manager
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Turn Header Panel (Moved outside sidebar, below reinforcement panel) -->
      <div class="turn-header-panel" id="turn-header-panel">
        <div class="current-player-display">
          <span id="current-player-name-header">Loading...</span>
        </div>
      </div>

      <div class="map-container">
        <svg
          id="risk-map"
          viewBox="0 0 1920 1080"
          preserveAspectRatio="xMidYMid meet"
          role="img"
          aria-label="Risk game world map with territory borders"
          title="Interactive Risk game map - click territories to interact"
        >
          <defs>
            <filter
              id="drop-shadow"
              x="-20%"
              y="-20%"
              width="140%"
              height="140%"
            >
              <feGaussianBlur in="SourceAlpha" stdDeviation="1.5" />
              <feOffset dx="1" dy="1" />
              <feComponentTransfer>
                <feFuncA type="linear" slope="0.2" />
              </feComponentTransfer>
              <feMerge>
                <feMergeNode />
                <feMergeNode in="SourceGraphic" />
              </feMerge>
            </filter>
            
            <!-- Water texture pattern for ocean background -->
            <pattern id="ocean-water-texture" patternUnits="userSpaceOnUse" width="1920" height="1080">
              <image href="res/ui/gameScreenElements/waterTextures/summerWaterTexture.png" 
                     x="0" y="0"
                     width="1920" 
                     height="1080" 
                     preserveAspectRatio="none" />
            </pattern>
            
            <!-- Background world map pattern -->
            <pattern id="world-map-bg" patternUnits="userSpaceOnUse" width="1920" height="1080">
              <image href="res/maps/classic/preview.png" 
                     x="0" y="0"
                     width="1920" 
                     height="1080" 
                     preserveAspectRatio="none" />
            </pattern>
            
            <!-- Gradient overlay for better territory visibility -->
            <linearGradient id="overlay-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:rgba(255,255,255,0.1);stop-opacity:1" />
              <stop offset="100%" style="stop-color:rgba(0,0,0,0.1);stop-opacity:1" />
            </linearGradient>
            
            <!-- Dynamic vignette effect for water texture -->
            <radialGradient id="water-vignette" cx="50%" cy="50%" r="70%" gradientUnits="objectBoundingBox">
              <stop offset="0%" style="stop-color:rgba(255,255,255,0);stop-opacity:0">
                <animate attributeName="stop-opacity" values="0;0.08;0.02;0" dur="6s" repeatCount="indefinite" />
              </stop>
              <stop offset="40%" style="stop-color:rgba(0,0,0,0.1);stop-opacity:0.1">
                <animate attributeName="stop-opacity" values="0.1;0.25;0.15;0.1" dur="6s" repeatCount="indefinite" />
                <animate attributeName="offset" values="0.4;0.35;0.42;0.4" dur="10s" repeatCount="indefinite" />
              </stop>
              <stop offset="70%" style="stop-color:rgba(0,0,0,0.4);stop-opacity:0.4">
                <animate attributeName="stop-opacity" values="0.4;0.55;0.45;0.4" dur="6s" repeatCount="indefinite" />
                <animate attributeName="offset" values="0.7;0.65;0.72;0.7" dur="10s" repeatCount="indefinite" />
              </stop>
              <stop offset="100%" style="stop-color:rgba(0,0,0,0.7);stop-opacity:0.7">
                <animate attributeName="stop-opacity" values="0.7;0.85;0.75;0.7" dur="6s" repeatCount="indefinite" />
              </stop>
            </radialGradient>
          </defs>
          
          <!-- LAYER 1: Water Texture Background (independently controllable) -->
          <g id="water-layer-container" transform="translate(0, 0) scale(1)">
            <rect width="1920" height="1080" fill="url(#ocean-water-texture)" opacity="0.85" />
            
            <!-- Dynamic vignette overlay for water texture -->
            <rect x="0" y="0" width="1920" height="1080" fill="url(#water-vignette)" opacity="0.85">
              <animate attributeName="opacity" values="0.85;0.92;0.88;0.85" dur="8s" repeatCount="indefinite" />
            </rect>
          </g>
          
          <!-- LAYER 2: World Map Background (independently controllable) -->
          <g id="map-layer-container" transform="translate(0, 0) scale(1)">
            <rect width="1920" height="1080" fill="url(#world-map-bg)" opacity="0.85" />
            
            <!-- Subtle overlay for better territory contrast -->
            <rect width="1920" height="1080" fill="url(#overlay-gradient)" opacity="0.2" />
          </g>
          
          <!-- LAYER 3: SVG Territories (independently controllable) -->
          <g id="territory-layer-container" transform="translate(0, 0) scale(1)">
            <g id="territory-content" class="map-group">
              <g
                id="north-america"
                class="continent continent-na"
                filter="url(#drop-shadow)"
              ></g>
              <g
                id="south-america"
                class="continent continent-sa"
                filter="url(#drop-shadow)"
              ></g>
              <g
                id="europe"
                class="continent continent-eu"
                filter="url(#drop-shadow)"
              ></g>
              <g
                id="africa"
                class="continent continent-af"
                filter="url(#drop-shadow)"
              ></g>
              <g
                id="asia"
                class="continent continent-as"
                filter="url(#drop-shadow)"
              ></g>
              <g
                id="australia"
                class="continent continent-au"
                filter="url(#drop-shadow)"
              ></g>
            </g>
          </g> <!-- End of territory-layer-container -->
        </svg>
        <div class="tooltip"></div>
      </div>
    </div>

    <!-- Load game scripts -->
    <script src="js/MusicPlayer.js"></script>
    <script>
      /**
       * RISK GAME DIGITAL EDITION - ARCHITECTURE OVERVIEW
       * ================================================
       *
       * This is a digital implementation of the classic Risk board game.
       *
       * MAIN COMPONENTS:
       * - game.html: Main game interface and UI logic
       * - GameState.js: Core game state management
       * - RiskUI.js: UI management and player interactions
       * - RiskMap.js: SVG map rendering and territory interactions
       * - PhaseManager.js: Game phase transitions
       * - Various managers: Reinforcement, Fortification, Attack, etc.
       *
       * KEY FEATURES:
       * - Modal-based attack system with dice rolling
       * - Army transfer system following official Risk rules
       * - Real-time territory ownership visualization
       * - Player color customization
       * - Phase-based gameplay (Deploy  Attack  Fortify)
       *
       * DATA FLOW:
       * 1. User interactions  RiskUI.js  GameState.js
       * 2. GameState updates  UI updates via event system
       * 3. Map interactions  RiskMap.js  game.html handlers
       *
       * ERROR HANDLING:
       * - All DOM access uses GameUtils.safeGetElement()
       * - Game state access validated before operations
       * - Comprehensive null checks throughout
       */

      /**
       * Utility Functions for Safe DOM Access and Error Handling
       * Provides standardized methods for DOM manipulation and game state access
       */
      window.GameUtils = {
        /**
         * Safe DOM element retrieval with optional logging
         * @param {string} id - Element ID to retrieve
         * @param {boolean} warnOnMissing - Whether to log warning if element not found
         * @returns {HTMLElement|null} - Found element or null
         */
        safeGetElement: function (id, warnOnMissing = true) {
          const element = document.getElementById(id);
          if (!element && warnOnMissing) {
            console.warn(`Element not found: ${id}`);
          }
          return element;
        },

        /**
         * Safe element class manipulation
         * @param {string|HTMLElement} elementOrId - Element or element ID
         * @param {string} className - CSS class name to toggle
         * @param {boolean|null} force - Force add/remove (true/false) or toggle (null)
         * @returns {boolean} - Success status
         */
        safeToggleClass: function (elementOrId, className, force = null) {
          const element =
            typeof elementOrId === "string"
              ? this.safeGetElement(elementOrId, false)
              : elementOrId;

          if (element && element.classList) {
            if (force !== null) {
              element.classList.toggle(className, force);
            } else {
              element.classList.toggle(className);
            }
            return true;
          }
          return false;
        },

        /**
         * Safe property setting on DOM elements
         * @param {string|HTMLElement} elementOrId - Element or element ID
         * @param {string} property - Property name to set
         * @param {any} value - Value to set
         * @returns {boolean} - Success status
         */
        safeSetProperty: function (elementOrId, property, value) {
          const element =
            typeof elementOrId === "string"
              ? this.safeGetElement(elementOrId, false)
              : elementOrId;

          if (element && property in element) {
            element[property] = value;
            return true;
          }
          return false;
        },

        // Safe function execution with error handling
        safeExecute: function (fn, context = null, ...args) {
          try {
            if (typeof fn === "function") {
              return fn.apply(context, args);
            } else if (
              typeof fn === "string" &&
              context &&
              typeof context[fn] === "function"
            ) {
              return context[fn].apply(context, args);
            }
          } catch (error) {
            console.error("Error executing function:", error);
          }
          return null;
        },

        // Get game state from multiple possible sources
        getGameState: function () {
          return (
            window.riskUI?.gameState ||
            window.gameState ||
            window.GameState ||
            null
          );
        },

        // Validate game state before operations
        validateGameState: function () {
          const gameState = this.getGameState();
          if (!gameState) {
            console.warn("Game state not available");
            return false;
          }
          return true;
        },

        /**
         * Enhanced safe element update helper
         * @param {string} elementId - Element ID to update
         * @param {string} property - Property to set (textContent, innerHTML, etc.)
         * @param {any} value - Value to set
         * @returns {boolean} - Success status
         */
        safeUpdateElement: function (elementId, property, value) {
          return this.safeSetProperty(elementId, property, value);
        },

        /**
         * Safe event listener attachment
         * @param {string} elementId - Element ID to attach event to
         * @param {string} event - Event type (click, change, etc.)
         * @param {Function} handler - Event handler function
         * @returns {boolean} - Success status
         */
        safeAddEventListener: function (elementId, event, handler) {
          const element = this.safeGetElement(elementId, false);
          if (element && typeof handler === "function") {
            element.addEventListener(event, handler);
            return true;
          }
          return false;
        },

        /**
         * Safe style property setting
         * @param {string} elementId - Element ID to style
         * @param {string} property - CSS property to set
         * @param {string} value - CSS value to set
         * @returns {boolean} - Success status
         */
        safeSetStyle: function (elementId, property, value) {
          const element = this.safeGetElement(elementId, false);
          if (element && element.style) {
            element.style[property] = value;
            return true;
          }
          return false;
        },

        /**
         * Safe display toggle (show/hide elements)
         * @param {string} elementId - Element ID to toggle
         * @param {boolean} show - True to show, false to hide
         * @returns {boolean} - Success status
         */
        safeToggleDisplay: function (elementId, show) {
          return this.safeSetStyle(
            elementId,
            "display",
            show ? "block" : "none"
          );
        },

        /**
         * Safe function execution with try-catch
         * @param {Function} fn - Function to execute safely
         * @returns {any} - Function result or false on error
         */
        safeCall: function (fn) {
          try {
            return fn();
          } catch (error) {
            console.warn("safeCall failed:", error);
            return false;
          }
        },

        /**
         * Safe phase display update
         * Safely calls the PhaseManager's updatePhaseDisplay method
         * @returns {boolean} - Success status
         */
        safeUpdatePhaseDisplay: function () {
          return this.safeCall(() => {
            if (window.riskUI?.phaseManager?.updatePhaseDisplay) {
              window.riskUI.phaseManager.updatePhaseDisplay();
              return true;
            }
            return false;
          });
        },
      };

      /* ===============================================
       * COMBAT SYSTEM INTEGRATION STATUS
       * ===============================================
       *
       *  NEW COMBAT SYSTEM ACTIVE:
       * - CombatSystem.js: Clean OOP combat logic
       * - CombatIntegration.js: UI integration layer
       * - combat-system.css: Modern combat styling
       * - PhaseManager.js: Updated with combat integration
       *
       *   LEGACY CODE BELOW (DEPRECATED):
       * The functions below are legacy attack system code.
       * They are kept for backward compatibility but are
       * no longer used in the active game flow.
       *
       * Active Combat Flow:
       * Territory Click  handleTerritoryClick()  CombatUI  CombatSystem
       *
       * Legacy functions marked for future removal:
       * - window.attackState (replaced by CombatSystem state)
       * - executeAttack() (replaced by executeCombatBattle())
       * - performSimpleCombat() (replaced by CombatSystem.executeBattle())
       * - All attack modal functions (replaced by dynamic combat panels)
       *
       * =============================================== */

      // Global wrapper functions for backward compatibility
      window.updatePhaseDisplay = function (phase) {
        return GameUtils.safeUpdatePhaseDisplay();
      };

      // Phase control wrapper functions
      window.startAttackPhase = function () {
        return GameUtils.safeCall(() => {
          if (window.riskUI?.phaseManager?.setPhase) {
            window.riskUI.phaseManager.setPhase("attack");
            return true;
          }
          return false;
        });
      };

      window.endAttackPhase = function () {
        return GameUtils.safeCall(() => {
          if (window.riskUI?.phaseManager?.advancePhase) {
            window.riskUI.phaseManager.advancePhase();
            return true;
          }
          return false;
        });
      };

      window.skipAttackPhase = function () {
        return GameUtils.safeCall(() => {
          if (window.riskUI?.phaseManager?.skipPhase) {
            window.riskUI.phaseManager.skipPhase();
            return true;
          }
          return false;
        });
      };

      // ========================================
      // TURN MANAGEMENT FUNCTIONS - ENHANCED
      // ========================================

      /**
       * Update turn header panel color to match current player
       * Separate function that can be called independently
       */
      window.updateTurnHeaderPanelColor = function() {
        try {
          if (!window.gameState) return false;
          
          const currentPlayer = window.gameState.getCurrentPlayer();
          const turnHeaderPanel = document.getElementById("turn-header-panel");
          
          // Try multiple ways to access ColorManager
          const colorManager = window.ColorManager || 
                              (window.riskUI && window.riskUI.colorManager) ||
                              null;
          
          if (turnHeaderPanel && colorManager && currentPlayer) {
            const playerColor = colorManager.getPlayerColor(currentPlayer);
            turnHeaderPanel.style.background = 
              `linear-gradient(135deg, ${playerColor} 0%, ${playerColor}dd 100%)`;
            turnHeaderPanel.style.color = "white";
            turnHeaderPanel.style.boxShadow = 
              `0 2px 8px ${playerColor}40`;
            
            console.log(` Turn header panel color updated to ${currentPlayer}: ${playerColor}`);
            return true;
          } else {
            if (!colorManager) {
              console.warn(" ColorManager not available for turn header panel update");
            }
            return false;
          }
        } catch (error) {
          console.error("Error updating turn header panel color:", error);
          return false;
        }
      };

      /**
       * Highlight all territories owned by the current player
       * Shows bright dashed borders in the player's color
       */
      window.highlightPlayerTerritories = function() {
        try {
          if (!window.gameState) return;
          
          const currentPlayer = window.gameState.getCurrentPlayer();
          const colorManager = window.ColorManager || 
                              (window.riskUI && window.riskUI.colorManager) ||
                              null;
          
          if (!colorManager || !currentPlayer) return;
          
          // Remove all previous highlights
          const allTerritories = document.querySelectorAll(".territory");
          allTerritories.forEach(territoryEl => {
            territoryEl.classList.remove("player-turn-highlight");
            territoryEl.style.stroke = "";
          });
          
          // Get player color
          const playerColor = colorManager.getPlayerColor(currentPlayer);
          
          // Highlight current player's territories
          const territories = window.gameState.territories;
          if (!territories) return;
          
          let highlightedCount = 0;
          Object.keys(territories).forEach(territoryId => {
            const territory = territories[territoryId];
            if (territory.owner === currentPlayer) {
              // Try multiple selector methods to find territory element
              const territoryEl = document.getElementById(territoryId) || 
                                 document.querySelector(`.territory[data-territory="${territoryId}"]`) ||
                                 document.querySelector(`path[id="${territoryId}"]`);
              
              if (territoryEl) {
                territoryEl.classList.add("player-turn-highlight");
                territoryEl.style.stroke = playerColor;
                highlightedCount++;
              } else {
                console.warn(` Territory element not found: ${territoryId}`);
              }
            }
          });
          
          console.log(` Highlighted ${highlightedCount} territories for ${currentPlayer} with color ${playerColor}`);
        } catch (error) {
          console.warn("Error highlighting player territories:", error);
        }
      };

      /**
       * Remove all territory highlighting
       */
      window.clearPlayerTerritoryHighlights = function() {
        try {
          const allTerritories = document.querySelectorAll(".territory");
          allTerritories.forEach(territoryEl => {
            territoryEl.classList.remove("player-turn-highlight");
            territoryEl.style.stroke = "";
          });
          console.log(" Cleared all territory highlights");
        } catch (error) {
          console.warn("Error clearing territory highlights:", error);
        }
      };

      /**
       * Debug function - Test territory highlighting
       * Call in console: testTerritoryHighlight()
       */
      window.testTerritoryHighlight = function() {
        console.log(" Testing territory highlighting...");
        
        // Check if territories exist in DOM
        const allTerritories = document.querySelectorAll(".territory");
        console.log(`Found ${allTerritories.length} territory elements in DOM`);
        
        // Check first few territories
        if (allTerritories.length > 0) {
          console.log("First 5 territories:", Array.from(allTerritories).slice(0, 5).map(t => ({
            id: t.id,
            className: t.className.baseVal || t.className,
            hasDataAttr: t.hasAttribute('data-territory')
          })));
        }
        
        // Check if gameState has territories
        if (window.gameState && window.gameState.territories) {
          const territoryIds = Object.keys(window.gameState.territories);
          console.log(`GameState has ${territoryIds.length} territories`);
          console.log("First 5 territory IDs:", territoryIds.slice(0, 5));
          
          // Show ownership info
          const ownedTerritories = {};
          territoryIds.forEach(id => {
            const owner = window.gameState.territories[id].owner;
            if (owner) {
              ownedTerritories[owner] = (ownedTerritories[owner] || 0) + 1;
            }
          });
          console.log("Territory ownership:", ownedTerritories);
        }
        
        // Try to highlight manually
        if (allTerritories.length > 0) {
          const testTerritory = allTerritories[0];
          testTerritory.classList.add("player-turn-highlight");
          testTerritory.style.stroke = "#FF0000";
          console.log(` Test highlight applied to: ${testTerritory.id}`);
        }
        
        // Test the actual function
        console.log(" Calling highlightPlayerTerritories()...");
        window.highlightPlayerTerritories();
      };

      /**
       * Trigger pop animation on reinforcement panel
       */
      window.triggerReinforcementPop = function() {
        const panelEl = document.getElementById("reinforcement-panel");
        if (!panelEl) return;
        
        // Remove class if it exists (to restart animation)
        panelEl.classList.remove('deploy-pop');
        
        // Trigger reflow to restart CSS animation
        void panelEl.offsetWidth;
        
        // Add class to trigger animation
        panelEl.classList.add('deploy-pop');
        
        // Remove class after animation completes
        setTimeout(() => {
          panelEl.classList.remove('deploy-pop');
        }, 400);
      };

      /**
       * Update reinforcement panel to show startup or reinforcement phase info
       */
      window.updateReinforcementPanel = function() {
        const currentPhase = window.gameState?.phase;
        const currentPlayer = window.gameState?.getCurrentPlayer();
        const remainingArmies = window.gameState?.remainingArmies?.[currentPlayer] || 0;
        
        const counterEl = document.getElementById("reinforcement-counter");
        const statusEl = document.getElementById("reinforcement-status");
        const panelEl = document.getElementById("reinforcement-panel");
        const turnHeaderPanel = document.getElementById("turn-header-panel");
        
        if (!counterEl || !statusEl || !panelEl) return;
        
        // Check if armies decreased (unit deployed)
        const previousCount = parseInt(counterEl.textContent) || 0;
        const armiesDeployed = previousCount > remainingArmies;
        
        // Update counter
        counterEl.textContent = remainingArmies;
        
        // Trigger pop animation if units were deployed
        if (armiesDeployed && remainingArmies >= 0) {
          window.triggerReinforcementPop();
        }
        
        // Match the exact background and border from turn header panel
        if (turnHeaderPanel) {
          const turnHeaderBg = window.getComputedStyle(turnHeaderPanel).background;
          const turnHeaderBorderColor = window.getComputedStyle(turnHeaderPanel).borderColor;
          
          // Copy the exact background from turn header
          panelEl.style.background = turnHeaderBg;
          
          // Use the same color scheme for border
          const colorManager = window.ColorManager || 
                              (window.riskUI && window.riskUI.colorManager) ||
                              null;
          
          if (colorManager && currentPlayer) {
            const playerColor = colorManager.getPlayerColor(currentPlayer);
            
            // Set border and shadow to match player color
            panelEl.style.borderColor = playerColor;
            panelEl.style.boxShadow = 
              `0 6px 20px rgba(0, 0, 0, 0.25), 0 2px 8px ${playerColor}40`;
            
            console.log(` Reinforcement panel synced with turn header panel for ${currentPlayer}`);
          }
        }
        
        // Counter text is always black for readability
        counterEl.style.color = '#000000';
        
        // Update status and instructions based on phase
        if (currentPhase === 'startup') {
          statusEl.textContent = remainingArmies > 0 
            ? "Initial armies to deploy" 
            : "Initial deployment complete";
          
          // Highlight panel during startup
          panelEl.classList.toggle('active', remainingArmies > 0);
        } else if (currentPhase === 'reinforcement') {
          statusEl.textContent = remainingArmies > 0 
            ? "Ready to deploy reinforcements" 
            : "Reinforcement complete";
          
          panelEl.classList.toggle('active', remainingArmies > 0);
          panelEl.classList.toggle('complete', remainingArmies === 0);
        } else {
          // Non-deployment phases
          statusEl.textContent = "No deployment this phase";
          panelEl.classList.remove('active', 'complete');
        }
        
        // Update dashboard when armies are deployed
        if (armiesDeployed && window.updateDashboardData) {
          window.updateDashboardData();
        }
      };

      /**
       * Update the turn management UI display
       * Called after any phase or player change
       */
      window.updateTurnManagementUI = function () {
        try {
          if (!window.gameState || !window.phaseSynchronizer) return;

          const gameState = window.gameState;
          const currentPlayer = gameState.getCurrentPlayer();
          const currentPhase = gameState.phase;
          const turnNumber = gameState.turnNumber || 1;
          const players = gameState.players || [];

          // 1. Update Turn Header
          const turnNumberEl = document.getElementById("turn-number-display");
          const turnPrefixEl = document.getElementById("turn-prefix");
          
          if (turnNumberEl) {
            // Show "Initial Setup" instead of turn number during startup
            if (currentPhase === 'startup') {
              if (turnPrefixEl) {
                turnPrefixEl.textContent = ' ';
              }
              turnNumberEl.textContent = 'Initial Setup';
              console.log(' Turn Display: Initial Setup phase');
            } else {
              if (turnPrefixEl) {
                turnPrefixEl.textContent = ' Turn ';
              }
              turnNumberEl.textContent = turnNumber;
              console.log(` Turn Display: Turn ${turnNumber}, Phase: ${currentPhase}`);
            }
          } else {
            console.warn(' Turn number display element not found!');
          }

          // 2. Update Current Player Display
          const playerNameHeader = document.getElementById(
            "current-player-name-header"
          );
          const playerColorDot = document.getElementById(
            "current-player-color"
          );
          if (playerNameHeader) {
            playerNameHeader.textContent = currentPlayer;
          }
          if (playerColorDot) {
            // Try multiple ways to access ColorManager
            const colorManager = window.ColorManager || 
                                (window.riskUI && window.riskUI.colorManager) ||
                                null;
            if (colorManager) {
              playerColorDot.style.backgroundColor =
                colorManager.getPlayerColor(currentPlayer);
            }
          }

          // Update turn header panel background color to match current player
          window.updateTurnHeaderPanelColor();

          // Highlight current player's territories
          window.highlightPlayerTerritories();

          // 3. Update Phase Progress Bar
          updatePhaseProgressBar(currentPhase);

          // 4. Update Players Turn Order List
          updatePlayersTurnOrder(players, currentPlayer);

          // 6. Update End Turn Button
          updateEndTurnButton(currentPhase);

          // 7. Update Skip Phase Button
          updateSkipPhaseButton(currentPhase);
          
          // 9. Update Reinforcement Panel
          if (window.updateReinforcementPanel) {
            window.updateReinforcementPanel();
          }

          console.log(
            ` Turn UI Updated - ${currentPhase === 'startup' ? 'Initial Setup' : `Turn ${turnNumber}`}, Player: ${currentPlayer}, Phase: ${currentPhase}`
          );
        } catch (error) {
          console.warn("Error updating turn UI:", error);
        }
      };

      /**
       * Update the phase progress bar showing current phase and completed phases
       * Updated for official Risk rules (startup excluded from progress bar)
       */
      function updatePhaseProgressBar(currentPhase) {
        const progressBar = document.getElementById("phase-progress-bar");
        if (!progressBar) {
          console.warn("Phase progress bar element not found");
          return;
        }

        // Official Risk phases (excluding one-time startup from progress bar)
        const phases = ["reinforcement", "attack", "fortification"];
        const phaseNames = ["Reinforce", "Attack", "Fortify"];
        const phaseDescriptions = {
          startup: "Click on territories to deploy armies in bulk. Click your territories to add multiple armies at once.",
          reinforcement: "Deploy reinforcement armies to your territories",
          attack: "Attack enemy territories to expand your empire",
          fortification: "Move armies between your connected territories"
        };

        // Clear existing content
        progressBar.innerHTML = "";

        // If in startup phase, show special message
        if (currentPhase === 'startup') {
          const startupSegment = document.createElement("div");
          startupSegment.className = "phase-segment active";
          startupSegment.style.cssText = "flex: 1; text-align: center;";
          startupSegment.innerHTML = `
            <span class="phase-name">Initial Army Deployment</span>
          `;
          startupSegment.title = "Click on unclaimed territories to claim them, or click your territories to deploy armies in bulk";
          progressBar.appendChild(startupSegment);
          console.log(` Phase Progress Updated: STARTUP (Bulk Army Deployment)`);
          return;
        }

        // Create phase segments for normal turn rotation
        phases.forEach((phase, index) => {
          const segment = document.createElement("div");
          segment.className = "phase-segment";
          segment.title = `${phaseNames[index]}: ${phaseDescriptions[phase]}`;
          segment.setAttribute("data-phase", phase);

          // Determine phase state
          const currentIndex = phases.indexOf(currentPhase);
          const phaseIndex = phases.indexOf(phase);
          
          if (phase === currentPhase) {
            segment.classList.add("active");
          } else if (phaseIndex < currentIndex) {
            segment.classList.add("completed");
          } else {
            segment.classList.add("upcoming");
          }

          // Set content without emoji
          segment.innerHTML = `
            <span class="phase-name">${phaseNames[index]}</span>
          `;

          // Add click handler for phase information
          segment.addEventListener("click", () => {
            showPhaseInfo(phase, phaseNames[index], phaseDescriptions[phase]);
          });

          progressBar.appendChild(segment);
        });

        console.log(` Phase Progress Updated: ${currentPhase.toUpperCase()} (Official Risk Rules)`);
      }

      /**
       * Show detailed phase information when clicking on a phase segment
       */
      function showPhaseInfo(phase, phaseName, description) {
        const currentPhase = window.gameState?.phase;
        const isCurrentPhase = phase === currentPhase;
        const phases = ["reinforce", "attack", "fortify"];
        const phaseIndex = phases.indexOf(phase);
        const currentIndex = phases.indexOf(currentPhase);
        
        let statusMessage = "";
        if (isCurrentPhase) {
          statusMessage = " Currently Active";
        } else if (phaseIndex < currentIndex) {
          statusMessage = " Completed";
        } else {
          statusMessage = " Upcoming";
        }

        // Show temporary tooltip or console message
        console.log(` Phase Info: ${phaseName} - ${statusMessage}\n${description}`);
        
        // You could extend this to show a modal or tooltip if desired
        const tooltip = document.createElement("div");
        tooltip.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border: 2px solid #667eea;
          border-radius: 8px;
          padding: 15px;
          box-shadow: 0 4px 15px rgba(0,0,0,0.2);
          z-index: 1000;
          max-width: 300px;
          text-align: center;
        `;
        
        tooltip.innerHTML = `
          <h4 style="margin:0 0 10px 0; color: #667eea;">${phaseName}</h4>
          <p style="margin:5px 0; color: #666;">${statusMessage}</p>
          <p style="margin:10px 0; font-size: 0.9em;">${description}</p>
          <button onclick="this.parentElement.remove()" style="
            background: #667eea; 
            color: white; 
            border: none; 
            padding: 5px 15px; 
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
          ">Close</button>
        `;
        
        document.body.appendChild(tooltip);
        setTimeout(() => {
          if (tooltip.parentElement) tooltip.remove();
        }, 5000);
      }

      /**
       * Update players turn order list
       */
      function updatePlayersTurnOrder(players, currentPlayer) {
        const playersList = document.getElementById("players-list-order");
        if (!playersList) return;

        playersList.innerHTML = "";

        players.forEach((player, index) => {
          const item = document.createElement("li");
          item.className = "player-order-item";

          if (player === currentPlayer) {
            item.classList.add("current");
          }

          const indicator = document.createElement("span");
          indicator.className = "player-order-indicator";
          indicator.textContent = index + 1;

          const colorDot = document.createElement("span");
          colorDot.className = "player-color-dot";
          // Try multiple ways to access ColorManager
          const colorManager = window.ColorManager || 
                              (window.riskUI && window.riskUI.colorManager) ||
                              null;
          if (colorManager) {
            const playerColor = colorManager.getPlayerColor(player);
            colorDot.style.backgroundColor = playerColor;
            // Set indicator background to player color ONLY for current player
            if (player === currentPlayer) {
              indicator.style.backgroundColor = playerColor;
              indicator.style.color = "white"; // Ensure text is visible
            }
          }

          const nameSpan = document.createElement("span");
          nameSpan.textContent = player;

          item.appendChild(indicator);
          item.appendChild(nameSpan);
          item.appendChild(colorDot);

          playersList.appendChild(item);
        });
      }

      /**
       * Update End Turn button text and state
       */
      function updateEndTurnButton(currentPhase) {
        const endTurnBtn = document.getElementById("end-turn-enhanced");
        if (!endTurnBtn) return;

        const phaseInfo = {
          reinforce: {
            text: " End Reinforce Phase",
            class: "phase-reinforce",
          },
          attack: { text: " End Attack Phase", class: "phase-attack" },
          fortify: { text: " End Fortify Phase", class: "phase-fortify" },
        };

        const info = phaseInfo[currentPhase] || {
          text: "Next Phase",
          class: "phase-deploy",
        };

        endTurnBtn.textContent = info.text;
        endTurnBtn.className = `end-turn-button-enhanced ${info.class}`;

        // Determine if button should be enabled based on phase requirements
        // This will be customized based on actual game logic
        const isDeploymentComplete = checkPhaseCompletion(currentPhase);
        endTurnBtn.disabled = !isDeploymentComplete;
      }

      /**
       * Update Skip Phase button visibility
       */
      function updateSkipPhaseButton(phase) {
        const skipBtn = document.getElementById("skip-phase-button");
        if (!skipBtn) return;

        // Attack and Fortify are optional phases
        const canSkip = phase === "attack" || phase === "fortify";
        skipBtn.style.display = canSkip ? "block" : "none";
      }

      /**
       * Check if current phase requirements are met
       */
      function checkPhaseCompletion(phase) {
        if (!window.gameState) return false;

        // For now, simple check - armies deployed = 0
        // This can be expanded with more sophisticated logic
        const currentPlayer = window.gameState.getCurrentPlayer();
        const remainingArmies =
          window.gameState.remainingArmies[currentPlayer] || 0;

        if (phase === "reinforce") {
          // Reinforce complete when all armies are deployed
          return remainingArmies === 0;
        }

        // Attack and Fortify phases don't have strict completion requirements
        // They can always be skipped or ended
        return true;
      }

      /**
       * Handle End Turn button click
       */
      window.handleEndTurn = function () {
        console.log(" End Turn/Phase clicked");
        try {
          if (!window.phaseSynchronizer || !window.turnManager) {
            console.error("Phase or Turn manager not available");
            return;
          }

          const currentPhase = window.gameState.phase;
          const currentPlayer = window.gameState.getCurrentPlayer();

          // Validate phase completion for mandatory phases
          if (currentPhase === 'startup' || currentPhase === 'reinforcement') {
            const remainingArmies =
              window.gameState.remainingArmies[currentPlayer] || 0;
            if (remainingArmies > 0) {
              showPhaseCompletionNotice(
                ` You must deploy all ${remainingArmies} remaining armies before advancing`,
                "required"
              );
              return;
            }
          }

          // Use TurnManager to advance phase (it handles player cycling)
          const success = window.turnManager.advancePhase();

          if (success) {
            const newPhase = window.gameState.phase;
            const newPlayer = window.gameState.getCurrentPlayer();
            
            // Check if player changed (turn completed)
            const playerChanged = newPlayer !== currentPlayer;
            
            if (playerChanged) {
              showPhaseCompletionNotice(
                ` ${currentPlayer}'s turn complete! Now ${newPlayer}'s turn - ${newPhase} phase`,
                "success"
              );
            } else {
              showPhaseCompletionNotice(
                ` Progressed to ${newPhase} phase`,
                "success"
              );
            }

            // Update UI
            setTimeout(() => {
              window.updateTurnManagementUI();
              // Update dashboard immediately on phase/turn change
              if (window.updateDashboardData) {
                window.updateDashboardData();
              }
            }, 100);
          } else {
            console.warn("Phase advancement failed");
            showPhaseCompletionNotice(
              "Cannot advance phase yet",
              "required"
            );
          }
        } catch (error) {
          console.error("Error ending turn/phase:", error);
          showPhaseCompletionNotice(
            "Error: " + error.message,
            "required"
          );
        }
      };

      /**
       * Handle Skip Phase button click
       */
      window.handleSkipPhase = function () {
        console.log(" Skip Phase clicked");
        try {
          if (!window.phaseSynchronizer) {
            console.error("Phase manager not available");
            return;
          }

          const currentPhase = window.gameState.phase;

          // Can only skip attack or fortify
          if (currentPhase !== "attack" && currentPhase !== "fortify") {
            showPhaseCompletionNotice("Cannot skip this phase", "required");
            return;
          }

          // Advance phase (skips the current optional phase)
          const result = window.phaseSynchronizer.advanceToNextPhase();

          if (result.success) {
            showPhaseCompletionNotice(
              ` Skipped ${currentPhase}, advancing to ${result.newPhase}`,
              "success"
            );

            setTimeout(() => {
              window.updateTurnManagementUI();
            }, 500);
          }
        } catch (error) {
          console.error("Error skipping phase:", error);
        }
      };

      /**
       * Show temporary completion notice
       */
      function showPhaseCompletionNotice(message, type = "info") {
        const notice = document.getElementById("phase-completion-notice");
        if (!notice) return;

        notice.textContent = message;
        notice.className = `phase-completion-notice show ${type}`;

        // Auto-hide after 4 seconds
        setTimeout(() => {
          notice.classList.remove("show");
        }, 4000);
      }

      /**
       * Initialize turn management on game start
       */
      window.initializeTurnManagement = function () {
        console.log(" Initializing Turn Management UI");
        window.updateTurnManagementUI();

        // Listen for phase changes
        if (
          window.gameState &&
          typeof window.gameState.addEventListener === "function"
        ) {
          window.gameState.addEventListener("phaseChanged", () => {
            window.updateTurnManagementUI();
          });
        }
      };

      /**
       * Initialize Phase Progress Panel with keyboard shortcuts and enhancements
       */
      window.initializePhaseProgressPanel = function () {
        console.log(" Initializing Phase Progress Panel enhancements...");

        // Add keyboard shortcuts for phase navigation
        document.addEventListener("keydown", function (event) {
          // Prevent shortcuts if user is typing in an input field
          if (
            event.target.tagName === "INPUT" ||
            event.target.tagName === "TEXTAREA" ||
            event.target.isContentEditable
          ) {
            return;
          }

          // Shift + Space = Advance Phase (same as End Turn button)
          if (event.shiftKey && event.code === "Space") {
            event.preventDefault();
            const endTurnBtn = document.getElementById("end-turn");
            if (endTurnBtn && !endTurnBtn.disabled) {
              endTurnBtn.click();
              console.log(" Keyboard shortcut: Phase advanced (Shift+Space)");
            }
          }

          // Shift + S = Skip Phase (if available)
          if (event.shiftKey && event.code === "KeyS") {
            event.preventDefault();
            const skipPhaseBtn = document.getElementById("skip-phase-btn");
            if (skipPhaseBtn && skipPhaseBtn.style.display !== "none") {
              skipPhaseBtn.click();
              console.log(" Keyboard shortcut: Phase skipped (Shift+S)");
            }
          }

          // Shift + P = Show current phase info
          if (event.shiftKey && event.code === "KeyP") {
            event.preventDefault();
            if (window.gameState) {
              const phase = window.gameState.phase;
              const phaseSegment = document.querySelector(
                `.phase-segment[data-phase="${phase}"]`
              );
              if (phaseSegment) {
                phaseSegment.click();
                console.log(" Keyboard shortcut: Phase info shown (Shift+P)");
              }
            }
          }
        });

        // Add visual feedback when hovering over phase segments
        const progressPanel = document.getElementById("phase-progress-panel");
        if (progressPanel) {
          progressPanel.setAttribute(
            "title",
            "Track your progress through Reinforce, Attack, and Fortify phases. Click on phases for details. Keyboard shortcuts: Shift+Space (advance), Shift+S (skip), Shift+P (info)"
          );
        }

        // Log keyboard shortcuts to console
        console.log(" Phase Progress Panel Keyboard Shortcuts:");
        console.log("  - Shift + Space: Advance to next phase");
        console.log("  - Shift + S: Skip current phase (if available)");
        console.log("  - Shift + P: Show current phase information");
        
        // Initial update of the phase progress panel
        if (window.gameState) {
          updatePhaseProgressBar(window.gameState.phase);
          console.log(" Phase Progress Panel initialized successfully");
        }
      };

      // Function to load scripts in sequence
      function loadScript(src) {
        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = src;
          script.onload = () => resolve();
          script.onerror = () => reject(new Error(`Failed to load ${src}`));
          document.head.appendChild(script);
        });
      }

      // Initialize game once everything is loaded
      document.addEventListener("DOMContentLoaded", () => {
        let playerCount = 0;
        let players = [];

        // First, try to get player data from sessionStorage (from index.html)
        const storedPlayers = sessionStorage.getItem("riskPlayers");
        const storedColors = sessionStorage.getItem("riskPlayerColors");
        const storedPlayerCount = sessionStorage.getItem("numPlayers");

        if (storedPlayers && storedPlayerCount) {
          // Use sessionStorage data
          const playerNames = JSON.parse(storedPlayers);
          const playerColors = storedColors ? JSON.parse(storedColors) : [];
          playerCount = parseInt(storedPlayerCount);

          // GameState expects separate arrays for names and colors
          players = playerNames; // Array of player names (strings)
          window.playerColors = playerColors; // Store colors separately for GameState constructor
        } else {
          // Fall back to URL parameters
          const params = new URLSearchParams(window.location.search);
          playerCount = parseInt(params.get("playerCount"));

          // Collect player data from URL parameters
          if (!isNaN(playerCount) && playerCount >= 2) {
            const playerNames = [];
            const playerColors = [];
            for (let i = 1; i <= playerCount; i++) {
              const name = params.get(`player${i}`);
              const color = decodeURIComponent(params.get(`color${i}`));
              playerNames.push(name);
              playerColors.push(color);
            }
            players = playerNames;
            window.playerColors = playerColors;
          }
        }

        // Validate playerCount
        if (isNaN(playerCount) || playerCount < 2) {
          document.querySelector(".map-container").innerHTML = `
                    <div style="color: red; padding: 20px;">
                        Error: Invalid or missing player count in URL.<br>
                        Please start the game with at least 2 players.
                    </div>
                `;
          return;
        }

        // Load all required scripts in sequence
        loadScript("js/mapData.js")
          .then(() => loadScript("js/territory-paths.js"))
          .then(() => loadScript("js/ColorManager.js"))
          .then(() => loadScript("js/ArmyCountManager.js")) // Load ArmyCountManager after ColorManager
          .then(() => loadScript("js/EnhancedTooltip.js"))
          .then(() => loadScript("js/DiceRoller.js")) // CombatValidator - must load before CombatUI
          .then(() => loadScript("js/DirectCombat.js"))
          .then(() => loadScript("js/attackLogic.js"))
          .then(() => loadScript("js/ReinforcementManager.js"))
          .then(() => loadScript("js/FortificationManager.js"))
          .then(() => loadScript("js/GameState.js"))
          .then(() => loadScript("js/GameStateManager.js"))
          .then(() => loadScript("js/ValidationManager.js"))
          .then(() => loadScript("js/CombatSystem.js"))
          .then(() => loadScript("js/CombatAnimations.js"))
          .then(() => loadScript("js/CombatDebugger.js")) // Load debugger before CombatUI
          .then(() => loadScript("js/CombatManager.js")) // Load CombatManager orchestration layer
          .then(() => loadScript("js/CombatUI.js"))
          .then(() => loadScript("js/CombatEnhancements.js"))
          .then(() => loadScript("js/CombatEnhancedIntegration.js"))
          .then(() => loadScript("js/CombatTester.js"))
          .then(() => loadScript("js/PhaseManager.js"))
          .then(() => loadScript("js/PhaseSynchronizer.js"))
          .then(() => loadScript("js/PhaseDebugger.js"))
          .then(() => loadScript("js/TurnManager.js"))
          .then(() => loadScript("js/RiskUI.js"))
          .then(() => loadScript("js/RiskUI.AttackExtension.js"))
          .then(() => loadScript("js/CombatIntegration.js"))
          .then(() => loadScript("js/RiskMap.js"))
          .then(() => loadScript("js/MapCalibrationPresets.js"))
          .then(() => loadScript("js/MapCalibration.js"))
          .then(() => loadScript("js/RiskGame.js"))
          .then(() => loadScript("js/AttackManager.js"))
          .then(() => loadScript("js/AttackManager.integration.js"))
          .then(() => loadScript("js/AttackPathVisualizer.js"))
          .then(() => loadScript("js/EnhancedAttackUI.js"))
          .then(() => loadScript("js/EnhancedAttackUI.integration.js"))
          .then(() => loadScript("js/StatisticsManager.js"))
          .then(() => {
            // Verify required data is loaded
            if (
              typeof mapData === "undefined" ||
              typeof territoryPaths === "undefined"
            ) {
              throw new Error("Required game data not loaded");
            }

            // COMBAT UI CLASS VERIFICATION - Moved here to run after all scripts loaded
            console.log("\n Verifying CombatUI Class...");
            if (typeof CombatUI !== 'undefined') {
              const methods = Object.getOwnPropertyNames(CombatUI.prototype);
              const hasReset = methods.includes("reset");
              const hasResetAll = methods.includes("resetAll");
              const hasResetAttack = methods.includes("resetAttack");
              const hasResetAttackUI = methods.includes("resetAttackUI");

              console.log(" CombatUI Reset Methods Check:");
              console.log(
                `${hasReset ? "" : ""} reset() method: ${
                  hasReset ? "available" : "MISSING"
                }`
              );
              console.log(
                `${hasResetAll ? "" : ""} resetAll() method: ${
                  hasResetAll ? "available" : "MISSING"
                }`
              );
              console.log(
                `${hasResetAttack ? "" : ""} resetAttack() method: ${
                  hasResetAttack ? "available" : "MISSING"
                }`
              );
              console.log(
                `${hasResetAttackUI ? "" : ""} resetAttackUI() method: ${
                  hasResetAttackUI ? "available" : "MISSING"
                }`
              );

              if (hasReset && hasResetAll) {
                console.log(" All critical CombatUI reset methods available!");
              } else {
                console.error(
                  " WARNING: Some CombatUI reset methods are missing!"
                );
              }
              console.log("");
            } else {
              console.warn(" CombatUI class not loaded yet - will retry in 1 second");
              setTimeout(() => {
                if (typeof CombatUI !== 'undefined') {
                  console.log(" CombatUI class loaded successfully on retry");
                } else {
                  console.error(" CombatUI class failed to load");
                }
              }, 1000);
            }

            // Log army count information
            console.log("\nRisk Game - Official Army Count Rules:");
            console.log("2 players: 40 armies each");
            console.log("3 players: 35 armies each");
            console.log("4 players: 30 armies each");
            console.log("5 players: 25 armies each");
            console.log("6 players: 20 armies each");

            // Pre-initialize attack modal elements
            function ensureAttackModalElements() {
              const attackModal = document.getElementById("attack-modal");
              if (!attackModal) {
                console.error(
                  " Cannot pre-initialize: Attack modal not found"
                );
                return;
              }

              // Find or create critical elements
              const modalContent = attackModal.querySelector(".modal-content");
              if (!modalContent) return;

              // Find or create attack-selection container
              let attackSelection = attackModal.querySelector(
                "#attack-modal-selection"
              );
              if (!attackSelection) {
                attackSelection = document.createElement("div");
                attackSelection.id = "attack-modal-selection";
                attackSelection.className = "attack-selection";
                modalContent.appendChild(attackSelection);
              }

              // Ensure attack territory container exists
              let attackTerritory =
                attackSelection.querySelector(".attack-territory");
              if (!attackTerritory) {
                attackTerritory = document.createElement("div");
                attackTerritory.className = "attack-territory";
                attackSelection.appendChild(attackTerritory);

                const label = document.createElement("div");
                label.className = "territory-label";
                label.textContent = " Attacking From";
                attackTerritory.appendChild(label);

                const separator = document.createElement("div");
                separator.className = "attack-vs";
                separator.textContent = "VS";
                attackSelection.appendChild(separator);
              }

              // Ensure defend territory container exists
              let defendTerritory =
                attackSelection.querySelector(".defend-territory");
              if (!defendTerritory) {
                defendTerritory = document.createElement("div");
                defendTerritory.className = "defend-territory";
                attackSelection.appendChild(defendTerritory);

                const label = document.createElement("div");
                label.className = "territory-label";
                label.textContent = " Defending";
                defendTerritory.appendChild(label);
              }

              // Create critical elements if missing
              const criticalElements = [
                {
                  id: "attack-modal-attacking-name",
                  parent: attackTerritory,
                  className: "territory-name",
                  text: "-",
                },
                {
                  id: "attack-modal-attacking-armies",
                  parent: attackTerritory,
                  className: "territory-armies",
                  text: "0 armies",
                },
                {
                  id: "attack-modal-defending-name",
                  parent: defendTerritory,
                  className: "territory-name",
                  text: "Select target",
                },
                {
                  id: "attack-modal-defending-armies",
                  parent: defendTerritory,
                  className: "territory-armies",
                  text: "0 armies",
                },
              ];

              criticalElements.forEach((el) => {
                if (!document.getElementById(el.id)) {
                  const newElement = document.createElement("div");
                  newElement.id = el.id;
                  newElement.className = el.className;
                  newElement.textContent = el.text;
                  el.parent.appendChild(newElement);
                  console.log(` Pre-initialized element: ${el.id}`);
                }
              });

              console.log(" Attack modal elements pre-initialized");
            }

            // Pre-initialize critical elements
            ensureAttackModalElements();

            // Initialize game components in the correct order
            const riskUI = new RiskUI();
            riskUI.initGame(players, window.playerColors || []);

            // Make riskUI globally available before initializing Combat System
            window.riskUI = riskUI;
            
            // Initialize StatisticsManager
            if (typeof StatisticsManager !== 'undefined') {
              window.statsManager = new StatisticsManager(riskUI.gameState);
              console.log(' StatisticsManager initialized and available globally');
            }
            
            // Expose ColorManager globally for easy access (both cases for compatibility)
            window.colorManager = riskUI.colorManager;
            window.ColorManager = riskUI.colorManager;
            
            // Update turn header and reinforcement panel colors immediately
            if (window.updateTurnHeaderPanelColor) {
              window.updateTurnHeaderPanelColor();
            }
            if (window.updateReinforcementPanel) {
              window.updateReinforcementPanel();
            }
            
            // Initialize opacity integration system after RiskUI and components are ready
            setTimeout(() => {
              if (typeof setupOpacityIntegration === 'function') {
                setupOpacityIntegration();
              }
            }, 50);

            // Initialize Combat System after riskUI is available
            setTimeout(() => {
              // Double-check critical elements are ready
              ensureAttackModalElements();

              const combatInitialized = initializeCombatSystem();
              if (!combatInitialized) {
                console.error("Failed to initialize combat system");
              } else {
                console.log(" Combat System initialized successfully");

                // Ensure combatUI is available globally after a short delay for UI creation
                setTimeout(() => {
                  if (window.combatUI) {
                    console.log(" CombatUI globally available");
                  } else {
                    console.warn(" CombatUI not globally available yet");
                  }
                }, 1200); // Allow time for CombatUI initialization
              }

              // Initialize Direct Combat system with additional delay to ensure DirectCombat.js is loaded
              setTimeout(() => {
                if (
                  window.initializeAttackSystem &&
                  !window.directCombatInitialized
                ) {
                  window.directCombatInitialized = true;
                  window.initializeAttackSystem();
                }
              }, 500); // Additional delay for DirectCombat initialization

              // Initialize PhaseDebugger after all managers are ready
              if (
                window.PhaseDebugger &&
                window.riskUI?.gameState &&
                window.riskUI?.turnManager &&
                window.riskUI?.phaseManager &&
                window.riskUI?.phaseSynchronizer
              ) {
                try {
                  window.gameDebugger = new PhaseDebugger(
                    window.riskUI.gameState,
                    window.riskUI.turnManager,
                    window.riskUI.phaseManager,
                    window.riskUI.phaseSynchronizer
                  );
                  console.log(" PhaseDebugger instantiated successfully");
                } catch (error) {
                  console.error("Error instantiating PhaseDebugger:", error);
                }
              }

              // PHASE MANAGEMENT SYSTEM VERIFICATION
              setTimeout(() => {
                console.log("\n PHASE MANAGEMENT SYSTEM STATUS:");
                console.log("================================");

                // Check GameState
                if (window.riskUI?.gameState) {
                  console.log(
                    ` GameState: Phase=${window.riskUI.gameState.phase}, Turn=${window.riskUI.gameState.turnNumber}`
                  );
                } else {
                  console.warn(" GameState not accessible");
                }

                // Check TurnManager
                if (window.riskUI?.turnManager) {
                  console.log(
                    ` TurnManager: Phase=${window.riskUI.turnManager.currentPhase}, Turn=${window.riskUI.turnManager.turnNumber}`
                  );
                } else {
                  console.warn(" TurnManager not accessible");
                }

                // Check PhaseManager
                if (window.riskUI?.phaseManager) {
                  console.log(
                    ` PhaseManager: Phase=${window.riskUI.phaseManager.currentPhase}`
                  );
                } else {
                  console.warn(" PhaseManager not accessible");
                }

                // Check PhaseSynchronizer
                if (window.riskUI?.phaseSynchronizer) {
                  console.log(` PhaseSynchronizer: Connected and ready`);
                  console.log(
                    `   - Phase history entries: ${window.riskUI.phaseSynchronizer.phaseHistory.length}`
                  );
                  console.log(
                    `   - Listeners registered: ${window.riskUI.phaseSynchronizer.listeners.length}`
                  );
                } else {
                  console.warn(" PhaseSynchronizer not accessible");
                }

                // Check PhaseDebugger
                if (window.gameDebugger) {
                  console.log(
                    ` PhaseDebugger: Available as window.gameDebugger`
                  );
                } else {
                  console.warn(" PhaseDebugger not available");
                }

                console.log("================================\n");

                // PHASE MANAGEMENT SYSTEM - PHASE CHANGE LISTENERS (Step 3)
                if (window.riskUI?.phaseSynchronizer) {
                  console.log(" Setting up phase change listeners...");

                  window.riskUI.phaseSynchronizer.onPhaseChange(
                    (newPhase, oldPhase) => {
                      console.log(
                        ` Phase changed: ${oldPhase}  ${newPhase}`
                      );

                      // Route to phase-specific handlers
                      switch (newPhase) {
                        case "deploy":
                          console.log(
                            " Deploy phase: Enable troop placement"
                          );
                          if (window.riskUI?.updatePhaseDisplay) {
                            window.riskUI.updatePhaseDisplay("deploy");
                          }
                          break;

                        case "attack":
                          console.log(" Attack phase: Enable combat");
                          if (window.riskUI?.updatePhaseDisplay) {
                            window.riskUI.updatePhaseDisplay("attack");
                          }
                          if (window.combatUI?.onAttackPhaseStart) {
                            window.combatUI.onAttackPhaseStart();
                          }
                          break;

                        case "fortify":
                          console.log(" Fortify phase: Enable fortification");
                          if (window.riskUI?.updatePhaseDisplay) {
                            window.riskUI.updatePhaseDisplay("fortify");
                          }
                          break;

                        case "reinforce":
                          console.log(
                            " Reinforce phase: Calculate and distribute armies"
                          );
                          if (window.riskUI?.updatePhaseDisplay) {
                            window.riskUI.updatePhaseDisplay("reinforce");
                          }
                          break;

                        default:
                          console.log(` Phase: ${newPhase}`);
                      }

                      // Update button states
                      if (window.riskUI?.updateButtonStates) {
                        window.riskUI.updateButtonStates();
                      }
                    }
                  );

                  console.log(" Phase change listeners registered");
                }
              }, 1500);
            }, 100);

            // Distribute territories randomly among players
            riskUI.gameState.assignTerritoriesRandomly();

            // Update PhaseManager after territory distribution
            riskUI.phaseManager.syncWithGameState();
            riskUI.updatePlayerStats();

            const riskMap = new RiskMap(riskUI);
            const riskGame = new RiskGame(riskUI, riskMap);

            // Store references globally if needed
            window.gameState = riskUI.gameState;
            window.riskUI = riskUI;
            window.riskMap = riskMap;
            window.riskGame = riskGame;

            // Initialize army count manager after RiskMap has created territories
            if (window.ArmyCountManager) {
              try {
                riskUI.armyCountManager = new ArmyCountManager(riskUI.colorManager);
                console.log(' ArmyCountManager integrated with RiskUI after territories created');
                
                // Setup army count map integration for zoom/pan compatibility
                riskUI.setupArmyCountMapIntegration();
                
                // Now initialize all territory visuals after everything is ready
                riskUI.initializeVisualsAfterMap();
              } catch (error) {
                console.error(' Failed to initialize ArmyCountManager:', error);
              }
            }

            // Store PhaseSynchronizer reference for turn management
            window.phaseSynchronizer =
              riskUI.phaseSynchronizer || window.phaseSynchronizer;
            window.turnManager = riskUI.turnManager;

            // Initialize Turn Management UI
            console.log(" Initializing Turn Management UI...");
            window.initializeTurnManagement();
            
            // Initialize Phase Progress Panel enhancements
            console.log(" Initializing Phase Progress Panel...");
            window.initializePhaseProgressPanel();
            
            // Ensure turn header panel color is updated after full initialization
            setTimeout(() => {
              const colorManager = window.ColorManager || 
                                  (window.riskUI && window.riskUI.colorManager) ||
                                  null;
              if (colorManager && window.gameState) {
                console.log(" Final turn header panel color update...");
                // Try dedicated function first, fallback to full UI update
                if (!window.updateTurnHeaderPanelColor()) {
                  window.updateTurnManagementUI();
                }
                
                // Apply initial territory highlighting after map is fully loaded
                if (window.highlightPlayerTerritories) {
                  console.log(" Applying initial territory highlighting...");
                  window.highlightPlayerTerritories();
                }
              } else {
                console.warn(" ColorManager or GameState not ready for final color update");
              }
            }, 1500); // Give extra time for all components to initialize

            // Assign continent information to all territories for tooltips
            setTimeout(() => {
              if (window.gameState && window.gameState.territories) {
                console.log(' Assigning continent information to territories...');
                
                // Complete mapping of all 42 territories to their continents
                // Using exact territory names from mapData.js (with spaces)
                const continentMapping = {
                  'north-america': ['alaska', 'northwest territory', 'greenland', 'alberta', 
                                   'ontario', 'quebec', 'western united states', 
                                   'eastern united states', 'central america'],
                  'south-america': ['venezuela', 'peru', 'brazil', 'argentina'],
                  'europe': ['iceland', 'great britain', 'scandinavia', 'ukraine', 
                            'northern europe', 'western europe', 'southern europe'],
                  'africa': ['north africa', 'egypt', 'east africa', 'congo', 
                            'south africa', 'madagascar'],
                  'asia': ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 
                          'afghanistan', 'china', 'mongolia', 'japan', 'middle east', 
                          'india', 'siam'],
                  'australia': ['indonesia', 'new guinea', 'western australia', 'eastern australia']
                };

                // Assign continents to all territories
                let assigned = 0;
                let missing = 0;
                Object.entries(continentMapping).forEach(([continent, territories]) => {
                  territories.forEach(territoryId => {
                    if (window.gameState.territories[territoryId]) {
                      window.gameState.territories[territoryId].continent = continent;
                      assigned++;
                    } else {
                      console.warn(` Territory ${territoryId} not found in game state`);
                      missing++;
                    }
                  });
                });

                // Verify all territories have continent assignments
                const totalTerritories = Object.keys(window.gameState.territories).length;
                console.log(` Assigned continents to ${assigned}/${totalTerritories} territories`);
                
                if (missing > 0) {
                  console.warn(` ${missing} territories not found in continent mapping`);
                }

                // Log any territories without continent assignment
                Object.entries(window.gameState.territories).forEach(([id, territory]) => {
                  if (!territory.continent) {
                    console.warn(` Territory ${id} missing continent assignment`);
                  }
                });

                console.log(' Territory tooltip data ready - all continents assigned');
              } else {
                console.error(' Cannot assign continents - gameState.territories not available');
              }
            }, 2000); // Run after game is fully initialized

            // ========================================================================
            // NAVIGATION PREVENTION SYSTEM
            // Prevents unwanted page navigation during gameplay (fixes about:blank issue)
            // ========================================================================
            (function preventUnwantedNavigation() {
              console.log(' Navigation prevention system initialized');
              
              // 1. Prevent all form submissions
              document.addEventListener('submit', function(e) {
                console.warn(' Form submission blocked:', e.target);
                e.preventDefault();
                return false;
              }, true);
              
              // 2. Intercept all link clicks
              document.addEventListener('click', function(e) {
                let target = e.target;
                
                // Find if click is on a link or inside one
                while (target && target !== document) {
                  if (target.tagName === 'A') {
                    const href = target.getAttribute('href');
                    const targetAttr = target.getAttribute('target');
                    
                    console.log(' Link clicked:', {
                      href: href,
                      target: targetAttr,
                      text: target.textContent.trim().substring(0, 30)
                    });
                    
                    // Allow external links with target="_blank" (like dashboard button)
                    if (targetAttr === '_blank' && href && !href.startsWith('#')) {
                      console.log(' Allowing external link in new tab:', href);
                      return; // Allow this navigation
                    }
                    
                    // Block empty or placeholder links
                    if (!href || href === '#' || href === '' || href === 'javascript:void(0)' || href.includes('about:blank')) {
                      console.warn(' Blocked navigation to invalid link:', href);
                      e.preventDefault();
                      e.stopPropagation();
                      return false;
                    }
                    
                    // Block same-page navigation that might reload
                    if (href && href.includes('game.html')) {
                      console.warn(' Blocked self-navigation to game.html');
                      e.preventDefault();
                      e.stopPropagation();
                      return false;
                    }
                    
                    break;
                  }
                  target = target.parentNode;
                }
              }, true); // Use capture phase to catch events early
              
              // 3. Ensure all buttons have type="button" to prevent form submission
              const fixButtons = function() {
                const buttons = document.querySelectorAll('button:not([type])');
                let fixedCount = 0;
                buttons.forEach(button => {
                  button.setAttribute('type', 'button');
                  fixedCount++;
                });
                if (fixedCount > 0) {
                  console.log(` Fixed ${fixedCount} buttons without type attribute`);
                }
              };
              
              // Fix buttons on load
              fixButtons();
              
              // Fix buttons after delays (in case they're dynamically created)
              setTimeout(fixButtons, 1000);
              setTimeout(fixButtons, 3000);
              
              // 4. Monitor for about:blank navigation attempts
              const originalOpen = window.open;
              window.open = function(...args) {
                console.log(' window.open called with:', args);
                
                if (!args[0] || args[0] === 'about:blank' || args[0] === '') {
                  console.error(' Blocked window.open to about:blank or empty URL');
                  return null;
                }
                
                return originalOpen.apply(this, args);
              };
              
              // 5. Prevent default behavior on SVG elements that might have links
              document.addEventListener('click', function(e) {
                // Check if click is on SVG or territory
                const svgElement = e.target.closest('svg');
                const territory = e.target.closest('.territory');
                
                if (svgElement || territory) {
                  // Check if there's an <a> tag wrapping the SVG/territory
                  const parentLink = e.target.closest('a');
                  if (parentLink && parentLink.tagName === 'A') {
                    const href = parentLink.getAttribute('href');
                    // Only block if it's an invalid link
                    if (!href || href === '#' || href === '' || href.includes('about:blank')) {
                      console.warn(' Prevented navigation from SVG/territory link');
                      e.preventDefault();
                      e.stopPropagation();
                      return false;
                    }
                  }
                }
              }, true);
              
              // 6. Warn on page unload (for debugging)
              window.addEventListener('beforeunload', function(e) {
                console.warn(' Page is attempting to unload!');
                console.trace('Unload trace');
                
                // Uncomment below to prevent accidental navigation during development
                // e.preventDefault();
                // e.returnValue = 'Are you sure you want to leave? Game progress may be lost.';
                // return e.returnValue;
              });
              
              console.log(' Navigation prevention system active');
            })();

          })
          .catch((error) => {
            console.error("Failed to initialize game:", error);
            document.querySelector(".map-container").innerHTML = `
                        <div style="color: red; padding: 20px;">
                            Error loading game data: ${error.message}<br>
                            Please refresh the page.
                        </div>
                    `;
          });

        // Setup Rules Modal functionality
        const rulesBtn = document.getElementById("rules-btn");
        const rulesModal = document.getElementById("rules-modal");
        const closeRules = rulesModal.querySelector(".close");

        if (rulesBtn && rulesModal && closeRules) {
          // Open modal when button is clicked
          rulesBtn.addEventListener("click", () => {
            rulesModal.style.display = "block";
          });

          // Close modal when X is clicked
          closeRules.addEventListener("click", () => {
            rulesModal.style.display = "none";
          });

          // Close modal when clicking outside the content
          window.addEventListener("click", (event) => {
            if (event.target === rulesModal) {
              rulesModal.style.display = "none";
            }
          });
        }

        // PHASE MANAGEMENT DEBUG COMMANDS (Step 4)
        console.log("\n Initializing Phase Management Debug Commands...");
        window.phaseDebug = {
          state: function () {
            console.log("\n PHASE MANAGEMENT STATE:");
            console.log("================================");

            const gs = window.riskUI?.gameState;
            const tm = window.riskUI?.turnManager;
            const pm = window.riskUI?.phaseManager;
            const ps = window.riskUI?.phaseSynchronizer;

            if (gs)
              console.log(
                `GameState:       Phase=${gs.phase}, Turn=${gs.turnNumber}, Player=${gs.currentPlayerIndex}`
              );
            if (tm)
              console.log(
                `TurnManager:     Phase=${tm.currentPhase}, Turn=${tm.turnNumber}`
              );
            if (pm) console.log(`PhaseManager:    Phase=${pm.currentPhase}`);
            if (ps) console.log(`PhaseSynchronizer: Phase=${ps.currentPhase}`);

            console.log("================================\n");
          },

          nextPhase: function () {
            console.log(" Advancing to next phase...");
            if (window.riskUI?.phaseSynchronizer) {
              const result =
                window.riskUI.phaseSynchronizer.advanceToNextPhase();
              if (result.success) {
                console.log(
                  ` Phase advanced: ${result.oldPhase}  ${result.newPhase}`
                );
              } else {
                console.warn(` Cannot advance: ${result.reason}`);
              }
            } else {
              console.error(" PhaseSynchronizer not available");
            }
          },

          skip: function () {
            console.log(" Skipping current phase...");
            if (window.riskUI?.phaseSynchronizer) {
              const result = window.riskUI.phaseSynchronizer.skipPhase();
              if (result.success) {
                console.log(
                  ` Skipped: ${result.oldPhase}  ${result.newPhase}`
                );
              } else {
                console.warn(` Cannot skip: ${result.reason}`);
              }
            } else {
              console.error(" PhaseSynchronizer not available");
            }
          },

          history: function () {
            console.log("\n PHASE TRANSITION HISTORY:");
            console.log("================================");
            if (window.riskUI?.phaseSynchronizer) {
              const history =
                window.riskUI.phaseSynchronizer.getPhaseHistory(10);
              if (history.length === 0) {
                console.log("(No phase transitions yet)");
              } else {
                history.forEach((entry, idx) => {
                  const time = new Date(entry.timestamp).toLocaleTimeString();
                  console.log(
                    `${idx + 1}. ${time}: ${entry.oldPhase}  ${entry.newPhase}`
                  );
                });
              }
            } else {
              console.error(" PhaseSynchronizer not available");
            }
            console.log("================================\n");
          },

          sync: function () {
            console.log("\n SYNCHRONIZATION CHECK:");
            console.log("================================");
            if (window.riskUI?.phaseSynchronizer) {
              const ps = window.riskUI.phaseSynchronizer;
              const gs = window.riskUI?.gameState;
              const tm = window.riskUI?.turnManager;
              const pm = window.riskUI?.phaseManager;

              const states = {
                gameState: gs?.phase,
                turnManager: tm?.currentPhase,
                phaseManager: pm?.currentPhase,
                synchronizer: ps?.currentPhase,
              };

              const allMatch = Object.values(states).every(
                (val) => val === states.gameState
              );

              Object.entries(states).forEach(([key, value]) => {
                const status = value === states.gameState ? "" : "";
                console.log(`${status} ${key}: ${value}`);
              });

              console.log("--------------------------------");
              if (allMatch) {
                console.log(" ALL SYSTEMS SYNCHRONIZED");
              } else {
                console.warn(" SYSTEMS OUT OF SYNC");
              }
            } else {
              console.error(" PhaseSynchronizer not available");
            }
            console.log("================================\n");
          },
        };

        console.log(
          " Phase debug commands ready: phaseDebug.state(), phaseDebug.nextPhase(), phaseDebug.skip(), phaseDebug.history(), phaseDebug.sync()\n"
        );
      });

      // 
      // DASHBOARD DATA BROADCASTING
      // 

      /**
       * Calculate continent bonuses for a player
       */
      window.calculateContinentBonuses = function(playerName) {
        if (!window.gameState || !window.gameState.territories) return 0;
        
        // Use the same continent definitions as mapData.js (with spaces, not hyphens)
        const continents = {
          'North America': { 
            territories: ['alaska', 'northwest territory', 'greenland', 'alberta', 'ontario', 'quebec', 'western united states', 'eastern united states', 'central america'], 
            bonus: 5 
          },
          'South America': { 
            territories: ['venezuela', 'brazil', 'peru', 'argentina'], 
            bonus: 2 
          },
          'Europe': { 
            territories: ['iceland', 'great britain', 'scandinavia', 'northern europe', 'western europe', 'southern europe', 'ukraine'], 
            bonus: 5 
          },
          'Africa': { 
            territories: ['north africa', 'egypt', 'east africa', 'congo', 'south africa', 'madagascar'], 
            bonus: 3 
          },
          'Asia': { 
            territories: ['ural', 'siberia', 'yakutsk', 'kamchatka', 'irkutsk', 'mongolia', 'japan', 'afghanistan', 'china', 'middle east', 'india', 'siam'], 
            bonus: 7 
          },
          'Australia': { 
            territories: ['indonesia', 'new guinea', 'western australia', 'eastern australia'], 
            bonus: 2 
          }
        };
        
        let totalBonus = 0;
        
        for (const [continentName, continentData] of Object.entries(continents)) {
          const ownedTerritories = continentData.territories.filter(territoryId => {
            const territory = window.gameState.territories[territoryId];
            return territory && territory.owner === playerName;
          });
          
          if (ownedTerritories.length === continentData.territories.length) {
            totalBonus += continentData.bonus;
            console.log(` ${playerName} controls ${continentName} - Bonus: +${continentData.bonus}`);
          }
        }
        
        return totalBonus;
      };

      /**
       * Event-driven Dashboard Data Watcher
       * Only saves when actual game state changes occur
       */
      window.GameDataWatcher = {
        lastSnapshot: null,
        isWatching: false,
        saveQueue: new Set(),
        lastSaveTime: 0,
        
        /**
         * Start watching for game state changes
         */
        startWatching() {
          if (this.isWatching) return;
          this.isWatching = true;
          
          // Take initial snapshot
          this.lastSnapshot = this.createSnapshot();
          
          // Watch for territory changes
          this.watchTerritoryChanges();
          
          // Watch for phase/turn changes
          this.watchPhaseChanges();
          
          // Watch for player changes
          this.watchPlayerChanges();
          
          console.log(' Event-driven dashboard watching started');
        },
        
        /**
         * Create a snapshot of current game state for comparison
         */
        createSnapshot() {
          if (!window.gameState) return null;
          
          const territories = {};
          Object.keys(window.gameState.territories).forEach(id => {
            const territory = window.gameState.territories[id];
            territories[id] = {
              armies: territory.armies,
              owner: territory.owner
            };
          });
          
          return {
            territories,
            currentPlayer: window.gameState.getCurrentPlayer(),
            phase: window.gameState.phase,
            turnNumber: window.gameState.turnNumber || 0,
            timestamp: Date.now()
          };
        },
        
        /**
         * Compare snapshots and detect what changed
         */
        detectChanges(oldSnapshot, newSnapshot) {
          if (!oldSnapshot || !newSnapshot) return { hasChanges: true, changes: ['initial'] };
          
          const changes = [];
          
          // Check phase/turn changes
          if (oldSnapshot.phase !== newSnapshot.phase) {
            changes.push('phase');
          }
          
          if (oldSnapshot.currentPlayer !== newSnapshot.currentPlayer) {
            changes.push('player');
          }
          
          if (oldSnapshot.turnNumber !== newSnapshot.turnNumber) {
            changes.push('turn');
          }
          
          // Check territory changes
          const territoryChanges = [];
          Object.keys(newSnapshot.territories).forEach(id => {
            const oldTerritory = oldSnapshot.territories[id];
            const newTerritory = newSnapshot.territories[id];
            
            if (!oldTerritory || 
                oldTerritory.armies !== newTerritory.armies || 
                oldTerritory.owner !== newTerritory.owner) {
              territoryChanges.push(id);
            }
          });
          
          if (territoryChanges.length > 0) {
            changes.push('territories');
          }
          
          return {
            hasChanges: changes.length > 0,
            changes,
            territoryChanges
          };
        },
        
        /**
         * Handle detected changes and update dashboard
         */
        handleChanges(changeInfo) {
          if (!changeInfo.hasChanges) return;
          
          // Throttle saves to prevent spam during rapid changes
          const now = Date.now();
          if (now - this.lastSaveTime < 500) {
            // Queue the save for later if too recent
            this.saveQueue.add('pending');
            return;
          }
          
          console.log(` Game state changed: ${changeInfo.changes.join(', ')}`);
          
          if (changeInfo.territoryChanges?.length > 0) {
            console.log(` Territory changes: ${changeInfo.territoryChanges.slice(0, 5).join(', ')}${changeInfo.territoryChanges.length > 5 ? '...' : ''}`);
          }
          
          // Update dashboard data
          window.updateDashboardDataEnhanced();
          this.lastSaveTime = now;
          this.saveQueue.clear();
          
          // Update snapshot
          this.lastSnapshot = this.createSnapshot();
        },
        
        /**
         * Check for changes and update if needed
         */
        checkAndUpdate() {
          const newSnapshot = this.createSnapshot();
          const changeInfo = this.detectChanges(this.lastSnapshot, newSnapshot);
          
          if (changeInfo.hasChanges) {
            this.handleChanges(changeInfo);
          }
        },
        
        /**
         * Process any queued saves (called periodically)
         */
        processQueue() {
          if (this.saveQueue.size > 0) {
            this.checkAndUpdate();
          }
        },
        
        /**
         * Watch for territory army count and ownership changes
         */
        watchTerritoryChanges() {
          // Hook into ArmyCountManager updates
          if (window.armyCountManager && window.armyCountManager.updateArmyCount) {
            const originalUpdate = window.armyCountManager.updateArmyCount;
            window.armyCountManager.updateArmyCount = (territoryId, forceUpdate) => {
              const result = originalUpdate.call(window.armyCountManager, territoryId, forceUpdate);
              this.checkAndUpdate();
              return result;
            };
            console.log(' Hooked into ArmyCountManager.updateArmyCount');
          }
          
          // Hook into direct territory army changes via Proxy
          this.watchGameStateChanges();
          
          // Listen for custom events that indicate territory changes
          document.addEventListener('territoryChanged', () => {
            this.checkAndUpdate();
          });
          
          document.addEventListener('armyCountChanged', () => {
            this.checkAndUpdate();
          });
        },
        
        /**
         * Watch GameState territory changes using Proxy
         */
        watchGameStateChanges() {
          if (!window.gameState || !window.gameState.territories) return;
          
          // Wrap territory objects in proxies to detect changes
          Object.keys(window.gameState.territories).forEach(territoryId => {
            const territory = window.gameState.territories[territoryId];
            if (territory && typeof territory === 'object' && !territory._isProxied) {
              const self = this;
              window.gameState.territories[territoryId] = new Proxy(territory, {
                set(target, property, value) {
                  const oldValue = target[property];
                  target[property] = value;
                  
                  // Only trigger on armies or owner changes
                  if ((property === 'armies' || property === 'owner') && oldValue !== value) {
                    console.log(` Territory ${territoryId}.${property}: ${oldValue}  ${value}`);
                    setTimeout(() => self.checkAndUpdate(), 10); // Slight delay to batch changes
                  }
                  
                  return true;
                }
              });
              
              // Mark as proxied to avoid double-wrapping
              territory._isProxied = true;
            }
          });
          
          console.log(' Territory change detection enabled via Proxy');
        },
        
        /**
         * Watch for phase changes
         */
        watchPhaseChanges() {
          // Hook into PhaseManager
          if (window.phaseManager) {
            ['setPhase', 'changePhase', 'nextPhase'].forEach(methodName => {
              if (window.phaseManager[methodName]) {
                const originalMethod = window.phaseManager[methodName];
                window.phaseManager[methodName] = (...args) => {
                  const result = originalMethod.apply(window.phaseManager, args);
                  this.checkAndUpdate();
                  return result;
                };
              }
            });
            console.log(' Hooked into PhaseManager phase changes');
          }
          
          // Hook into GameState phase changes
          if (window.gameState) {
            ['setPhase', 'changePhase'].forEach(methodName => {
              if (window.gameState[methodName]) {
                const originalMethod = window.gameState[methodName];
                window.gameState[methodName] = (...args) => {
                  const result = originalMethod.apply(window.gameState, args);
                  this.checkAndUpdate();
                  return result;
                };
              }
            });
          }
          
          // Listen for phase change events
          document.addEventListener('phaseChanged', (event) => {
            console.log(' Phase change event detected:', event.detail);
            this.checkAndUpdate();
          });
          
          // Listen for player change events
          document.addEventListener('playerChanged', (event) => {
            console.log(' Player change event detected:', event.detail);
            this.checkAndUpdate();
          });
        },
        
        /**
         * Watch for player/turn changes
         */
        watchPlayerChanges() {
          if (window.turnManager) {
            ['nextPlayer', 'advancePlayer', 'setCurrentPlayer'].forEach(methodName => {
              if (window.turnManager[methodName]) {
                const originalMethod = window.turnManager[methodName];
                window.turnManager[methodName] = (...args) => {
                  const result = originalMethod.apply(window.turnManager, args);
                  this.checkAndUpdate();
                  return result;
                };
              }
            });
            console.log(' Hooked into TurnManager player changes');
          }
        },
        
        /**
         * Stop watching (for cleanup)
         */
        stopWatching() {
          this.isWatching = false;
          console.log(' Event-driven dashboard watching stopped');
        }
      };

      /**
       * Utility function to manually trigger dashboard updates
       * Can be called from anywhere in the codebase when changes occur
       */
      window.triggerDashboardUpdate = function(source, details = {}) {
        if (window.GameDataWatcher && window.GameDataWatcher.isWatching) {
          console.log(` Manual dashboard update triggered by: ${source}`);
          if (details.territoryId) {
            document.dispatchEvent(new CustomEvent('territoryChanged', {
              detail: { ...details, source }
            }));
          } else {
            // General change - force a check
            setTimeout(() => window.GameDataWatcher.checkAndUpdate(), 50);
          }
        } else {
          // Fallback to direct update
          window.updateDashboardData();
        }
      };

      /**
       * Dashboard Connection Testing
       */
      window.testDashboardConnection = function() {
        console.log(' Testing dashboard connection...');
        
        // Test data creation
        try {
          window.updateDashboardDataEnhanced();
          console.log(' Data creation successful');
        } catch (error) {
          console.error(' Data creation failed:', error);
          return false;
        }
        
        // Test localStorage
        const data = localStorage.getItem('riskGameData');
        if (data) {
          console.log(' Data found in localStorage');
          try {
            const parsed = JSON.parse(data);
            console.log(' Data parsing successful');
            console.log(' Data preview:', {
              timestamp: parsed.timestamp,
              phase: parsed.phase,
              currentPlayer: parsed.currentPlayer,
              players: Object.keys(parsed.players || {}).length,
              territories: Object.keys(parsed.territories || {}).length
            });
          } catch (error) {
            console.error(' Data parsing failed:', error);
            return false;
          }
        } else {
          console.error(' No data in localStorage');
          return false;
        }
        
        // Test dashboard accessibility
        console.log(' Dashboard should be accessible at: Stats/dashboard.html');
        console.log(' If dashboard shows "not connected", refresh the dashboard page');
        
        return true;
      };

      /**
       * Debug function to check dashboard system health
       */
      window.debugDashboard = function() {
        console.log(' Dashboard System Status:');
        console.log('- GameDataWatcher exists:', !!window.GameDataWatcher);
        console.log('- Is watching:', window.GameDataWatcher?.isWatching);
        console.log('- Last snapshot time:', window.GameDataWatcher?.lastSnapshot?.timestamp);
        console.log('- Save queue size:', window.GameDataWatcher?.saveQueue?.size);
        console.log('- Time since last save:', Date.now() - (window.GameDataWatcher?.lastSaveTime || 0), 'ms');
        
        const dashboardData = localStorage.getItem('riskGameData');
        if (dashboardData) {
          const parsed = JSON.parse(dashboardData);
          console.log('- Last update:', new Date(parsed.lastUpdate).toLocaleTimeString());
          console.log('- Current phase:', parsed.phase);
          console.log('- Turn number:', parsed.turnNumber);
          console.log('- Current player:', parsed.currentPlayer);
        } else {
          console.log('- No dashboard data in localStorage');
        }
      };

      /**
       * Enhanced updateDashboardData with change detection
       * This replaces the original time-based approach
       */
      window.updateDashboardDataEnhanced = function() {
        try {
          if (!window.gameState) {
            console.warn(' No game state available for dashboard update');
            return;
          }

          console.log(' Creating dashboard data snapshot...');

          // Get statistics data safely
          let statisticsData = {
            totalBattles: 0,
            totalArmiesDeployed: 0,
            gameStartTime: window.gameStartTime || Date.now(),
            gameDuration: Date.now() - (window.gameStartTime || Date.now())
          };
          
          // Try to get stats from StatisticsManager if available
          if (window.statsManager && typeof window.statsManager.getStatsSummary === 'function') {
            try {
              const statsSummary = window.statsManager.getStatsSummary();
              statisticsData.totalBattles = statsSummary.battles?.length || 0;
              statisticsData.totalArmiesDeployed = statsSummary.gameInfo?.totalDeployments || 0;
              if (statsSummary.gameInfo?.startTime) {
                statisticsData.gameStartTime = statsSummary.gameInfo.startTime;
                statisticsData.gameDuration = statsSummary.gameInfo.duration || 0;
              }
            } catch (error) {
              console.warn(' Could not get stats from StatisticsManager:', error.message);
            }
          }

          // Create dashboard data object with enhanced structure
          const dashboardData = {
            timestamp: Date.now(),
            gameId: `risk-${Date.now()}`,
            phase: window.gameState.phase || 'unknown',
            currentPlayer: window.gameState.getCurrentPlayer() || 'Unknown',
            turnNumber: window.gameState.turnNumber || 0,
            players: {},
            territories: {},
            statistics: statisticsData,
            version: '1.0',
            dataSource: 'event-driven',
            lastUpdate: Date.now() // Keep for backward compatibility
          };

          // Get all players with enhanced data
          const players = window.gameState.players || [];
          console.log(` Processing ${players.length} players...`);
          
          players.forEach((playerName, index) => {
            const playerTerritories = Object.keys(window.gameState.territories).filter(
              id => window.gameState.territories[id].owner === playerName
            );
            
            const totalArmies = playerTerritories.reduce((sum, id) => 
              sum + (window.gameState.territories[id].armies || 0), 0
            );
            
            const continentBonus = window.calculateContinentBonuses ? 
              window.calculateContinentBonuses(playerName) : 0;
            
            // Get player color
            let playerColor = '#666666';
            if (window.colorManager) {
              playerColor = window.colorManager.getPlayerColor(playerName);
            } else if (window.playerColors && window.playerColors[index]) {
              playerColor = window.playerColors[index];
            }
            
            dashboardData.players[playerName] = {
              name: playerName, // Ensure name is included
              territories: playerTerritories.length,
              totalArmies,
              armies: totalArmies, // Alternative name for compatibility
              continentBonus,
              remainingArmies: window.gameState.remainingArmies?.[playerName] || 0,
              color: playerColor,
              isCurrentPlayer: playerName === window.gameState.getCurrentPlayer()
            };
            
            console.log(` Player ${playerName}: ${playerTerritories.length} territories, ${totalArmies} armies`);
          });

          // Territory data with enhanced information
          const territoryCount = Object.keys(window.gameState.territories).length;
          console.log(` Processing ${territoryCount} territories...`);
          
          Object.keys(window.gameState.territories).forEach(id => {
            const territory = window.gameState.territories[id];
            dashboardData.territories[id] = {
              owner: territory.owner,
              armies: territory.armies,
              continent: territory.continent || 'unknown',
              displayName: territory.name || id
            };
          });

          // Save to localStorage with both keys for compatibility
          const dataString = JSON.stringify(dashboardData);
          localStorage.setItem('riskGameData', dataString);
          localStorage.setItem('riskDashboardData', dataString); // Backup key
          
          console.log(' Dashboard data saved successfully:', {
            key: 'riskGameData',
            size: Math.round(dataString.length / 1024) + 'KB',
            players: Object.keys(dashboardData.players).length,
            territories: Object.keys(dashboardData.territories).length,
            phase: dashboardData.phase,
            turn: dashboardData.turnNumber
          });
          
          // Dispatch custom event for dashboard listening
          window.dispatchEvent(new CustomEvent('riskGameDataUpdated', {
            detail: dashboardData
          }));
          
          // Cross-tab message for dashboard using multiple methods
          try {
            // Method 1: PostMessage to specific window
            const dashboardWindow = window.open('', 'riskDashboard');
            if (dashboardWindow && !dashboardWindow.closed) {
              dashboardWindow.postMessage({
                type: 'riskGameUpdate',
                data: dashboardData
              }, '*');
            }
          } catch (e) {
            // Ignore cross-tab messaging errors
          }

          // Method 2: BroadcastChannel (modern browsers, works better than postMessage)
          try {
            if (!window.riskGameChannel) {
              window.riskGameChannel = new BroadcastChannel('risk-game-updates');
            }
            window.riskGameChannel.postMessage({
              type: 'gameStateUpdated',
              data: dashboardData,
              timestamp: Date.now()
            });
            console.log(' BroadcastChannel update sent to dashboard');
          } catch (e) {
            console.warn(' BroadcastChannel not available:', e.message);
          }

          // Method 3: Storage event will fire automatically when localStorage.setItem is called above
          
          // Save StatisticsManager data if available
          if (window.statsManager) {
            window.statsManager.saveStats();
          }
          
          // Historical tracking - save snapshot at end of each turn
          if (dashboardData.phase === 'startup' || 
              (dashboardData.phase === 'reinforcement' && window.gameState.getCurrentPlayer() === window.gameState.players[0])) {
            window.saveHistoricalSnapshot(dashboardData.turnNumber, dashboardData.players);
          }
          
          // Only log if this is a significant change (not spam)
          const lastUpdate = window.lastDashboardUpdate || 0;
          const timeSinceLastUpdate = Date.now() - lastUpdate;
          
          if (timeSinceLastUpdate > 2000) { // Only log every 2+ seconds to reduce spam
            console.log(' Dashboard data updated:', dashboardData.phase, 'Turn', dashboardData.turnNumber);
          }
          
          window.lastDashboardUpdate = Date.now();
        } catch (error) {
          console.error(' Error updating dashboard data:', error);
          console.error('Stack trace:', error.stack);
        }
      };

      /**
       * Original updateDashboardData - kept for backwards compatibility
       * Now redirects to the enhanced version
       */
      window.updateDashboardData = function() {
        return window.updateDashboardDataEnhanced();
      };

      /**
       * Save historical snapshot for tracking player progress over time
       */
      window.saveHistoricalSnapshot = function(turnNumber, playerStats) {
        try {
          // Get existing history
          const historyStr = localStorage.getItem('riskGameHistory');
          const history = historyStr ? JSON.parse(historyStr) : [];
          
          // Check if this turn already exists
          const existingIndex = history.findIndex(h => h.turn === turnNumber);
          
          const snapshot = {
            turn: turnNumber,
            timestamp: Date.now(),
            players: Object.values(playerStats)
          };
          
          if (existingIndex >= 0) {
            history[existingIndex] = snapshot;
          } else {
            history.push(snapshot);
          }
          
          // Keep only last 50 turns
          if (history.length > 50) {
            history.shift();
          }
          
          localStorage.setItem('riskGameHistory', JSON.stringify(history));
          console.log(' Historical snapshot saved for turn', turnNumber);
        } catch (error) {
          console.error(' Error saving historical snapshot:', error);
        }
      };

      /**
       * Clear historical data (for new games)
       */
      window.clearGameHistory = function() {
        localStorage.removeItem('riskGameHistory');
        console.log(' Game history cleared');
      };

      /**
       * Start event-driven dashboard system
       * Updates only when game data actually changes
       */
      window.startDashboardBroadcast = function() {
        // Stop any existing time-based updates
        if (window.dashboardUpdateInterval) {
          clearInterval(window.dashboardUpdateInterval);
          window.dashboardUpdateInterval = null;
          console.log(' Stopped time-based dashboard updates');
        }

        if (window.gameState) {
          // Start event-driven watching
          if (window.GameDataWatcher) {
            window.GameDataWatcher.startWatching();
            
            // Process any queued saves periodically (every 10 seconds as backup)
            window.dashboardQueueInterval = setInterval(() => {
              if (window.GameDataWatcher.isWatching) {
                window.GameDataWatcher.processQueue();
              }
            }, 10000);
            
            // Initial update
            window.updateDashboardData();
            
            console.log(' Event-driven dashboard system started');
            console.log(' Dashboard will now update only when game data changes');
            console.log(' Dashboard available at: Stats/dashboard.html');
            console.log(' Test connection: Open Stats/dashboard.html in a new tab');
            console.log(' Manual update: window.updateDashboardData()');
            console.log(' Force check: window.GameDataWatcher.checkAndUpdate()');
          } else {
            console.error(' GameDataWatcher not available, falling back to time-based updates');
            // Fallback to time-based updates if event system fails
            window.dashboardUpdateInterval = setInterval(() => {
              window.updateDashboardData();
            }, 5000); // Reduced frequency as fallback
          }
        } else {
          console.warn(' Dashboard: gameState not ready, will retry...');
          setTimeout(window.startDashboardBroadcast, 1000);
        }
      };

      /**
       * Stop dashboard broadcasting (for debugging)
       */
      window.stopDashboardBroadcast = function() {
        // Stop time-based updates
        if (window.dashboardUpdateInterval) {
          clearInterval(window.dashboardUpdateInterval);
          window.dashboardUpdateInterval = null;
        }
        
        // Stop queue processing
        if (window.dashboardQueueInterval) {
          clearInterval(window.dashboardQueueInterval);
          window.dashboardQueueInterval = null;
        }
        
        // Stop event-driven watching
        if (window.GameDataWatcher && window.GameDataWatcher.isWatching) {
          window.GameDataWatcher.stopWatching();
        }
        
        console.log(' Dashboard broadcasting stopped (both event-driven and time-based)');
      };

      /**
       * Get current dashboard data (for debugging)
       */
      window.getDashboardData = function() {
        const data = localStorage.getItem('riskGameData');
        if (data) {
          const parsed = JSON.parse(data);
          console.log(' Current Dashboard Data:');
          console.table(parsed.players);
          console.log('Turn:', parsed.turnNumber);
          console.log('Phase:', parsed.phase);
          console.log('Current Player:', parsed.currentPlayer);
          console.log('Last Update:', new Date(parsed.lastUpdate).toLocaleTimeString());
          return parsed;
        } else {
          console.log(' No dashboard data available');
          return null;
        }
      };

      // Start event-driven dashboard system when game is initialized
      document.addEventListener('DOMContentLoaded', () => {
        // Wait for game to be fully initialized
        setTimeout(() => {
          if (window.gameState) {
            window.startDashboardBroadcast();
            
            // Add additional hooks for territory changes that might be missed
            setTimeout(() => {
              window.GameDataWatcher.watchGameStateChanges();
              
              // Add click listeners to territory elements as fallback
              document.querySelectorAll('.territory').forEach(territory => {
                territory.addEventListener('click', () => {
                  setTimeout(() => {
                    if (window.GameDataWatcher && window.GameDataWatcher.isWatching) {
                      window.GameDataWatcher.checkAndUpdate();
                    }
                  }, 100); // Small delay to let game state update
                });
              });
              
              console.log(' Added fallback click listeners to territories');
            }, 1000); // Give territories time to be fully initialized
            
            // Test dashboard connection after initialization
            setTimeout(() => {
              if (window.gameState && window.gameState.territories) {
                console.log(' Running automatic dashboard connection test...');
                const testResult = window.testDashboardConnection();
                if (testResult) {
                  console.log(' Dashboard connection test passed');
                  console.log(' Dashboard URL: http://localhost:8000/Stats/dashboard.html');
                } else {
                  console.warn(' Dashboard connection test failed - check console for details');
                }
              }
            }, 3000); // Give game more time to fully initialize
          }
        }, 2000); // Give game 2 seconds to initialize
      });

      /**
       * Attack Modal Functions
       * Handle opening and managing the attack modal window
       */

      /**
       * Opens the attack modal window for territory battles
       */
      window.openAttackModal = function () {
        const modal = window.GameUtils.safeGetElement("attack-modal");
        if (!modal) return;

        window.GameUtils.safeSetProperty(modal.style, "display", "flex");

        // Update modal with current attacking territory
        if (window.attackState.attackingTerritory) {
          const gameState = window.GameUtils.getGameState();
          if (!gameState) return;

          const territory =
            gameState.territories[window.attackState.attackingTerritory];
          if (territory) {
            window.GameUtils.safeSetProperty(
              "attack-modal-attacking-name",
              "textContent",
              window.attackState.attackingTerritory
                .replace(/-/g, " ")
                .toUpperCase()
            );
            window.GameUtils.safeSetProperty(
              "attack-modal-attacking-armies",
              "textContent",
              `${territory.armies} armies`
            );

            // Show selection UI and highlight valid targets
            window.GameUtils.safeExecute(
              window.highlightValidTargets,
              null,
              window.attackState.attackingTerritory
            );
            window.GameUtils.safeSetProperty(
              "attack-modal-status",
              "innerHTML",
              "<strong>Click on an adjacent enemy territory</strong> on the map to select your target"
            );

            // Add helpful instruction
            const statusElement = window.GameUtils.safeGetElement(
              "attack-modal-status",
              false
            );
            if (statusElement) {
              statusElement.innerHTML +=
                '<br><small style="color: #666;"> Valid targets are highlighted in orange on the map</small>';
            }
          }
        }
      };

      window.closeAttackModal = function () {
        const modal = document.getElementById("attack-modal");
        if (!modal) return;

        modal.style.display = "none";
        window.clearAttackHighlights();

        // Reset modal state but keep attacking territory selected using safe DOM access
        window.GameUtils.safeSetStyle(
          "attack-modal-dice-selection",
          "display",
          "none"
        );
        window.GameUtils.safeSetStyle(
          "attack-modal-execute",
          "display",
          "none"
        );
        window.GameUtils.safeSetStyle(
          "attack-modal-results",
          "display",
          "none"
        );
        window.GameUtils.safeSetStyle("attack-modal-reset", "display", "none");
      };

      /**
       * Target Selection Modal Functions (SIMPLIFIED)
       */
      window.targetSelectionState = {
        attackingTerritory: null,
        validTargets: [],
        selectedIndex: 0
      };

      window.openTargetSelectionModal = function(attackingTerritoryId) {
        if (!attackingTerritoryId || !window.gameState) return;

        const attackingTerritory = window.gameState.territories[attackingTerritoryId];
        if (!attackingTerritory || attackingTerritory.armies <= 1) return;

        const currentPlayer = window.gameState.getCurrentPlayer();

        // Get valid attack targets - ONLY check neighboring territories owned by OTHER players
        let validTargets = [];
        
        if (attackingTerritory.neighbors && Array.isArray(attackingTerritory.neighbors)) {
          console.log(` Checking neighbors of ${attackingTerritoryId}:`, attackingTerritory.neighbors);
          
          validTargets = attackingTerritory.neighbors.filter(neighborId => {
            const neighbor = window.gameState.territories[neighborId];
            const isEnemy = neighbor && neighbor.owner !== currentPlayer;
            console.log(`  - ${neighborId}: owner=${neighbor?.owner}, currentPlayer=${currentPlayer}, isEnemy=${isEnemy}`);
            return isEnemy;
          });
        } else {
          console.error(` Territory ${attackingTerritoryId} has no neighbors array!`, attackingTerritory);
        }

        console.log(` Valid attack targets from ${attackingTerritoryId}:`, validTargets);

        if (validTargets.length === 0) {
          console.log('No valid targets from this territory');
          alert('No enemy territories adjacent to attack from here!');
          return;
        }

        // Store state
        window.targetSelectionState = {
          attackingTerritory: attackingTerritoryId,
          validTargets: validTargets,
          selectedIndex: 0
        };

        // Get modal and its child elements
        const modal = document.getElementById('target-selection-modal');
        if (!modal) {
          console.error(' Target selection modal not found!');
          alert('Error: Modal not found. Please refresh the page.');
          return;
        }

        // Query child elements from within the modal container
        const attackingDisplay = modal.querySelector('.attacking-territory-display');
        if (!attackingDisplay) {
          console.error(' Attacking territory display not found!');
          return;
        }

        // Get elements by their position within the display (more reliable than IDs)
        const territoryName = attackingDisplay.querySelector('.territory-name');
        const territoryArmies = attackingDisplay.querySelector('.territory-armies');
        const targetListEl = modal.querySelector('.target-list');

        if (!territoryName || !territoryArmies || !targetListEl) {
          console.error(' Modal child elements not found!', {
            territoryName: !!territoryName,
            territoryArmies: !!territoryArmies,
            targetListEl: !!targetListEl
          });
          
          // Debug: show what's in the modal
          console.log('Modal HTML:', modal.innerHTML.substring(0, 500));
          alert('Error: Could not initialize target selection. Please try clicking the territory instead.');
          return;
        }

        console.log(' All modal elements found');

        // Update attacking territory display
        const colorManager = window.riskUI?.colorManager;
        const playerColor = colorManager ? colorManager.getPlayerColor(attackingTerritory.owner) : '#666';

        territoryName.textContent = attackingTerritoryId.replace(/-/g, ' ').toUpperCase();
        territoryArmies.textContent = `${attackingTerritory.armies} armies`;

        if (attackingDisplay) {
          attackingDisplay.style.backgroundColor = playerColor + '33';
          attackingDisplay.style.borderColor = playerColor;
        }

        // Populate target list
        targetListEl.innerHTML = '';

        validTargets.forEach((targetId, index) => {
          const targetTerritory = window.gameState.territories[targetId];
          if (!targetTerritory) return;

          const targetColor = colorManager ? colorManager.getPlayerColor(targetTerritory.owner) : '#666';
          const targetItem = document.createElement('div');
          targetItem.className = 'target-item' + (index === 0 ? ' selected' : '');
          targetItem.dataset.index = index;
          targetItem.style.backgroundColor = targetColor + '22';
          targetItem.style.borderColor = targetColor + '55';

          targetItem.innerHTML = `
            <div class="target-info">
              <div class="target-name">${targetId.replace(/-/g, ' ').toUpperCase()}</div>
              <div class="target-armies">Owner: ${targetTerritory.owner}</div>
            </div>
            <div style="font-size: 1.3em; font-weight: bold; color: ${targetColor};">
              ${targetTerritory.armies} 
            </div>
          `;

          targetItem.onclick = () => window.selectTargetFromModal(index);
          targetListEl.appendChild(targetItem);
        });

        modal.style.display = 'flex';
      };

      window.closeTargetSelectionModal = function() {
        const modal = document.getElementById('target-selection-modal');
        if (modal) modal.style.display = 'none';
        
        window.targetSelectionState = {
          attackingTerritory: null,
          validTargets: [],
          selectedIndex: 0
        };
      };

      window.navigateTargetSelection = function(direction) {
        const state = window.targetSelectionState;
        if (!state.validTargets.length) return;

        const items = document.querySelectorAll('.target-item');
        items[state.selectedIndex]?.classList.remove('selected');

        if (direction === 'up') {
          state.selectedIndex = (state.selectedIndex - 1 + state.validTargets.length) % state.validTargets.length;
        } else {
          state.selectedIndex = (state.selectedIndex + 1) % state.validTargets.length;
        }

        const newItem = items[state.selectedIndex];
        if (newItem) {
          newItem.classList.add('selected');
          newItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      };

      window.selectTargetFromModal = function(index) {
        const state = window.targetSelectionState;
        if (index !== undefined) state.selectedIndex = index;

        const defendingTerritoryId = state.validTargets[state.selectedIndex];
        const attackingTerritoryId = state.attackingTerritory;
        
        if (!defendingTerritoryId || !attackingTerritoryId) return;

        // Close target modal
        window.closeTargetSelectionModal();

        // Open attack modal with both territories selected
        const attackModal = document.getElementById('attack-modal');
        if (!attackModal) return;

        const attackingTerr = window.gameState.territories[attackingTerritoryId];
        const defendingTerr = window.gameState.territories[defendingTerritoryId];

        // Update attack modal content
        document.getElementById('attack-modal-attacking-name').textContent = 
          attackingTerritoryId.replace(/-/g, ' ').toUpperCase();
        document.getElementById('attack-modal-attacking-armies').textContent = 
          `${attackingTerr.armies} armies`;
        
        document.getElementById('attack-modal-defending-name').textContent = 
          defendingTerritoryId.replace(/-/g, ' ').toUpperCase();
        document.getElementById('attack-modal-defending-armies').textContent = 
          `${defendingTerr.armies} armies`;

        // Show army input section
        const armyInput = document.getElementById('attack-modal-army-input');
        if (armyInput) armyInput.style.display = 'block';

        // Show execute button
        const executeBtn = document.getElementById('attack-modal-execute');
        if (executeBtn) executeBtn.style.display = 'block';

        // Set up input fields
        const attackerInput = document.getElementById('attack-modal-attacker-armies-input');
        const defenderInput = document.getElementById('attack-modal-defender-armies-input');
        
        if (attackerInput) {
          attackerInput.min = 1;
          attackerInput.max = attackingTerr.armies;
          attackerInput.value = attackingTerr.armies;
        }
        
        if (defenderInput) {
          defenderInput.min = 0;
          defenderInput.max = defendingTerr.armies;
          defenderInput.value = defendingTerr.armies;
        }

        // Store attack state
        if (window.attackState) {
          window.attackState.attackingTerritory = attackingTerritoryId;
          window.attackState.defendingTerritory = defendingTerritoryId;
        }

        attackModal.style.display = 'flex';
      };

      window.showAttackButton = function (territoryId) {
        const container = document.getElementById("attack-button-container");
        const territoryInfo = document.getElementById(
          "selected-attacking-territory"
        );

        if (!container || !territoryInfo) return;

        const territory = window.riskUI.gameState.territories[territoryId];
        territoryInfo.textContent = `${territoryId} (${territory.armies} armies)`;
        container.style.display = "block";
      };

      window.hideAttackButton = function () {
        const container = document.getElementById("attack-button-container");
        if (container) {
          container.style.display = "none";
        }
      };

      /**
       * Show attack message to user with safe DOM access
       * @param {string} message - Message to display
       * @param {string} type - Message type ('info', 'error', 'success')
       */
      window.showAttackMessage = function (message, type = "info") {
        // Try to update the attack modal status first
        const statusElement = window.GameUtils.safeGetElement(
          "attack-modal-status",
          false
        );
        if (statusElement) {
          const typeColors = {
            error: "#d32f2f",
            success: "#388e3c",
            info: "#1976d2",
          };
          statusElement.innerHTML = `<span style="color: ${
            typeColors[type] || typeColors.info
          }">${message}</span>`;
          return;
        }

        // Fallback to console logging if no UI element available
        console.log(`Attack Message (${type}): ${message}`);
      };

      // Enhanced Attack Phase Functions
      window.attackState = {
        attackingTerritory: null,
        defendingTerritory: null,
        attackerRemaining: 1,
        defenderRemaining: 1,
        maxAttackerArmies: 1,
        maxDefenderArmies: 1,
        directCombat: null,
        step: 1, // Track current step in attack process
      };

      // Ensure attackState is available globally
      if (!window.attackState) {
        window.attackState = {
          attackingTerritory: null,
          defendingTerritory: null,
          attackerRemaining: 1,
          defenderRemaining: 1,
          maxAttackerArmies: 1,
          maxDefenderArmies: 1,
          directCombat: null,
          step: 1,
        };
      }

      // Initialize direct combat system when available
      window.initializeAttackSystem = function () {
        // First check if DirectCombat instance already exists
        if (typeof window.directCombat !== "undefined" && window.directCombat) {
          window.attackState.directCombat = window.directCombat;
          console.log(
            " Direct Combat system initialized (using existing instance)"
          );
          return true;
        }

        // If instance doesn't exist, try to create one
        if (typeof DirectCombat === "function") {
          try {
            window.directCombat = new DirectCombat();
            window.attackState.directCombat = window.directCombat;
            console.log(
              " Direct Combat system initialized (created new instance)"
            );
            return true;
          } catch (err) {
            console.error("Failed to create DirectCombat instance:", err);
            return false;
          }
        }

        // If DirectCombat class is not available, wait and try again
        console.warn(
          "DirectCombat class not available, retrying in 1 second..."
        );
        setTimeout(() => {
          if (!window.directCombatInitialized) {
            window.initializeAttackSystem();
          }
        }, 1000);

        return false;
      };

      // Flag to track if DirectCombat has been initialized
      window.directCombatInitialized = false;

      // This function is no longer needed with direct army input
      window.adjustAttackerArmies = function () {
        // Function has been replaced by direct input in the UI
      };

      // LEGACY FUNCTION - DISABLED: Use CombatUI.executeAttack() instead
      window.executeAttack = function () {
        console.warn(
          "Legacy executeAttack() called - redirecting to CombatUI system"
        );
        console.log("DEBUG: window.combatUI exists:", !!window.combatUI);
        console.log("DEBUG: typeof window.combatUI:", typeof window.combatUI);
        console.log(
          "DEBUG: window.combatUI.executeAttack exists:",
          !!(window.combatUI && window.combatUI.executeAttack)
        );

        // Try different access methods
        const combatUI = window.combatUI || window["combatUI"];
        console.log("DEBUG: combatUI via fallback:", !!combatUI);

        if (combatUI && typeof combatUI.executeAttack === "function") {
          console.log("Calling combatUI.executeAttack()");
          return combatUI.executeAttack();
        } else if (combatUI) {
          // Try to access method from prototype
          const proto = Object.getPrototypeOf(combatUI);
          console.log(
            "DEBUG: CombatUI prototype methods:",
            Object.getOwnPropertyNames(proto).filter(
              (name) => typeof proto[name] === "function"
            )
          );

          if (
            proto.executeAttack &&
            typeof proto.executeAttack === "function"
          ) {
            console.log("Calling executeAttack from prototype");
            return proto.executeAttack.call(combatUI);
          } else {
            console.error(
              "executeAttack method not found on CombatUI or its prototype"
            );
            console.log(
              "CombatUI own properties:",
              Object.getOwnPropertyNames(combatUI)
            );
            window.showAttackMessage(
              " Combat system method not found!",
              "error"
            );
            return;
          }
        } else {
          console.error("CombatUI not available - cannot execute attack");
          console.log(
            "Available on window:",
            Object.keys(window).filter((k) => k.includes("combat"))
          );
          window.showAttackMessage(
            " Combat system not initialized!",
            "error"
          );
          return;
        }
      };

      // LEGACY FUNCTION - DISABLED: Use DirectCombat.determineBattleOutcome() instead
      window.performDirectCombat = function (
        attackerArmies,
        defenderArmies,
        attackerRemaining,
        defenderRemaining
      ) {
        console.warn(
          "Legacy performDirectCombat() called - use DirectCombat system instead"
        );
        if (window.directCombat) {
          return window.directCombat.determineBattleOutcome(
            attackerArmies,
            defenderArmies,
            attackerRemaining,
            defenderRemaining
          );
        }
        return { success: false, error: "DirectCombat system not available" };
      };

      // Display combat results in the UI
      window.displayCombatResults = function (result) {
        // Show results section
        GameUtils.safeSetStyle("attack-modal-results", "display", "block");

        // Display battle result (no dice rolls for direct combat)
        let resultMessage = `Attacker lost ${result.attackerLosses} armies, Defender lost ${result.defenderLosses} armies.`;
        if (result.territoryConquered) {
          resultMessage += "<br><strong> Territory Conquered!</strong>";
        }

        GameUtils.safeSetProperty(
          "attack-modal-battle-result",
          "innerHTML",
          resultMessage
        );

        // Show continue/end options
        if (result.territoryConquered) {
          GameUtils.safeSetStyle("attack-modal-continue", "display", "none");
          GameUtils.safeSetStyle("attack-modal-end", "display", "block");
        } else {
          // Check if attacker can continue
          const canContinue = result.remainingAttackerArmies > 1;
          GameUtils.safeSetStyle(
            "attack-modal-continue",
            "display",
            canContinue ? "block" : "none"
          );
          GameUtils.safeSetStyle("attack-modal-end", "display", "block");
        }

        // Hide execute button
        GameUtils.safeSetStyle("attack-modal-execute", "display", "none");
      };

      // Apply combat results to game state
      window.applyCombatResults = function (result) {
        const gameState = GameUtils.getGameState();
        if (!gameState) return;

        const attackingTerr =
          gameState.territories[window.attackState.attackingTerritory];
        const defendingTerr =
          gameState.territories[window.attackState.defendingTerritory];

        if (!attackingTerr || !defendingTerr) return;

        // Apply army losses
        attackingTerr.armies = result.remainingAttackerArmies;
        defendingTerr.armies = result.remainingDefenderArmies;

        // Handle territory conquest
        if (result.territoryConquered) {
          const previousOwner = defendingTerr.owner;
          defendingTerr.owner = attackingTerr.owner;

          // Move minimum armies (equal to dice used in attack)
          const minMove = window.attackState.attackerDice;
          defendingTerr.armies = minMove;
          attackingTerr.armies -= minMove;

          // Check for player elimination
          window.checkPlayerElimination(previousOwner);

          // Open unit transfer modal for additional army movement
          setTimeout(() => {
            const availableForTransfer = attackingTerr.armies - 1; // Must leave at least 1
            if (availableForTransfer > 0) {
              window.openTransferModal(
                window.attackState.attackingTerritory,
                window.attackState.defendingTerritory,
                availableForTransfer
              );
            }
          }, 500);
        }

        // Update UI displays
        if (window.riskUI && window.riskUI.updateTerritoryDisplay) {
          window.riskUI.updateTerritoryDisplay(
            window.attackState.attackingTerritory
          );
          window.riskUI.updateTerritoryDisplay(
            window.attackState.defendingTerritory
          );
        }

        // Update territory colors
        if (result.territoryConquered) {
          window.updateTerritoryOwnershipVisuals(
            window.attackState.defendingTerritory,
            attackingTerr.owner
          );
        }
      };

      // Continue attack (reset for another round)
      window.continueAttack = function () {
        // Reset modal for next attack
        GameUtils.safeSetStyle("attack-modal-results", "display", "none");
        GameUtils.safeSetStyle("attack-modal-army-input", "display", "block");
        GameUtils.safeSetStyle("attack-modal-execute", "display", "block");

        // Update army counts for next round
        const gameState = GameUtils.getGameState();
        if (
          gameState &&
          window.attackState.attackingTerritory &&
          window.attackState.defendingTerritory
        ) {
          const attackingTerr =
            gameState.territories[window.attackState.attackingTerritory];
          const defendingTerr =
            gameState.territories[window.attackState.defendingTerritory];

          if (attackingTerr && defendingTerr) {
            // Set default values for army input fields
            const attackerInput = GameUtils.safeGetElement(
              "attack-modal-attacker-armies-input",
              false
            );
            const defenderInput = GameUtils.safeGetElement(
              "attack-modal-defender-armies-input",
              false
            );

            if (attackerInput) {
              attackerInput.min = 1;
              attackerInput.max = attackingTerr.armies;
              attackerInput.value = attackingTerr.armies;
            }

            if (defenderInput) {
              defenderInput.min = 0;
              defenderInput.max = defendingTerr.armies;
              defenderInput.value = defendingTerr.armies;
            }

            // Update territory army displays
            GameUtils.safeSetProperty(
              "attack-modal-attacking-armies",
              "textContent",
              `${attackingTerr.armies} armies`
            );
            GameUtils.safeSetProperty(
              "attack-modal-defending-armies",
              "textContent",
              `${defendingTerr.armies} armies`
            );
          }
        }

        window.showAttackMessage(" Ready for another battle!", "info");
      };

      // End attack (close modal and reset)
      window.endAttack = function () {
        window.closeAttackModal();
        window.resetAttackState();
      };

      // Enhanced show/hide attack panel with territory highlighting
      window.updateAttackPanelVisibility = function () {
        const attackPanel = document.getElementById("attack-panel");
        if (!attackPanel) return;

        const currentPhase =
          window.riskUI && window.riskUI.gameState
            ? window.riskUI.gameState.phase
            : "unknown";

        if (currentPhase === "attack") {
          attackPanel.classList.add("active");
          window.highlightAttackableElements();
        } else {
          attackPanel.classList.remove("active");
          window.clearAttackHighlights();
          if (typeof window.resetAttackState === "function") {
            window.resetAttackState();
          }
        }
      };

      // Highlight territories that can attack
      window.highlightAttackableElements = function () {
        if (!window.riskUI || !window.riskUI.gameState) return;

        const currentPlayer = window.riskUI.gameState.getCurrentPlayer();
        const territories = window.riskUI.gameState.territories;

        Object.keys(territories).forEach((territoryId) => {
          const territory = territories[territoryId];
          const element = document.getElementById(territoryId);
          if (!element) return;

          // Remove existing attack highlights
          element.classList.remove(
            "highlight-attackable",
            "highlight-attacking-from"
          );

          if (territory.owner === currentPlayer && territory.armies > 1) {
            element.classList.add("highlight-attackable");
          }
        });
      };

      // Clear all attack-related highlights
      window.clearAttackHighlights = function () {
        const territories = document.querySelectorAll(".territory");
        territories.forEach((element) => {
          element.classList.remove(
            "highlight-attackable",
            "highlight-attacking-from",
            "highlight-selected-attacker",
            "highlight-selected-target"
          );
        });
      };

      // Enhanced reset attack state
      window.resetAttackState = function () {
        window.attackState.attackingTerritory = null;
        window.attackState.defendingTerritory = null;
        window.attackState.attackerDice = 1;
        window.attackState.defenderDice = 1;
        window.attackState.step = 1;

        // Hide attack button in sidebar
        window.hideAttackButton();

        // Reset modal UI elements with safe property setting
        window.GameUtils.safeSetProperty(
          "attack-modal-status",
          "innerHTML",
          "Select territories to attack"
        );
        window.GameUtils.safeSetProperty(
          "attack-modal-defending-name",
          "textContent",
          "Select target"
        );
        window.GameUtils.safeSetProperty(
          "attack-modal-defending-armies",
          "textContent",
          "0 armies"
        );

        // Safe element display changes
        const diceSelection = window.GameUtils.safeGetElement(
          "attack-modal-dice-selection",
          false
        );
        if (diceSelection) diceSelection.style.display = "none";

        const executeBtn = window.GameUtils.safeGetElement(
          "attack-modal-execute",
          false
        );
        if (executeBtn) executeBtn.style.display = "none";

        const resultsDiv = window.GameUtils.safeGetElement(
          "attack-modal-results",
          false
        );
        if (resultsDiv) resultsDiv.style.display = "none";

        const resetBtn = window.GameUtils.safeGetElement(
          "attack-modal-reset",
          false
        );
        if (resetBtn) resetBtn.style.display = "none";

        // Clear highlights and re-highlight attackable territories
        window.clearAttackHighlights();
        window.highlightAttackableElements();
      };

      // LEGACY FUNCTION - DISABLED: Use CombatUI.handleTerritoryClick() instead
      window.selectAttackingTerritory = function (territoryId) {
        console.warn(
          "Legacy selectAttackingTerritory() called - using CombatUI system instead"
        );
        if (window.combatUI && window.combatUI.handleTerritoryClick) {
          return window.combatUI.handleTerritoryClick(territoryId);
        }
        return false;
      };

      // Highlight territories that can be attacked from the selected territory
      window.highlightValidTargets = function (attackingTerritoryId) {
        if (!window.riskUI || !window.riskUI.gameState) return;

        const attackingTerritory =
          window.riskUI.gameState.territories[attackingTerritoryId];
        const currentPlayer = window.riskUI.gameState.getCurrentPlayer();

        attackingTerritory.neighbors.forEach((neighborId) => {
          const neighbor = window.riskUI.gameState.territories[neighborId];
          if (neighbor && neighbor.owner !== currentPlayer) {
            const element = document.getElementById(neighborId);
            if (element) {
              // Valid target - no additional highlighting needed beyond neighbor-desaturated
            }
          }
        });
      };

      // DEPRECATED: Enhanced defending territory selection - Redirects to CombatUI
      window.selectDefendingTerritory = function (territoryId) {
        console.warn(
          " selectDefendingTerritory() is DEPRECATED. Territory selection is now handled by CombatUI.js"
        );

        // Try to use CombatUI if available
        if (
          window.combatUI &&
          typeof window.combatUI.handleTerritoryClick === "function"
        ) {
          console.log(
            " Using CombatUI.handleTerritoryClick() for territory selection"
          );
          return window.combatUI.handleTerritoryClick(territoryId);
        }

        // Fallback: Store in attack state only (don't update UI)
        if (window.attackState) {
          window.attackState.defendingTerritory = territoryId;
          console.log(
            `Fallback: Stored defending territory ${territoryId} in attackState`
          );
        }

        return false;
      };

      // Enhanced reset attack state
      window.resetAttackState = function () {
        window.attackState.attackingTerritory = null;
        window.attackState.defendingTerritory = null;
        window.attackState.attackerDice = 1;
        window.attackState.defenderDice = 1;
        window.attackState.step = 1;

        // Hide attack button in sidebar
        window.hideAttackButton();

        // Reset modal UI elements with safe property setting
        window.GameUtils.safeSetProperty(
          "attack-modal-status",
          "innerHTML",
          "Select territories to attack"
        );
        window.GameUtils.safeSetProperty(
          "attack-modal-defending-name",
          "textContent",
          "Select target"
        );
        window.GameUtils.safeSetProperty(
          "attack-modal-defending-armies",
          "textContent",
          "0 armies"
        );

        // Safe element display changes
        const diceSelection = window.GameUtils.safeGetElement(
          "attack-modal-dice-selection",
          false
        );
        if (diceSelection) diceSelection.style.display = "none";

        const executeBtn = window.GameUtils.safeGetElement(
          "attack-modal-execute",
          false
        );
        if (executeBtn) executeBtn.style.display = "none";

        const resultsDiv = window.GameUtils.safeGetElement(
          "attack-modal-results",
          false
        );
        if (resultsDiv) resultsDiv.style.display = "none";

        const resetBtn = window.GameUtils.safeGetElement(
          "attack-modal-reset",
          false
        );
        if (resetBtn) resetBtn.style.display = "none";

        // Clear highlights and re-highlight attackable territories
        window.clearAttackHighlights();
        window.highlightAttackableElements();
      };

      // Territory click handler for attack phase
      window.handleTerritoryClickForAttack = function (territoryId) {
        if (!window.riskUI || !window.riskUI.gameState) return false;

        const currentPhase = window.riskUI.gameState.phase;
        if (currentPhase !== "attack") return false;

        const territory = window.riskUI.gameState.territories[territoryId];
        const currentPlayer = window.riskUI.gameState.getCurrentPlayer();

        // If no attacking territory selected yet
        if (!window.attackState.attackingTerritory) {
          if (territory.owner === currentPlayer && territory.armies > 1) {
            // Use CombatUI system instead of legacy function
            if (window.combatUI && window.combatUI.handleTerritoryClick) {
              return window.combatUI.handleTerritoryClick(territoryId);
            }
            return window.selectAttackingTerritory(territoryId);
          } else {
            window.showAttackMessage(
              " Select your own territory with 2+ armies to attack from",
              "error"
            );
            return false;
          }
        }
        // If attacking territory selected, now select defending territory
        else if (!window.attackState.defendingTerritory) {
          if (territory.owner !== currentPlayer) {
            // Use CombatUI system instead of legacy function
            if (window.combatUI && window.combatUI.handleTerritoryClick) {
              return window.combatUI.handleTerritoryClick(territoryId);
            }
            return window.selectDefendingTerritory(territoryId);
          } else {
            window.showAttackMessage(
              " You cannot attack your own territories",
              "error"
            );
            return false;
          }
        }
        // Both territories selected, allow re-selection
        else {
          if (territory.owner === currentPlayer && territory.armies > 1) {
            // Switch to new attacking territory
            if (typeof window.resetAttackState === "function") {
              window.resetAttackState();
            }
            // Use CombatUI system instead of legacy function
            if (window.combatUI && window.combatUI.handleTerritoryClick) {
              return window.combatUI.handleTerritoryClick(territoryId);
            }
            return window.selectAttackingTerritory(territoryId);
          } else if (territory.owner !== currentPlayer) {
            // Switch to new defending territory  
            // Use CombatUI system instead of legacy function
            if (window.combatUI && window.combatUI.handleTerritoryClick) {
              return window.combatUI.handleTerritoryClick(territoryId);
            }
            return window.selectDefendingTerritory(territoryId);
          }
        }

        return false;
      };

      // ========================================================================
      // DEPRECATED: Legacy Battle Management System
      // This code is kept ONLY for backward compatibility
      // All new code should use CombatUI.js for combat management
      // ========================================================================

      // DEPRECATED: Use CombatUI state management instead
      window.battleState = {
        attackingTerritory: null,
        defendingTerritory: null,
        initialAttackerArmies: 0,
        initialDefenderArmies: 0,
        minAttackerArmies: 1,
        minDefenderArmies: 0,
      };

      // DEPRECATED: Redirect to CombatUI.startAttack()
      window.openBattleModal = function (
        attackingTerritoryId,
        defendingTerritoryId
      ) {
        console.warn(
          " openBattleModal() is DEPRECATED. Redirecting to CombatUI.startAttack()"
        );

        // Try to use CombatUI if available
        if (
          window.combatUI &&
          typeof window.combatUI.startAttack === "function"
        ) {
          console.log(" Using CombatUI.startAttack() for combat management");
          return window.combatUI.startAttack(
            attackingTerritoryId,
            defendingTerritoryId
          );
        }

        // Fallback to opening attack modal directly (CombatUI not loaded yet)
        console.warn(" CombatUI not available, using fallback modal opening");
        if (
          window.openAttackModal &&
          typeof window.openAttackModal === "function"
        ) {
          return window.openAttackModal();
        }
      };

      // DEPRECATED: Redirect to window.closeAttackModal()
      window.closeBattleModal = function () {
        console.warn(
          " closeBattleModal() is DEPRECATED. Use window.closeAttackModal() instead"
        );

        if (
          window.closeAttackModal &&
          typeof window.closeAttackModal === "function"
        ) {
          return window.closeAttackModal();
        }

        // Fallback: Close modal directly
        const modal =
          document.getElementById("battle-modal") ||
          document.getElementById("attack-modal");
        if (modal) {
          modal.style.display = "none";
        }
      };

      // DEPRECATED: User inputs handled in CombatUI now
      window.adjustBattleArmies = function (side, delta) {
        console.warn(
          " adjustBattleArmies() is DEPRECATED. User inputs are now handled in CombatUI.js"
        );
        // No-op: This functionality is now in CombatUI
      };

      // DEPRECATED: Preview updates handled in CombatUI now
      window.updateBattlePreview = function () {
        console.warn(
          " updateBattlePreview() is DEPRECATED. Preview updates are handled in CombatUI.js"
        );
        // No-op: This functionality is now in CombatUI
      };

      // DEPRECATED: Redirect to CombatUI.executeAttack()
      window.resolveBattle = function () {
        console.warn(
          " resolveBattle() is DEPRECATED. Redirecting to CombatUI.executeAttack()"
        );

        // Try to use CombatUI if available
        if (
          window.combatUI &&
          typeof window.combatUI.executeAttack === "function"
        ) {
          console.log(
            " Using CombatUI.executeAttack() for battle resolution"
          );
          return window.combatUI.executeAttack();
        }

        // Fallback error
        console.error(" CombatUI not available. Cannot resolve battle.");
        alert("Combat system not initialized. Please refresh the page.");
      };

      // Manually update territory color and visuals
      window.updateTerritoryOwnershipVisuals = function (
        territoryId,
        newOwner
      ) {
        const territoryElement = window.GameUtils.safeGetElement(
          territoryId,
          false
        );
        if (!territoryElement) return;

        // Update territory color using the user-selected colors from GameState
        let playerColor = "#888888"; // default fallback
        const gameState = window.GameUtils.getGameState();

        if (gameState && gameState.playerColors) {
          playerColor = gameState.playerColors[newOwner] || playerColor;
        } else if (window.riskUI && window.riskUI.colorManager) {
          playerColor = window.riskUI.colorManager.getPlayerColor(newOwner);
        } else if (window.riskUI && window.riskUI.getPlayerColor) {
          playerColor = window.riskUI.getPlayerColor(newOwner);
        }

        territoryElement.style.fill = playerColor;

        // Update data attribute
        territoryElement.setAttribute("data-owner", newOwner);

        // Force visual refresh by updating army display
        const territoryData = window.riskUI.gameState.territories[territoryId];
        if (territoryData && window.riskUI.updateTerritoryArmies) {
          window.riskUI.updateTerritoryArmies(
            territoryId,
            territoryData.armies
          );
        }

        console.log(
          `Territory ${territoryId} visuals updated for new owner: ${newOwner} with color: ${playerColor}`
        );
      };

      // Check if a player has been eliminated
      window.checkPlayerElimination = function (playerName) {
        const gameState = window.GameUtils.getGameState();
        if (!gameState) return;

        const territories = gameState.territories;
        const hasTerritory = Object.values(territories).some(
          (territory) => territory.owner === playerName
        );

        if (!hasTerritory) {
          console.log(`Player ${playerName} has been eliminated!`);
          // Remove from active players if needed
          if (window.riskUI.gameState.players) {
            const playerIndex =
              window.riskUI.gameState.players.indexOf(playerName);
            if (playerIndex > -1) {
              window.riskUI.gameState.players.splice(playerIndex, 1);
            }
          }

          // Show elimination message
          setTimeout(() => {
            alert(`Player ${playerName} has been eliminated from the game!`);
          }, 500);
        }
      };

      // Unit Transfer System
      window.transferState = {
        sourceTerritory: null,
        destinationTerritory: null,
        maxTransfer: 0,
        currentTransfer: 1,
      };

      /**
       * Open unit transfer modal after conquest
       * Implements official Risk rules for army transfers
       * @param {string} sourceTerritory - Territory being transferred from
       * @param {string} destinationTerritory - Territory being transferred to
       * @param {number} availableArmies - Number of armies available for transfer
       */
      window.openTransferModal = function (
        sourceTerritory,
        destinationTerritory,
        availableArmies
      ) {
        const gameState = window.GameUtils.getGameState();
        if (!gameState) return;

        const sourceTerr = gameState.territories[sourceTerritory];
        if (!sourceTerr) return;

        // According to official Risk rules:
        // - Minimum: You must move at least 1 army (since we can't track exact attack dice in manual battles)
        // - Maximum: You can move up to all armies except 1 (which must stay in source territory)
        const minTransfer = 1;
        const maxTransfer = Math.min(availableArmies, sourceTerr.armies - 1);

        // Set up transfer state
        window.transferState.sourceTerritory = sourceTerritory;
        window.transferState.destinationTerritory = destinationTerritory;
        window.transferState.maxTransfer = maxTransfer;
        window.transferState.minTransfer = minTransfer;
        window.transferState.currentTransfer = minTransfer;

        // Update modal display using safe DOM access
        window.GameUtils.safeUpdateElement(
          "transfer-source-name",
          "textContent",
          sourceTerritory.replace(/-/g, " ").toUpperCase()
        );
        window.GameUtils.safeUpdateElement(
          "transfer-source-armies",
          "textContent",
          `${sourceTerr.armies} armies (before transfer)`
        );

        window.GameUtils.safeUpdateElement(
          "transfer-destination-name",
          "textContent",
          destinationTerritory.replace(/-/g, " ").toUpperCase()
        );
        window.GameUtils.safeUpdateElement(
          "transfer-destination-armies",
          "textContent",
          "1 army (minimum occupation)"
        );

        // Update constraints with official Risk rules explanation
        window.GameUtils.safeUpdateElement(
          "transfer-range",
          "textContent",
          `You can transfer ${minTransfer}-${maxTransfer} armies`
        );

        // Update constraints text with Risk rules using safe DOM access
        const constraintsList = window.GameUtils.safeGetElement(
          "transfer-constraints ul",
          false
        );
        if (!constraintsList) {
          const constraintsContainer = document.querySelector(
            ".transfer-constraints ul"
          );
          if (constraintsContainer) {
            constraintsContainer.innerHTML = `
                        <li><strong>Minimum:</strong> ${minTransfer} army must move (Official Risk rule)</li>
                        <li><strong>Maximum:</strong> ${maxTransfer} armies can move (must leave 1 in source)</li>
                        <li><strong>Mandatory:</strong> You MUST move armies when conquering (Risk rule)</li>
                    `;
          }
        }

        // Set up slider and input using safe property setting
        window.GameUtils.safeSetProperty("transfer-slider", "min", minTransfer);
        window.GameUtils.safeSetProperty("transfer-slider", "max", maxTransfer);
        window.GameUtils.safeSetProperty(
          "transfer-slider",
          "value",
          minTransfer
        );

        window.GameUtils.safeSetProperty("transfer-input", "min", minTransfer);
        window.GameUtils.safeSetProperty("transfer-input", "max", maxTransfer);
        window.GameUtils.safeSetProperty(
          "transfer-input",
          "value",
          minTransfer
        );

        // Update slider labels using safe DOM access
        const firstLabel = document.querySelector(
          ".slider-labels span:first-child"
        );
        if (firstLabel) firstLabel.textContent = minTransfer;
        window.GameUtils.safeUpdateElement(
          "slider-max-label",
          "textContent",
          maxTransfer
        );

        // Update button text using safe DOM access
        const useMinBtn = window.GameUtils.safeGetElement(
          "use-minimum-btn",
          false
        );
        if (useMinBtn) {
          useMinBtn.textContent = `Use Minimum (${minTransfer} ${
            minTransfer === 1 ? "army" : "armies"
          })`;
        }

        // Update preview
        window.updateTransferPreview();

        // Show modal using safe style setting
        window.GameUtils.safeSetStyle("unit-transfer-modal", "display", "flex");
      };

      // Close transfer modal
      window.closeTransferModal = function () {
        window.GameUtils.safeSetStyle("unit-transfer-modal", "display", "none");

        // Reset transfer state
        window.transferState.sourceTerritory = null;
        window.transferState.destinationTerritory = null;
        window.transferState.maxTransfer = 0;
        window.transferState.currentTransfer = 1;
      };

      // Adjust transfer armies with buttons
      window.adjustTransferArmies = function (delta) {
        const newValue = window.transferState.currentTransfer + delta;
        const minTransfer = window.transferState.minTransfer || 1;
        const maxTransfer = window.transferState.maxTransfer || 1;

        if (newValue >= minTransfer && newValue <= maxTransfer) {
          window.transferState.currentTransfer = newValue;

          // Update both slider and input using safe DOM access
          window.GameUtils.safeSetProperty(
            "transfer-slider",
            "value",
            newValue
          );
          window.GameUtils.safeSetProperty("transfer-input", "value", newValue);

          // Update preview
          window.updateTransferPreview();
        }
      };

      // Update transfer preview
      window.updateTransferPreview = function () {
        const transferAmount = window.transferState.currentTransfer;
        const sourceTerr =
          window.riskUI.gameState.territories[
            window.transferState.sourceTerritory
          ];

        if (!sourceTerr) return;

        const sourceRemaining = sourceTerr.armies - transferAmount;
        const destinationTotal = 1 + transferAmount; // Already has 1 from conquest

        // Update preview display using safe DOM access
        window.GameUtils.safeUpdateElement(
          "preview-source-name",
          "textContent",
          window.transferState.sourceTerritory.replace(/-/g, " ").toUpperCase()
        );
        window.GameUtils.safeUpdateElement(
          "preview-source-armies",
          "textContent",
          `${sourceRemaining} armies remaining`
        );

        window.GameUtils.safeUpdateElement(
          "preview-destination-name",
          "textContent",
          window.transferState.destinationTerritory
            .replace(/-/g, " ")
            .toUpperCase()
        );
        window.GameUtils.safeUpdateElement(
          "preview-destination-armies",
          "textContent",
          `${destinationTotal} armies total`
        );

        // Update button states
        const minusBtn = document.querySelector(
          ".transfer-number-input button:first-child"
        );
        const plusBtn = document.querySelector(
          ".transfer-number-input button:last-child"
        );

        minusBtn.disabled = transferAmount <= 1;
        plusBtn.disabled = transferAmount >= window.transferState.maxTransfer;
      };

      // Cancel transfer (use minimum)
      window.cancelTransfer = function () {
        console.warn(
          " Legacy cancelTransfer() called - using CombatUI system instead"
        );

        try {
          if (window.combatUI && window.combatUI.cancelTransfer) {
            console.log(" Using minimum transfer (1 army)");
            const result = window.combatUI.cancelTransfer();
            console.log(" Minimum transfer completed:", result);
            return result;
          } else {
            console.warn(
              " CombatUI cancelTransfer not available, using fallback"
            );

            // FALLBACK: Use window.confirmTransfer with 1 army
            if (typeof window.confirmTransfer === "function") {
              // Set transfer amount to 1
              if (window.transferState) {
                window.transferState.currentTransfer = 1;
              }

              // Update input values if they exist
              const transferSlider = document.getElementById("transfer-slider");
              const transferInput = document.getElementById("transfer-input");

              if (transferSlider) transferSlider.value = 1;
              if (transferInput) transferInput.value = 1;

              // Use confirmTransfer with minimum armies
              return window.confirmTransfer();
            }

            // Hide modal if all else fails
            GameUtils.safeSetStyle("unit-transfer-modal", "display", "none");
            console.error(
              " No method available to complete minimum transfer"
            );
            return false;
          }
        } catch (error) {
          console.error(" Error during minimum transfer:", error);
          // Hide modal even on error
          GameUtils.safeSetStyle("unit-transfer-modal", "display", "none");
          return false;
        }
      };

      // Unit transfer function for both legacy and new conquest systems
      let transferInProgress = false;
      window.confirmTransfer = function () {
        if (transferInProgress) {
          console.log(
            " Transfer already in progress, ignoring duplicate call"
          );
          return false;
        }

        transferInProgress = true;
        console.warn(
          " Legacy confirmTransfer() called - using CombatUI conquest system instead"
        );

        try {
          // Ensure we have valid transfer state
          if (
            !window.transferState ||
            !window.transferState.sourceTerritory ||
            !window.transferState.destinationTerritory
          ) {
            console.error(
              " Invalid transfer state - missing territory information"
            );
            GameUtils.safeUpdateElement(
              "transfer-error-message",
              "textContent",
              "Transfer error: Missing territory information"
            );
            return false;
          }

          // Get transfer amount
          const transferAmount = parseInt(
            document.getElementById("transfer-input")?.value ||
              document.getElementById("transfer-slider")?.value ||
              window.transferState?.currentTransfer ||
              1
          );

          console.log(" Transfer amount:", transferAmount);

          // Validate transfer amount
          if (transferAmount < 1 || isNaN(transferAmount)) {
            console.error(" Invalid transfer amount:", transferAmount);
            GameUtils.safeUpdateElement(
              "transfer-error-message",
              "textContent",
              "Transfer error: Invalid army count"
            );
            return false;
          }

          // Execute transfer using CombatUI if available
          if (window.combatUI && window.combatUI.completeConquest) {
            try {
              const result = window.combatUI.completeConquest(transferAmount);
              console.log(" Transfer completed, result:", result);

              // Hide the transfer modal regardless of result
              GameUtils.safeSetStyle("unit-transfer-modal", "display", "none");

              return result;
            } catch (uiError) {
              console.error(" Error in CombatUI.completeConquest:", uiError);
              // Continue to fallback logic
            }
          } else {
            console.warn(
              " CombatUI conquest system not available, using fallback"
            );
          }

          // ULTIMATE FALLBACK: Try CombatSystem directly if it exists
          if (window.combatSystem && window.transferState) {
            try {
              console.log(
                " Attempting CombatSystem direct transfer fallback"
              );
              const result =
                window.combatSystem.completeConquest(transferAmount);
              if (result && result.success) {
                console.log(" Direct CombatSystem transfer successful");
                GameUtils.safeSetStyle(
                  "unit-transfer-modal",
                  "display",
                  "none"
                );
                return result;
              }
            } catch (csError) {
              console.error(
                " Error in CombatSystem direct transfer:",
                csError
              );
              // Continue to manual fallback
            }
          }

          // MANUAL FALLBACK: Transfer directly using game state
          const gameState = GameUtils.getGameState();
          if (!gameState || !gameState.territories) {
            console.error(" Game state not available for fallback transfer");
            return false;
          }

          const source =
            gameState.territories[window.transferState.sourceTerritory];
          const destination =
            gameState.territories[window.transferState.destinationTerritory];

          if (!source || !destination) {
            console.error(" Source or destination territory not found");
            return false;
          }

          // Check if transfer is valid
          if (source.armies <= transferAmount) {
            console.error(" Not enough armies in source territory");
            return false;
          }

          // Execute the transfer
          source.armies -= transferAmount;
          destination.armies = transferAmount;
          destination.owner = source.owner;

          console.log(" Fallback transfer completed successfully");

          // Hide the transfer modal
          GameUtils.safeSetStyle("unit-transfer-modal", "display", "none");

          return { success: true };
        } catch (error) {
          console.error(" Error during transfer:", error);
          GameUtils.safeUpdateElement(
            "transfer-error-message",
            "textContent",
            "Transfer error: " + error.message
          );
          return false;
        } finally {
          // Reset flag after a short delay to allow for next transfer
          setTimeout(() => {
            transferInProgress = false;
          }, 1000);
        }
      };

      // REMOVED: Legacy territory ownership and transfer code - handled by CombatUI now

      // Add input event listeners for real-time preview updates
      document.addEventListener("DOMContentLoaded", function () {
        setTimeout(function () {
          const attackerInput = document.getElementById("attacker-remaining");
          const defenderInput = document.getElementById("defender-remaining");

          if (attackerInput) {
            attackerInput.addEventListener("input", window.updateBattlePreview);
          }
          if (defenderInput) {
            defenderInput.addEventListener("input", window.updateBattlePreview);
          }

          // Add transfer modal event listeners
          const transferSlider = document.getElementById("transfer-slider");
          const transferInput = document.getElementById("transfer-input");

          if (transferSlider) {
            transferSlider.addEventListener("input", function () {
              const value = parseInt(this.value);
              window.transferState.currentTransfer = value;
              window.GameUtils.safeSetProperty(
                "transfer-input",
                "value",
                value
              );
              window.updateTransferPreview();
            });
          }

          if (transferInput) {
            transferInput.addEventListener("input", function () {
              const value = parseInt(this.value) || 1;
              const minTransfer = window.transferState.minTransfer || 1;
              const maxTransfer = window.transferState.maxTransfer || 1;

              if (value >= minTransfer && value <= maxTransfer) {
                window.transferState.currentTransfer = value;
                window.GameUtils.safeSetProperty(
                  "transfer-slider",
                  "value",
                  value
                );
                window.updateTransferPreview();
              }
            });
          }
        }, 1000);
      });

      /**
       * Ensure all attack modal elements exist at page load
       * This prevents elements from being created dynamically later
       */
      window.ensureAttackModalElements = function () {
        console.log(" Pre-initializing attack modal elements");
        const attackModal = document.getElementById("attack-modal");
        if (!attackModal) {
          console.error(" Attack modal not found during pre-initialization");
          return;
        }

        // First make sure modal content exists
        let modalContent = attackModal.querySelector(".modal-content");
        if (!modalContent) {
          console.log(" Creating attack modal content");
          modalContent = document.createElement("div");
          modalContent.className = "modal-content attack-modal-content";
          attackModal.appendChild(modalContent);
        }

        // Create attack selection container if needed
        let attackSelection = attackModal.querySelector(
          "#attack-modal-selection"
        );
        if (!attackSelection) {
          console.log(" Creating attack-modal-selection");
          attackSelection = document.createElement("div");
          attackSelection.id = "attack-modal-selection";
          attackSelection.className = "attack-selection";
          modalContent.appendChild(attackSelection);
        }

        // Create territory containers if needed
        let attackTerritory = attackModal.querySelector(".attack-territory");
        if (!attackTerritory) {
          console.log(" Creating attack-territory container");
          attackTerritory = document.createElement("div");
          attackTerritory.className = "attack-territory";

          // Add label
          const label = document.createElement("div");
          label.className = "territory-label";
          label.textContent = " Attacking From";
          attackTerritory.appendChild(label);

          attackSelection.appendChild(attackTerritory);
        }

        // Add separator if needed
        let separator = attackSelection.querySelector(".attack-vs");
        if (!separator) {
          console.log(" Creating attack-vs separator");
          separator = document.createElement("div");
          separator.className = "attack-vs";
          separator.textContent = "VS";
          attackSelection.appendChild(separator);
        }

        // Create defend territory container if needed
        let defendTerritory = attackModal.querySelector(".defend-territory");
        if (!defendTerritory) {
          console.log(" Creating defend-territory container");
          defendTerritory = document.createElement("div");
          defendTerritory.className = "defend-territory";

          // Add label
          const label = document.createElement("div");
          label.className = "territory-label";
          label.textContent = " Defending";
          defendTerritory.appendChild(label);

          attackSelection.appendChild(defendTerritory);
        }

        // Create critical territory selection elements
        const criticalElements = [
          {
            id: "attack-modal-attacking-name",
            parent: attackTerritory,
            className: "territory-name",
            text: "-",
          },
          {
            id: "attack-modal-attacking-armies",
            parent: attackTerritory,
            className: "territory-armies",
            text: "0 armies",
          },
          {
            id: "attack-modal-defending-name",
            parent: defendTerritory,
            className: "territory-name",
            text: "Select target",
          },
          {
            id: "attack-modal-defending-armies",
            parent: defendTerritory,
            className: "territory-armies",
            text: "0 armies",
          },
        ];

        criticalElements.forEach((config) => {
          if (!document.getElementById(config.id)) {
            console.log(` Creating critical element: ${config.id}`);
            const element = document.createElement("div");
            element.id = config.id;
            element.className = config.className;
            element.textContent = config.text;
            config.parent.appendChild(element);
          }
        });

        console.log(" Pre-initialization of attack modal complete");
      };

      // Initialize continent system and other features when game loads
      document.addEventListener("DOMContentLoaded", function () {
        // PRE-INITIALIZE ATTACK MODAL ELEMENTS
        // This needs to run as early as possible to ensure DOM is ready
        window.ensureAttackModalElements();

        setTimeout(function () {
          // Continent system removed - initialization no longer needed

          // Initialize phase display
          GameUtils.safeUpdatePhaseDisplay();

          // Add territory click listeners for attack phase
          setTimeout(function () {
            const territories = document.querySelectorAll(".territory");
            territories.forEach((territory) => {
              territory.addEventListener("click", function () {
                const territoryId = this.id;
                if (territoryId) {
                  // Use the new unified territory click handler
                  window.handleTerritoryClick(territoryId);
                }
              });
            });
          }, 2000);
        }, 1000);

        // Update attack panel visibility when phase changes
        const observer = new MutationObserver(function (mutations) {
          mutations.forEach(function (mutation) {
            if (
              mutation.type === "childList" ||
              mutation.type === "characterData"
            ) {
              window.updateAttackPanelVisibility();
            }
          });
        });

        // Note: Observer for phase changes removed since phase-indicator was removed
        // Phase changes are now handled through the phase management system
      });

      // Backward compatibility shims for legacy code
      window.handleTerritoryClickForAttack = function (territoryId) {
        console.warn(
          "  handleTerritoryClickForAttack is deprecated. Using new handleTerritoryClick."
        );
        if (typeof window.handleTerritoryClick === "function") {
          return window.handleTerritoryClick(territoryId);
        } else {
          console.error(" New combat system not initialized");
        }
      };

      /**
       * ========================================================================
       * DYNAMIC TERRITORY OPACITY INTEGRATION - FIXED
       * Ensures opacity updates are called at all critical game events
       * ========================================================================
       */
      (function initializeDynamicOpacitySystem() {
        console.log(' Initializing Dynamic Territory Opacity System...');
        
        let opacitySystemReady = false;
        
        // Wait for game to fully initialize with better detection
        function setupOpacityIntegration(retryCount = 0) {
          const maxRetries = 20; // Maximum 10 seconds of retries
          
          if (retryCount >= maxRetries) {
            console.error(' Failed to setup opacity integration after 20 retries. Components not available:', {
              riskUI: !!window.riskUI,
              colorManager: !!(window.riskUI && window.riskUI.colorManager),
              gameState: !!(window.gameState && window.gameState.territories)
            });
            return;
          }
          
          // Check for all required components
          if (!window.riskUI) {
            console.warn(` RiskUI not available, retrying in 500ms... (${retryCount + 1}/${maxRetries})`);
            setTimeout(() => setupOpacityIntegration(retryCount + 1), 500);
            return;
          }
          
          if (!window.riskUI.colorManager) {
            console.warn(` ColorManager not available, retrying in 500ms... (${retryCount + 1}/${maxRetries})`);
            setTimeout(() => setupOpacityIntegration(retryCount + 1), 500);
            return;
          }
          
          if (!window.gameState || !window.gameState.territories) {
            console.warn(` GameState not available, retrying in 500ms... (${retryCount + 1}/${maxRetries})`);
            setTimeout(() => setupOpacityIntegration(retryCount + 1), 500);
            return;
          }
          
          console.log(' All components available, setting up opacity integration');
          
          // 1. Initial opacity setup
          try {
            window.riskUI.colorManager.refreshAllTerritories(window.gameState);
            console.log(' Initial territory opacities set');
          } catch (error) {
            console.error(' Error setting initial opacities:', error);
          }
          
          // 2. Hook into territory display updates
          if (window.riskUI.updateTerritoryDisplay) {
            const originalUpdateTerritoryDisplay = window.riskUI.updateTerritoryDisplay;
            window.riskUI.updateTerritoryDisplay = function(territoryId) {
              const result = originalUpdateTerritoryDisplay.call(this, territoryId);
              
              // Update opacity after display update
              try {
                if (this.colorManager && window.gameState) {
                  const territory = window.gameState.territories[territoryId];
                  if (territory && territory.owner) {
                    this.colorManager.updateTerritoryColorWithOpacity(
                      territoryId, 
                      territory.owner, 
                      window.gameState
                    );
                  }
                }
              } catch (error) {
                console.warn('Error updating opacity in updateTerritoryDisplay:', error);
              }
              
              return result;
            };
            console.log(' Hooked into updateTerritoryDisplay');
          }
          
          // 3. Hook into army count updates
          if (window.riskUI.updateTerritoryArmies) {
            const originalUpdateTerritoryArmies = window.riskUI.updateTerritoryArmies;
            window.riskUI.updateTerritoryArmies = function(territoryId, armies) {
              const result = originalUpdateTerritoryArmies.call(this, territoryId, armies);
              
              // Refresh ALL territory opacities since max armies might have changed
              try {
                if (this.colorManager && window.gameState) {
                  this.colorManager.refreshAllTerritories(window.gameState);
                }
              } catch (error) {
                console.warn('Error refreshing opacities in updateTerritoryArmies:', error);
              }
              
              return result;
            };
            console.log(' Hooked into updateTerritoryArmies');
          }
          
          // 4. Hook into ReinforcementManager if available
          if (window.riskUI.reinforcementManager && window.riskUI.reinforcementManager.deployArmies) {
            const originalDeployArmies = window.riskUI.reinforcementManager.deployArmies;
            window.riskUI.reinforcementManager.deployArmies = function(...args) {
              const result = originalDeployArmies.apply(this, args);
              
              // Refresh opacities after deployment
              try {
                if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                  window.riskUI.colorManager.refreshAllTerritories(window.gameState);
                }
              } catch (error) {
                console.warn('Error refreshing opacities after deployment:', error);
              }
              
              return result;
            };
            console.log(' Hooked into ReinforcementManager.deployArmies');
          }
          
          // 5. Hook into FortificationManager if available
          if (window.riskUI.fortificationManager && window.riskUI.fortificationManager.executeFortification) {
            const originalExecuteFortification = window.riskUI.fortificationManager.executeFortification;
            window.riskUI.fortificationManager.executeFortification = function(...args) {
              const result = originalExecuteFortification.apply(this, args);
              
              // Refresh opacities after fortification
              try {
                if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                  window.riskUI.colorManager.refreshAllTerritories(window.gameState);
                }
              } catch (error) {
                console.warn('Error refreshing opacities after fortification:', error);
              }
              
              return result;
            };
            console.log(' Hooked into FortificationManager.executeFortification');
          }
          
          // 6. Hook into battle resolution (via custom events)
          window.addEventListener('battleResolved', function(event) {
            console.log(' Battle resolved, updating territory opacities');
            try {
              if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                window.riskUI.colorManager.refreshAllTerritories(window.gameState);
              }
            } catch (error) {
              console.warn('Error refreshing opacities after battle:', error);
            }
          });
          
          // 7. Hook into territory conquest (via custom events)
          window.addEventListener('territoryConquered', function(event) {
            console.log(' Territory conquered, updating all opacities');
            setTimeout(function() {
              try {
                if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                  window.riskUI.colorManager.refreshAllTerritories(window.gameState);
                }
              } catch (error) {
                console.warn('Error refreshing opacities after conquest:', error);
              }
            }, 100);
          });
          
          // 8. Hook into phase changes
          if (window.gameState && typeof window.gameState.setPhase === 'function') {
            const originalSetPhase = window.gameState.setPhase;
            window.gameState.setPhase = function(newPhase) {
              const result = originalSetPhase.call(this, newPhase);
              
              // Refresh opacities on phase change
              try {
                if (window.riskUI && window.riskUI.colorManager) {
                  window.riskUI.colorManager.refreshAllTerritories(this);
                }
              } catch (error) {
                console.warn('Error refreshing opacities on phase change:', error);
              }
              
              return result;
            };
            console.log(' Hooked into phase changes');
          }
          
          // 9. Create global refresh function
          window.refreshTerritoryOpacities = function() {
            try {
              if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                window.riskUI.colorManager.refreshAllTerritories(window.gameState);
                console.log(' Territory opacities manually refreshed');
                return true;
              }
              console.warn(' Cannot refresh opacities - system not ready');
              return false;
            } catch (error) {
              console.error('Error refreshing opacities:', error);
              return false;
            }
          };
          
          // 10. Enhanced updateTerritoryOwnershipVisuals
          const originalUpdateOwnership = window.updateTerritoryOwnershipVisuals;
          window.updateTerritoryOwnershipVisuals = function(territoryId, newOwner) {
            if (originalUpdateOwnership) {
              originalUpdateOwnership(territoryId, newOwner);
            }
            
            // Update with dynamic opacity
            try {
              if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                window.riskUI.colorManager.updateTerritoryColorWithOpacity(
                  territoryId,
                  newOwner,
                  window.gameState
                );
              }
            } catch (error) {
              console.warn('Error updating opacity in updateTerritoryOwnershipVisuals:', error);
            }
          };
          
          // 11. Hook confirmTransfer
          const originalConfirmTransfer = window.confirmTransfer;
          window.confirmTransfer = function() {
            const result = originalConfirmTransfer ? originalConfirmTransfer.apply(this, arguments) : null;
            
            setTimeout(function() {
              try {
                if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                  window.riskUI.colorManager.refreshAllTerritories(window.gameState);
                  console.log(' Opacities refreshed after unit transfer');
                }
              } catch (error) {
                console.warn('Error refreshing opacities after transfer:', error);
              }
            }, 100);
            
            return result;
          };
          
          // 12. Hook cancelTransfer
          const originalCancelTransfer = window.cancelTransfer;
          window.cancelTransfer = function() {
            const result = originalCancelTransfer ? originalCancelTransfer.apply(this, arguments) : null;
            
            setTimeout(function() {
              try {
                if (window.riskUI && window.riskUI.colorManager && window.gameState) {
                  window.riskUI.colorManager.refreshAllTerritories(window.gameState);
                  console.log(' Opacities refreshed after minimum transfer');
                }
              } catch (error) {
                console.warn('Error refreshing opacities after cancel transfer:', error);
              }
            }, 100);
            
            return result;
          };
          
          // 13. Periodic refresh (fallback for missed updates)
          setInterval(function() {
            if (opacitySystemReady && window.gameState && 
                window.gameState.phase !== 'ended' && 
                window.gameState.phase !== 'victory') {
              try {
                window.refreshTerritoryOpacities();
              } catch (error) {
                // Silent fail for periodic refresh
              }
            }
          }, 5000);
          
          opacitySystemReady = true;
          console.log(' Dynamic Territory Opacity System fully integrated');
          console.log(' Manual refresh: window.refreshTerritoryOpacities()');
        }
        
        // Setup will be called from main game initialization
        // No longer auto-starting here to prevent infinite loops
      })();
    </script>

    <!-- Music Player Initialization -->
    <script>
      // Initialize music player for game
      let musicPlayer;
      (function() {
        musicPlayer = new MusicPlayer();
        
        // Try to start music immediately
        musicPlayer.start();
        
        // Also try to start on first user interaction (for browsers that block autoplay)
        const startMusicOnInteraction = () => {
          if (!musicPlayer.isPlaying) {
            musicPlayer.start();
          }
          // Remove listeners after first interaction
          document.removeEventListener('click', startMusicOnInteraction);
          document.removeEventListener('keydown', startMusicOnInteraction);
        };
        
        document.addEventListener('click', startMusicOnInteraction);
        document.addEventListener('keydown', startMusicOnInteraction);
        
        // Close music manager modal when clicking outside
        const musicModal = document.getElementById('musicManagerModal');
        if (musicModal) {
          musicModal.addEventListener('click', (e) => {
            if (e.target === musicModal) {
              musicPlayer.closeMusicManager();
            }
          });
        }
        
        console.log(' Music player initialized. Controls: M (mute/unmute), + (next), - (previous), N (music manager)');
      })();
    </script>

    <!-- Custom Cursor Animation Script -->
    <script>
      // Custom cursor with click animation
      const customCursor = document.querySelector('.custom-cursor');
      let mouseX = 0;
      let mouseY = 0;

      // Update cursor position
      document.addEventListener('mousemove', (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
          customCursor.style.left = mouseX + 'px';
          customCursor.style.top = mouseY + 'px';
      });

      // Click animation
      document.addEventListener('mousedown', () => {
          customCursor.classList.add('clicking');
      });

      document.addEventListener('mouseup', () => {
          customCursor.classList.remove('clicking');
      });

      // Activate custom cursor
      document.body.classList.add('custom-cursor-active');

      // Hide cursor when it leaves the window
      document.addEventListener('mouseleave', () => {
          customCursor.style.opacity = '0';
      });

      document.addEventListener('mouseenter', () => {
          customCursor.style.opacity = '1';
      });
    </script>
  </body>
    <!-- Keyboard Navigation for Territory Selection -->
    <script>
    (function() {
      const HOVER_CLASS = 'keyboard-hover-territory';
      const style = document.createElement('style');
      style.textContent = `
        .${HOVER_CLASS} {
          stroke: #ffd700 !important;
          stroke-width: 7px !important;
          filter: drop-shadow(0 0 12px #ffd700);
          z-index: 9999;
          transition: stroke 0.1s, filter 0.1s;
        }
      `;
      document.head.appendChild(style);

      let ownedTerritories = [];
      let hoveredIndex = -1;
      let lastHoveredId = null;

      function getCurrentPlayer() {
        return window.gameState?.getCurrentPlayer?.();
      }
      function getTerritories() {
        return window.gameState?.territories || {};
      }
      function refreshOwnedTerritories() {
        const player = getCurrentPlayer();
        const terrs = getTerritories();
        const phase = window.gameState?.phase;
        
        // In attack phase, only show territories with more than 1 army
        if (phase === 'attack') {
          ownedTerritories = Object.keys(terrs).filter(id => 
            terrs[id].owner === player && terrs[id].armies > 1
          );
        } else {
          ownedTerritories = Object.keys(terrs).filter(id => terrs[id].owner === player);
        }
        
        if (ownedTerritories.length === 0) hoveredIndex = -1;
        else if (hoveredIndex < 0 || hoveredIndex >= ownedTerritories.length) hoveredIndex = 0;
      }
      function clearKeyboardHover() {
        if (lastHoveredId) {
          const el = document.getElementById(lastHoveredId);
          if (el) {
            el.classList.remove(HOVER_CLASS);
            el.dispatchEvent(new Event('mouseleave'));
          }
          lastHoveredId = null;
        }
      }
      function setKeyboardHover(id) {
        clearKeyboardHover();
        const el = document.getElementById(id);
        if (el) {
          el.classList.add(HOVER_CLASS);
          el.dispatchEvent(new Event('mouseenter'));
          lastHoveredId = id;
        }
      }
      function getTerritoryCenter(territoryId) {
        const el = document.getElementById(territoryId);
        if (!el) return null;
        try {
          const bbox = el.getBBox();
          return {
            x: bbox.x + bbox.width / 2,
            y: bbox.y + bbox.height / 2
          };
        } catch (e) {
          return null;
        }
      }

      function findClosestInDirection(currentId, direction) {
        if (!ownedTerritories.length) return null;
        
        const currentCenter = getTerritoryCenter(currentId);
        if (!currentCenter) return null;

        let bestMatch = null;
        let bestScore = Infinity;

        ownedTerritories.forEach(tid => {
          if (tid === currentId) return;
          
          const center = getTerritoryCenter(tid);
          if (!center) return;

          const dx = center.x - currentCenter.x;
          const dy = center.y - currentCenter.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Check if territory is in the correct direction
          let isInDirection = false;
          let directionScore = 0;

          switch(direction) {
            case 'up':
              // Must be above (negative dy)
              if (dy < -10) {
                isInDirection = true;
                // Prefer territories that are more directly above (less horizontal deviation)
                directionScore = distance + Math.abs(dx) * 0.5;
              }
              break;
            case 'down':
              // Must be below (positive dy)
              if (dy > 10) {
                isInDirection = true;
                directionScore = distance + Math.abs(dx) * 0.5;
              }
              break;
            case 'left':
              // Must be to the left (negative dx)
              if (dx < -10) {
                isInDirection = true;
                // Prefer territories that are more directly left (less vertical deviation)
                directionScore = distance + Math.abs(dy) * 0.5;
              }
              break;
            case 'right':
              // Must be to the right (positive dx)
              if (dx > 10) {
                isInDirection = true;
                directionScore = distance + Math.abs(dy) * 0.5;
              }
              break;
          }

          if (isInDirection && directionScore < bestScore) {
            bestScore = directionScore;
            bestMatch = tid;
          }
        });

        return bestMatch;
      }

      function moveHover(delta) {
        if (!ownedTerritories.length) return;
        hoveredIndex = (hoveredIndex + delta + ownedTerritories.length) % ownedTerritories.length;
        setKeyboardHover(ownedTerritories[hoveredIndex]);
      }

      function moveInDirection(direction) {
        if (!ownedTerritories.length) return;
        
        // If no territory is currently hovered, start with the first one
        if (hoveredIndex === -1 || hoveredIndex >= ownedTerritories.length) {
          hoveredIndex = 0;
          setKeyboardHover(ownedTerritories[hoveredIndex]);
          return;
        }

        const currentId = ownedTerritories[hoveredIndex];
        const nextId = findClosestInDirection(currentId, direction);
        
        if (nextId) {
          hoveredIndex = ownedTerritories.indexOf(nextId);
          setKeyboardHover(nextId);
        }
      }

      document.addEventListener('keydown', function(e) {
        if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName) || document.activeElement.isContentEditable) return;
        if (document.querySelector('.modal[style*="display: flex"], .modal[style*="display: block"]')) return;

        refreshOwnedTerritories();
        if (!ownedTerritories.length) return;

        let handled = false;
        if (e.key === "ArrowUp") {
          moveInDirection('up');
          handled = true;
        }
        if (e.key === "ArrowDown") {
          moveInDirection('down');
          handled = true;
        }
        if (e.key === "ArrowLeft") {
          moveInDirection('left');
          handled = true;
        }
        if (e.key === "ArrowRight") {
          moveInDirection('right');
          handled = true;
        }
        if (e.key === 'Enter' && hoveredIndex !== -1) {
          const tid = ownedTerritories[hoveredIndex];
          const el = document.getElementById(tid);

          // Special handling for attack phase - open target selection modal
          if (window.gameState && window.gameState.phase === 'attack') {
            const territory = window.gameState.territories?.[tid];
            if (territory && territory.armies > 1 && typeof window.openTargetSelectionModal === 'function') {
              e.preventDefault();
              // Open target selection modal to choose enemy territory
              setTimeout(() => window.openTargetSelectionModal(tid), 100);
              return;
            }
          }

          // 1. Dispatch a real MouseEvent (for event delegation)
          if (el) {
            el.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
          }
          // 2. Always call the main handler directly
          if (typeof window.handleTerritoryClick === 'function') {
            window.handleTerritoryClick(tid);
          }
          // 3. Open modal if needed for the phase (non-attack phases)
          if (window.gameState && window.gameState.phase) {
            if (window.gameState.phase === 'reinforcement' && typeof window.openDeploymentModal === 'function') {
              setTimeout(() => window.openDeploymentModal(), 100);
            }
            if (window.gameState.phase === 'fortification' && typeof window.openFortificationModal === 'function') {
              setTimeout(() => window.openFortificationModal(), 100);
            }
          }
          handled = true;
        }
        if (handled) {
          e.preventDefault();
          setKeyboardHover(ownedTerritories[hoveredIndex]);
        }
      });

      if (window.gameState && typeof window.gameState.addEventListener === 'function') {
        window.gameState.addEventListener('phaseChanged', () => {
          hoveredIndex = 0;
          refreshOwnedTerritories();
          clearKeyboardHover();
          if (hoveredIndex !== -1 && ownedTerritories.length) setKeyboardHover(ownedTerritories[hoveredIndex]);
        });
      }

      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(() => {
          refreshOwnedTerritories();
          if (hoveredIndex !== -1 && ownedTerritories.length) setKeyboardHover(ownedTerritories[hoveredIndex]);
        }, 2000);
      });
    })();
    </script>

    <!-- Target Selection Modal Keyboard Navigation -->
    <script>
    (function() {
      document.addEventListener('keydown', function(e) {
        const modal = document.getElementById('target-selection-modal');
        if (!modal || modal.style.display !== 'flex') return;

        // Check if we're focused on an input element
        if (['INPUT','TEXTAREA'].includes(document.activeElement.tagName) || document.activeElement.isContentEditable) return;

        let handled = false;

        if (e.key === 'ArrowUp') {
          window.navigateTargetSelection('up');
          handled = true;
        } else if (e.key === 'ArrowDown') {
          window.navigateTargetSelection('down');
          handled = true;
        } else if (e.key === 'Enter') {
          window.selectTargetFromModal();
          handled = true;
        } else if (e.key === 'Escape') {
          window.closeTargetSelectionModal();
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
        }
      });
    })();
    </script>

    <!-- Spacebar to End Turn/Phase -->
    <script>
    (function() {
      document.addEventListener('keydown', function(e) {
        // Check if spacebar was pressed
        if (e.code === 'Space' || e.keyCode === 32) {
          // Prevent default spacebar behavior (page scroll)
          e.preventDefault();
          
          // Get the end turn button
          const endTurnBtn = document.getElementById('end-turn-enhanced');
          
          // Check if button exists and is not disabled
          if (endTurnBtn && !endTurnBtn.disabled) {
            console.log(' Spacebar pressed - triggering end turn/phase');
            
            // Trigger the button click
            endTurnBtn.click();
            
            // Optional: Add visual feedback that spacebar was pressed
            endTurnBtn.style.transform = 'scale(0.95)';
            setTimeout(() => {
              endTurnBtn.style.transform = '';
            }, 100);
          } else if (endTurnBtn && endTurnBtn.disabled) {
            console.log(' Spacebar pressed but end turn button is disabled');
          }
        }
      });
      
      console.log(' Spacebar shortcut initialized - Press SPACE to end turn/phase');
    })();
    </script>

    <!-- Mobile Navigation Button Handlers -->
    <script>
    (function() {
      // Mobile Navigation Button Handlers
      document.addEventListener('DOMContentLoaded', function() {
        // Music button handler
        const musicButton = document.getElementById('mobile-music-button');
        if (musicButton) {
          musicButton.addEventListener('click', function() {
            if (window.musicPlayer && typeof window.musicPlayer.openMusicManager === 'function') {
              window.musicPlayer.openMusicManager();
            } else {
              // Fallback: trigger 'n' key event
              const event = new KeyboardEvent('keydown', { key: 'n', code: 'KeyN' });
              document.dispatchEvent(event);
            }
          });
        }

        // Sizing/Calibration button handler
        const sizingButton = document.getElementById('mobile-sizing-button');
        if (sizingButton) {
          sizingButton.addEventListener('click', function() {
            // Toggle the existing MapCalibration system
            if (window.mapCalibration) {
              if (window.mapCalibration.isDevelopmentMode) {
                window.mapCalibration.disableDevelopmentMode();
              } else {
                window.mapCalibration.enableDevelopmentMode();
              }
            }
          });
        }
      });

      console.log(' Mobile navigation buttons initialized');
    })();
    </script>

    <!-- Unit Removal During Deployment - TURN 0 APPROACH (SIMPLIFIED) -->
    <script>
    (function() {
      // 
      // UNIT REMOVAL SYSTEM - Turn-based tracking (Turn 0 = Startup)
      // 
      
      window.deploymentTracking = window.deploymentTracking || {
        phaseStartArmies: {},
        currentTrackingId: null  // Format: "turn0_playerRed", "turn1_playerBlue", etc.
      };

      /**
       * Get current tracking ID based on turn number and player
       * Turn 0 = Startup phase
       * Turn 1+ = Regular reinforcement phases
       */
      function getCurrentTrackingId() {
        const phase = window.gameState?.phase;
        const currentPlayer = window.gameState?.getCurrentPlayer();
        
        // Only track during deployment phases
        if (phase !== 'startup' && phase !== 'reinforcement') {
          return null;
        }
        
        // Get turn number (startup = 0, then 1, 2, 3...)
        let turnNumber = window.gameState?.turnNumber || 0;
        
        // If in startup phase, force turn to 0
        if (phase === 'startup') {
          turnNumber = 0;
        }
        
        return `turn${turnNumber}_${currentPlayer}`;
      }

      /**
       * Initialize/reset phase tracking for current player's deployment
       */
      function resetPhaseTracking() {
        const newTrackingId = getCurrentTrackingId();
        
        if (!newTrackingId) {
          console.log(` Not in deployment phase - clearing tracking`);
          window.deploymentTracking.phaseStartArmies = {};
          window.deploymentTracking.currentTrackingId = null;
          return;
        }
        
        // If already tracking this exact phase, don't reset
        if (window.deploymentTracking.currentTrackingId === newTrackingId) {
          console.log(` Already tracking: ${newTrackingId}`);
          return;
        }
        
        // Reset tracking for new player/turn
        const oldId = window.deploymentTracking.currentTrackingId;
        console.log(` Tracking reset: ${oldId}  ${newTrackingId}`);
        
        window.deploymentTracking.currentTrackingId = newTrackingId;
        window.deploymentTracking.phaseStartArmies = {};
        
        // Capture starting armies for all territories
        if (window.gameState?.territories) {
          Object.keys(window.gameState.territories).forEach(territoryId => {
            const territory = window.gameState.territories[territoryId];
            window.deploymentTracking.phaseStartArmies[territoryId] = territory.armies;
          });
        }
        
        console.log(` Tracking initialized: ${newTrackingId}`);
        console.log(`   Captured ${Object.keys(window.deploymentTracking.phaseStartArmies).length} territories`);
      }

      /**
       * Alias for backward compatibility
       */
      function initializePhaseTracking() {
        resetPhaseTracking();
      }

      /**
       * Calculate how many units can be removed from territory
       * Only allows removal of units deployed in CURRENT turn's deployment phase
       */
      function getRemovableUnits(territoryId) {
        const territory = window.gameState?.territories[territoryId];
        if (!territory) return 0;

        const currentTrackingId = getCurrentTrackingId();
        
        // Verify we're in a deployment phase
        if (!currentTrackingId) {
          console.warn(` Not in deployment phase`);
          return 0;
        }

        // Verify tracking matches current state
        if (window.deploymentTracking.currentTrackingId !== currentTrackingId) {
          console.warn(` Tracking mismatch for ${territoryId}:`);
          console.warn(`   Expected: ${currentTrackingId}`);
          console.warn(`   Actual: ${window.deploymentTracking.currentTrackingId}`);
          resetPhaseTracking(); // Auto-fix
          return 0;
        }

        // Get starting armies for this territory
        const startingArmies = window.deploymentTracking.phaseStartArmies[territoryId];
        
        if (startingArmies === undefined) {
          console.warn(` No tracking data for ${territoryId}`);
          return 0;
        }
        
        const currentArmies = territory.armies;
        const deployedThisTurn = currentArmies - startingArmies;
        
        // Can only remove units deployed THIS TURN, and must leave at least 1 army
        const removable = Math.max(0, Math.min(deployedThisTurn, currentArmies - 1));
        
        console.log(` ${territoryId} (${currentTrackingId}):`);
        console.log(`   Starting: ${startingArmies}, Current: ${currentArmies}`);
        console.log(`   Deployed: ${deployedThisTurn}, Removable: ${removable}`);
        
        return removable;
      }

      /**
       * Remove one unit from territory during deployment phase
       */
      document.addEventListener('keydown', function(e) {
        if (e.key !== 'Delete' && e.key !== 'Backspace') return;
        if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

        const phase = window.gameState?.phase;
        if (phase !== 'startup' && phase !== 'reinforcement') {
          console.log(' Unit removal only available during deployment phases');
          return;
        }

        e.preventDefault();

        const territoryId = getSelectedTerritory();
        if (!territoryId) {
          console.log(' No territory selected');
          return;
        }

        const territory = window.gameState.territories[territoryId];
        const currentPlayer = window.gameState.getCurrentPlayer();
        
        const trackingId = getCurrentTrackingId();
        console.log(` DELETE: ${territoryId} (Tracking: ${window.deploymentTracking.currentTrackingId})`);
        
        // Check ownership
        if (!territory || territory.owner !== currentPlayer) {
          showTemporaryMessage(' Can only remove from your territories', 'error');
          return;
        }
        
        // Check minimum army requirement
        if (territory.armies <= 1) {
          showTemporaryMessage(' Territory must keep at least 1 army', 'error');
          return;
        }

        // Check if units were deployed THIS TURN
        const removable = getRemovableUnits(territoryId);
        
        if (removable <= 0) {
          console.log(` No removable units in ${territoryId}`);
          showTemporaryMessage(' No units deployed this turn - previous units are locked', 'error');
          return;
        }

        // Remove unit and return to pool
        territory.armies -= 1;
        window.gameState.remainingArmies[currentPlayer] = (window.gameState.remainingArmies[currentPlayer] || 0) + 1;

        console.log(` Removed 1 unit (${removable - 1} more removable)`);

        // Update UI
        updateTerritoryVisuals(territoryId);
        updateReinforcementPanel();
        showTemporaryMessage(` Unit removed from ${territoryId.replace(/-/g, ' ')}`, 'success');
        
        if (window.triggerReinforcementPop) window.triggerReinforcementPop();
        if (window.audioManager?.play) window.audioManager.play('remove-unit');
      });

      /**
       * Helper functions
       */
      function updateTerritoryVisuals(id) {
        const armies = window.gameState.territories[id].armies;
        if (window.riskUI?.updateTerritoryArmies) window.riskUI.updateTerritoryArmies(id, armies);
        if (window.riskUI?.updateTerritoryDisplay) window.riskUI.updateTerritoryDisplay(id);
        if (window.refreshTerritoryOpacities) window.refreshTerritoryOpacities();
      }

      function updateReinforcementPanel() {
        if (window.updateReinforcementPanel) window.updateReinforcementPanel();
      }

      function showTemporaryMessage(msg, type = 'info') {
        if (window.showPhaseCompletionNotice) {
          window.showPhaseCompletionNotice(msg, type);
        } else {
          console.log(`[${type}] ${msg}`);
        }
      }

      // Track last clicked territory
      document.addEventListener('click', (e) => {
        const territory = e.target.closest('.territory');
        if (territory?.id) window.lastClickedTerritory = territory.id;
      });

      /**
       * Get the currently selected/hovered territory
       */
      function getSelectedTerritory() {
        // Check for keyboard navigation hover
        const keyboardHovered = document.querySelector('.keyboard-hover-territory');
        if (keyboardHovered) {
          return keyboardHovered.id;
        }

        // Check for combat UI selected territory
        if (window.combatUI?.selectedTerritory) {
          return window.combatUI.selectedTerritory;
        }

        // Check for attack state territory
        if (window.attackState?.attackingTerritory) {
          return window.attackState.attackingTerritory;
        }

        // Check for recently clicked territory (store in global)
        if (window.lastClickedTerritory) {
          return window.lastClickedTerritory;
        }

        return null;
      }

      // 
      // EVENT HOOKS - Reset tracking on phase/player changes
      // 

      // Hook into TurnManager
      document.addEventListener('DOMContentLoaded', function() {
        const hookTurnManager = setInterval(() => {
          if (window.riskUI?.turnManager) {
            clearInterval(hookTurnManager);
            
            // Hook advancePhase
            const origAdvancePhase = window.riskUI.turnManager.advancePhase;
            if (origAdvancePhase) {
              window.riskUI.turnManager.advancePhase = function() {
                const result = origAdvancePhase.apply(this, arguments);
                setTimeout(resetPhaseTracking, 50);
                return result;
              };
            }
            
            // Hook advancePlayer
            const origAdvancePlayer = window.riskUI.turnManager.advancePlayer;
            if (origAdvancePlayer) {
              window.riskUI.turnManager.advancePlayer = function() {
                const result = origAdvancePlayer.apply(this, arguments);
                setTimeout(resetPhaseTracking, 50);
                return result;
              };
            }
            
            console.log(' Hooked into TurnManager for tracking resets');
          }
        }, 100);
        
        // Initial tracking setup
        setTimeout(resetPhaseTracking, 1000);
      });

      // Safety net: Reset tracking on any territory click during deployment
      document.addEventListener('click', function(e) {
        const territory = e.target.closest('.territory');
        if (!territory?.id) return;
        
        const expectedId = getCurrentTrackingId();
        if (expectedId && window.deploymentTracking.currentTrackingId !== expectedId) {
          console.log(` Auto-fixing tracking mismatch on click`);
          resetPhaseTracking();
        }
      }, true);

      // 
      // UTILITY FUNCTIONS
      // 

      function updateTerritoryVisuals(id) {
        const armies = window.gameState.territories[id].armies;
        if (window.riskUI?.updateTerritoryArmies) window.riskUI.updateTerritoryArmies(id, armies);
        if (window.riskUI?.updateTerritoryDisplay) window.riskUI.updateTerritoryDisplay(id);
        if (window.refreshTerritoryOpacities) window.refreshTerritoryOpacities();
      }

      function updateReinforcementPanel() {
        if (window.updateReinforcementPanel) window.updateReinforcementPanel();
      }

      function showTemporaryMessage(msg, type = 'info') {
        if (window.showPhaseCompletionNotice) {
          window.showPhaseCompletionNotice(msg, type);
        } else {
          console.log(`[${type}] ${msg}`);
        }
      }

      function getSelectedTerritory() {
        const keyboardHovered = document.querySelector('.keyboard-hover-territory');
        if (keyboardHovered) return keyboardHovered.id;
        if (window.combatUI?.selectedTerritory) return window.combatUI.selectedTerritory;
        if (window.attackState?.attackingTerritory) return window.attackState.attackingTerritory;
        if (window.lastClickedTerritory) return window.lastClickedTerritory;
        return null;
      }

      document.addEventListener('click', (e) => {
        const territory = e.target.closest('.territory');
        if (territory?.id) window.lastClickedTerritory = territory.id;
      });

      // 
      // EXPOSE GLOBAL API
      // 

      window.getRemovableUnits = getRemovableUnits;
      window.resetPhaseTracking = resetPhaseTracking;
      window.initializePhaseTracking = initializePhaseTracking;
      window.getCurrentTrackingId = getCurrentTrackingId;

      console.log(' ');
      console.log(' UNIT REMOVAL SYSTEM INITIALIZED (TURN 0 APPROACH)');
      console.log(' Turn 0 = Startup (initial deployment)');
      console.log(' Turn 1+ = Regular reinforcement phases');
      console.log(' ');
    })();

    // EMERGENCY MANUAL INITIALIZATION - Run this if tracking isn't working
    // Copy-paste this into console: window.manualInitTracking()
    window.manualInitTracking = function() {
      if (!window.deploymentTracking) {
        window.deploymentTracking = { phaseStartArmies: {} };
      }
      
      const currentPhase = window.gameState?.phase;
      console.log(` Manual initialization for phase: ${currentPhase}`);
      
      if (currentPhase !== 'startup' && currentPhase !== 'reinforcement') {
        console.warn(' Not in a deployment phase!');
        return false;
      }
      
      window.deploymentTracking.phaseStartArmies = {};
      
      if (window.gameState?.territories) {
        Object.keys(window.gameState.territories).forEach(territoryId => {
          const territory = window.gameState.territories[territoryId];
          window.deploymentTracking.phaseStartArmies[territoryId] = territory.armies;
        });
      }
      
      console.log(` Manually initialized tracking for ${Object.keys(window.deploymentTracking.phaseStartArmies).length} territories`);
      console.log('Tracking data:', window.deploymentTracking.phaseStartArmies);
      return true;
    };

    // DIAGNOSTIC: Check what can be removed from a territory
    window.checkRemovable = function(territoryId) {
      if (!territoryId) {
        console.error(' Provide a territory ID, e.g.: window.checkRemovable("venezuela")');
        return;
      }
      
      const territory = window.gameState?.territories[territoryId];
      if (!territory) {
        console.error(` Territory "${territoryId}" not found`);
        return;
      }
      
      const tracking = window.deploymentTracking;
      const starting = tracking?.phaseStartArmies?.[territoryId];
      const current = territory.armies;
      const deployed = current - (starting || 0);
      const removable = window.getRemovableUnits?.(territoryId) || 0;
      
      console.log('');
      console.log(` TERRITORY REMOVAL ANALYSIS: ${territoryId}`);
      console.log('');
      console.log(`Owner: ${territory.owner}`);
      console.log(`Current Player: ${window.gameState?.getCurrentPlayer()}`);
      console.log(`Current Phase: ${window.gameState?.phase}`);
      console.log(`Turn Number: ${window.gameState?.turnNumber || 0}`);
      console.log('');
      console.log('TRACKING INFO:');
      console.log(`  Phase ID: ${tracking?.currentPhaseId || 'NOT SET'}`);
      console.log(`  Tracked Player: ${tracking?.currentPhasePlayer || 'NOT SET'}`);
      console.log('');
      console.log('ARMY COUNTS:');
      console.log(`  Starting armies (this phase): ${starting === undefined ? 'NOT TRACKED' : starting}`);
      console.log(`  Current armies: ${current}`);
      console.log(`  Deployed this phase: ${deployed}`);
      console.log(`  Removable units: ${removable}`);
      console.log('');
      console.log(`STATUS: ${removable > 0 ? ' CAN REMOVE UNITS' : ' CANNOT REMOVE UNITS'}`);
      
      if (starting === undefined) {
        console.warn(' WARNING: No tracking data! Phase tracking may not be initialized.');
        console.warn('   Try: window.resetPhaseTracking()');
      } else if (deployed <= 0) {
        console.warn(' All units were deployed in PREVIOUS phases (locked)');
      }
      console.log('');
    };

    // Add CSS animations for notifications
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideInFromLeft {
        from {
          transform: translateX(-100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes fadeOut {
        from {
          opacity: 1;
        }
        to {
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(style);
    </script>

    <!-- Mobile & Touch Interaction System -->
    <script>
    (function() {
      // 
      // MOBILE SIDEBAR TOGGLE & SWIPE GESTURES
      // 
      
      const sidebar = document.querySelector('.sidebar');
      const sidebarToggle = document.getElementById('sidebar-toggle');
      
      let touchStartY = 0;
      let touchStartTime = 0;
      let isSidebarDragging = false;
      
      if (!sidebar || !sidebarToggle) {
        console.warn(' Sidebar or toggle not found');
        return;
      }
      
      // Toggle sidebar with button (works for both landscape and portrait)
      sidebarToggle.addEventListener('click', function(e) {
        e.stopPropagation();
        sidebar.classList.toggle('expanded');
        
        // Update icon for landscape mode
        if (window.matchMedia('(orientation: landscape)').matches) {
          if (sidebar.classList.contains('expanded')) {
            sidebarToggle.textContent = '';
          } else {
            sidebarToggle.textContent = '';
          }
        }
      });
      
      // Portrait mode - tap on sidebar top area to expand/collapse
      sidebar.addEventListener('touchstart', function(e) {
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }, { passive: true });
      
      sidebar.addEventListener('touchend', function(e) {
        // Only in portrait mode
        if (!window.matchMedia('(orientation: portrait)').matches) return;
        
        const touchEndY = e.changedTouches[0].clientY;
        const touchEndTime = Date.now();
        const diff = touchStartY - touchEndY;
        const duration = touchEndTime - touchStartTime;
        
        // Get sidebar bounds
        const sidebarRect = sidebar.getBoundingClientRect();
        const tapY = e.changedTouches[0].clientY - sidebarRect.top;
        
        // If tapped near the top (within 80px) and didn't swipe much and was quick
        if (tapY < 80 && Math.abs(diff) < 30 && duration < 300) {
          e.preventDefault();
          sidebar.classList.toggle('expanded');
          console.log(' Sidebar toggled via tap');
        }
      }, { passive: false });
      
      // Close sidebar when clicking outside in landscape mode
      document.addEventListener('click', function(e) {
        if (window.matchMedia('(max-width: 1024px) and (orientation: landscape)').matches) {
          if (!sidebar.contains(e.target) && 
              !sidebarToggle.contains(e.target) && 
              sidebar.classList.contains('expanded')) {
            sidebar.classList.remove('expanded');
            sidebarToggle.textContent = '';
          }
        }
      });
      
      // Handle orientation changes
      window.addEventListener('orientationchange', function() {
        setTimeout(function() {
          // Reset sidebar state on orientation change
          sidebar.classList.remove('expanded');
          if (window.matchMedia('(orientation: landscape)').matches) {
            sidebarToggle.textContent = '';
          }
          console.log(' Orientation changed, sidebar reset');
        }, 100);
      });
      
      console.log(' Mobile sidebar gestures initialized');
      
      // 
      // PINCH-TO-ZOOM REMOVED - NOW HANDLED BY RiskMap.js
      // 
      // The RiskMap class now handles all zoom/pan functionality
      // including touch events for mobile devices. This ensures
      // all layers (background, map, SVG) stay synchronized.
      
      // 
      // ENHANCED TOUCH HANDLING FOR TERRITORIES
      // 
      
      let touchStartTime = 0;
      let touchMoved = false;
      
      // Add touch event listeners to all territories
      document.addEventListener('DOMContentLoaded', function() {
        const territories = document.querySelectorAll('.territory');
        
        territories.forEach(territory => {
          // Touch start
          territory.addEventListener('touchstart', function(e) {
            touchStartTime = Date.now();
            touchMoved = false;
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
          }, { passive: true });
          
          // Track if user is scrolling/panning
          territory.addEventListener('touchmove', function(e) {
            const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
            const deltaY = Math.abs(e.touches[0].clientY - touchStartY);
            
            if (deltaX > 10 || deltaY > 10) {
              touchMoved = true;
            }
          }, { passive: true });
          
          // Touch end - trigger click only if it was a tap (not a drag)
          territory.addEventListener('touchend', function(e) {
            const touchDuration = Date.now() - touchStartTime;
            
            // Only count as tap if: quick touch, didn't move much
            if (touchDuration < 500 && !touchMoved) {
              e.preventDefault();
              
              // Visual feedback
              territory.style.opacity = '0.7';
              setTimeout(() => {
                territory.style.opacity = '';
              }, 100);
              
              // Trigger the territory click handler
              const territoryId = territory.id;
              if (window.handleTerritoryClick) {
                window.handleTerritoryClick(territoryId);
              }
            }
          }, { passive: false });
        });
        
        console.log(` Touch handlers added to ${territories.length} territories`);
      });
      
      // 
      // PREVENT DOUBLE-TAP ZOOM ON IOS
      // 
      
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(e) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
          e.preventDefault();
        }
        lastTouchEnd = now;
      }, { passive: false });
      
      // 
      // RESPONSIVE BREAKPOINT DETECTION
      // 
      
      function detectDevice() {
        const width = window.innerWidth;
        
        if (width <= 480) {
          document.body.classList.add('mobile-phone');
          document.body.classList.remove('tablet', 'desktop');
          console.log(' Device: Mobile Phone');
        } else if (width <= 768) {
          document.body.classList.add('tablet');
          document.body.classList.remove('mobile-phone', 'desktop');
          console.log(' Device: Tablet');
        } else {
          document.body.classList.add('desktop');
          document.body.classList.remove('mobile-phone', 'tablet');
          console.log(' Device: Desktop');
        }
      }
      
      // Detect on load and on resize
      detectDevice();
      window.addEventListener('resize', detectDevice);
      
      // 
      // MODAL TOUCH IMPROVEMENTS
      // 
      
      // Make modals easier to close on mobile
      document.addEventListener('DOMContentLoaded', function() {
        const modals = document.querySelectorAll('.modal, [id*="modal"]');
        
        modals.forEach(modal => {
          modal.addEventListener('touchstart', function(e) {
            // Close modal if touching the backdrop
            if (e.target === modal) {
              const closeBtn = modal.querySelector('.close-btn, [onclick*="close"]');
              if (closeBtn) {
                closeBtn.click();
              }
            }
          });
        });
      });
      
      console.log(' Mobile & touch interaction system fully initialized');
    })();
    </script>
</html>

